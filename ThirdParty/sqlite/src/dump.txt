1.1          (drh      11-Apr-01): /*
1.20         (drh      16-Sep-01): ** 2001 September 15
1.1          (drh      11-Apr-01): **
1.20         (drh      16-Sep-01): ** The author disclaims copyright to this source code.  In place of
1.20         (drh      16-Sep-01): ** a legal notice, here is a blessing:
1.20         (drh      16-Sep-01): **
1.20         (drh      16-Sep-01): **    May you do good and not evil.
1.20         (drh      16-Sep-01): **    May you find forgiveness for yourself and forgive others.
1.20         (drh      16-Sep-01): **    May you share freely, never taking more than you give.
1.1          (drh      11-Apr-01): **
1.1          (drh      11-Apr-01): *************************************************************************
1.20         (drh      16-Sep-01): ** This is the implementation of the page cache subsystem or "pager".
1.1          (drh      11-Apr-01): ** 
1.20         (drh      16-Sep-01): ** The pager is used to access a database disk file.  It implements
1.20         (drh      16-Sep-01): ** atomic commit and rollback through the use of a journal file that
1.20         (drh      16-Sep-01): ** is separate from the database file.  The pager also implements file
1.20         (drh      16-Sep-01): ** locking to prevent two processes from writing the same database
1.20         (drh      16-Sep-01): ** file simultaneously, or one process from reading the database while
1.20         (drh      16-Sep-01): ** another is writing.
1.1          (drh      11-Apr-01): **
1.352        (drh      07-Aug-07): ** @(#) $Id: pager.c,v 1.351 2007/07/20 00:33:36 drh Exp $
1.1          (drh      11-Apr-01): */
1.202        (drh      28-Apr-05): #ifndef SQLITE_OMIT_DISKIO
1.3          (drh      15-Apr-01): #include "sqliteInt.h"
1.165        (drh      01-Oct-04): #include "os.h"
1.1          (drh      11-Apr-01): #include "pager.h"
1.1          (drh      11-Apr-01): #include <assert.h>
1.3          (drh      15-Apr-01): #include <string.h>
1.1          (drh      11-Apr-01): 
1.1          (drh      11-Apr-01): /*
1.68         (drh      16-Jan-03): ** Macros for troubleshooting.  Normally turned off
1.68         (drh      16-Jan-03): */
1.120        (danielk1 10-Jun-04): #if 0
1.277        (drh      18-Dec-06): #define sqlite3DebugPrintf printf
1.300        (drh      26-Mar-07): #define PAGERTRACE1(X)       sqlite3DebugPrintf(X)
1.300        (drh      26-Mar-07): #define PAGERTRACE2(X,Y)     sqlite3DebugPrintf(X,Y)
1.300        (drh      26-Mar-07): #define PAGERTRACE3(X,Y,Z)   sqlite3DebugPrintf(X,Y,Z)
1.300        (drh      26-Mar-07): #define PAGERTRACE4(X,Y,Z,W) sqlite3DebugPrintf(X,Y,Z,W)
1.300        (drh      26-Mar-07): #define PAGERTRACE5(X,Y,Z,W,V) sqlite3DebugPrintf(X,Y,Z,W,V)
1.68         (drh      16-Jan-03): #else
1.300        (drh      26-Mar-07): #define PAGERTRACE1(X)
1.300        (drh      26-Mar-07): #define PAGERTRACE2(X,Y)
1.300        (drh      26-Mar-07): #define PAGERTRACE3(X,Y,Z)
1.300        (drh      26-Mar-07): #define PAGERTRACE4(X,Y,Z,W)
1.300        (drh      26-Mar-07): #define PAGERTRACE5(X,Y,Z,W,V)
1.68         (drh      16-Jan-03): #endif
1.68         (drh      16-Jan-03): 
1.175        (danielk1 08-Nov-04): /*
1.300        (drh      26-Mar-07): ** The following two macros are used within the PAGERTRACEX() macros above
1.220        (drh      26-Nov-05): ** to print out file-descriptors. 
1.175        (danielk1 08-Nov-04): **
1.175        (danielk1 08-Nov-04): ** PAGERID() takes a pointer to a Pager struct as it's argument. The
1.175        (danielk1 08-Nov-04): ** associated file-descriptor is returned. FILEHANDLEID() takes an OsFile
1.175        (danielk1 08-Nov-04): ** struct as it's argument.
1.175        (danielk1 08-Nov-04): */
1.261        (drh      06-Mar-06): #define PAGERID(p) ((int)(p->fd))
1.261        (drh      06-Mar-06): #define FILEHANDLEID(fd) ((int)fd)
1.68         (drh      16-Jan-03): 
1.68         (drh      16-Jan-03): /*
1.1          (drh      11-Apr-01): ** The page cache as a whole is always in one of the following
1.1          (drh      11-Apr-01): ** states:
1.1          (drh      11-Apr-01): **
1.115        (drh      09-Jun-04): **   PAGER_UNLOCK        The page cache is not currently reading or 
1.1          (drh      11-Apr-01): **                       writing the database file.  There is no
1.1          (drh      11-Apr-01): **                       data held in memory.  This is the initial
1.1          (drh      11-Apr-01): **                       state.
1.1          (drh      11-Apr-01): **
1.115        (drh      09-Jun-04): **   PAGER_SHARED        The page cache is reading the database.
1.1          (drh      11-Apr-01): **                       Writing is not permitted.  There can be
1.1          (drh      11-Apr-01): **                       multiple readers accessing the same database
1.2          (drh      14-Apr-01): **                       file at the same time.
1.1          (drh      11-Apr-01): **
1.123        (drh      10-Jun-04): **   PAGER_RESERVED      This process has reserved the database for writing
1.123        (drh      10-Jun-04): **                       but has not yet made any changes.  Only one process
1.123        (drh      10-Jun-04): **                       at a time can reserve the database.  The original
1.123        (drh      10-Jun-04): **                       database file has not been modified so other
1.123        (drh      10-Jun-04): **                       processes may still be reading the on-disk
1.115        (drh      09-Jun-04): **                       database file.
1.115        (drh      09-Jun-04): **
1.115        (drh      09-Jun-04): **   PAGER_EXCLUSIVE     The page cache is writing the database.
1.1          (drh      11-Apr-01): **                       Access is exclusive.  No other processes or
1.1          (drh      11-Apr-01): **                       threads can be reading or writing while one
1.1          (drh      11-Apr-01): **                       process is writing.
1.1          (drh      11-Apr-01): **
1.125        (danielk1 14-Jun-04): **   PAGER_SYNCED        The pager moves to this state from PAGER_EXCLUSIVE
1.125        (danielk1 14-Jun-04): **                       after all dirty pages have been written to the
1.125        (danielk1 14-Jun-04): **                       database file and the file has been synced to
1.309        (drh      30-Mar-07): **                       disk. All that remains to do is to remove or
1.309        (drh      30-Mar-07): **                       truncate the journal file and the transaction 
1.309        (drh      30-Mar-07): **                       will be committed.
1.125        (danielk1 14-Jun-04): **
1.115        (drh      09-Jun-04): ** The page cache comes up in PAGER_UNLOCK.  The first time a
1.292        (danielk1 19-Mar-07): ** sqlite3PagerGet() occurs, the state transitions to PAGER_SHARED.
1.1          (drh      11-Apr-01): ** After all pages have been released using sqlite_page_unref(),
1.115        (drh      09-Jun-04): ** the state transitions back to PAGER_UNLOCK.  The first time
1.292        (danielk1 19-Mar-07): ** that sqlite3PagerWrite() is called, the state transitions to
1.309        (drh      30-Mar-07): ** PAGER_RESERVED.  (Note that sqlite3PagerWrite() can only be
1.6          (drh      21-May-01): ** called on an outstanding page which means that the pager must
1.115        (drh      09-Jun-04): ** be in PAGER_SHARED before it transitions to PAGER_RESERVED.)
1.309        (drh      30-Mar-07): ** PAGER_RESERVED means that there is an open rollback journal.
1.309        (drh      30-Mar-07): ** The transition to PAGER_EXCLUSIVE occurs before any changes
1.309        (drh      30-Mar-07): ** are made to the database file, though writes to the rollback
1.309        (drh      30-Mar-07): ** journal occurs with just PAGER_RESERVED.  After an sqlite3PagerRollback()
1.309        (drh      30-Mar-07): ** or sqlite3PagerCommitPhaseTwo(), the state can go back to PAGER_SHARED,
1.309        (drh      30-Mar-07): ** or it can stay at PAGER_EXCLUSIVE if we are in exclusive access mode.
1.1          (drh      11-Apr-01): */
1.115        (drh      09-Jun-04): #define PAGER_UNLOCK      0
1.167        (drh      05-Oct-04): #define PAGER_SHARED      1   /* same as SHARED_LOCK */
1.167        (drh      05-Oct-04): #define PAGER_RESERVED    2   /* same as RESERVED_LOCK */
1.167        (drh      05-Oct-04): #define PAGER_EXCLUSIVE   4   /* same as EXCLUSIVE_LOCK */
1.167        (drh      05-Oct-04): #define PAGER_SYNCED      5
1.1          (drh      11-Apr-01): 
1.167        (drh      05-Oct-04): /*
1.167        (drh      05-Oct-04): ** If the SQLITE_BUSY_RESERVED_LOCK macro is set to true at compile-time,
1.167        (drh      05-Oct-04): ** then failed attempts to get a reserved lock will invoke the busy callback.
1.167        (drh      05-Oct-04): ** This is off by default.  To see why, consider the following scenario:
1.167        (drh      05-Oct-04): ** 
1.167        (drh      05-Oct-04): ** Suppose thread A already has a shared lock and wants a reserved lock.
1.167        (drh      05-Oct-04): ** Thread B already has a reserved lock and wants an exclusive lock.  If
1.167        (drh      05-Oct-04): ** both threads are using their busy callbacks, it might be a long time
1.167        (drh      05-Oct-04): ** be for one of the threads give up and allows the other to proceed.
1.167        (drh      05-Oct-04): ** But if the thread trying to get the reserved lock gives up quickly
1.167        (drh      05-Oct-04): ** (if it never invokes its busy callback) then the contention will be
1.167        (drh      05-Oct-04): ** resolved quickly.
1.167        (drh      05-Oct-04): */
1.167        (drh      05-Oct-04): #ifndef SQLITE_BUSY_RESERVED_LOCK
1.167        (drh      05-Oct-04): # define SQLITE_BUSY_RESERVED_LOCK 0
1.167        (drh      05-Oct-04): #endif
1.3          (drh      15-Apr-01): 
1.1          (drh      11-Apr-01): /*
1.168        (drh      22-Oct-04): ** This macro rounds values up so that if the value is an address it
1.168        (drh      22-Oct-04): ** is guaranteed to be an address that is aligned to an 8-byte boundary.
1.168        (drh      22-Oct-04): */
1.168        (drh      22-Oct-04): #define FORCE_ALIGNMENT(X)   (((X)+7)&~7)
1.168        (drh      22-Oct-04): 
1.168        (drh      22-Oct-04): /*
1.1          (drh      11-Apr-01): ** Each in-memory image of a page begins with the following header.
1.8          (drh      02-Jun-01): ** This header is only visible to this pager module.  The client
1.8          (drh      02-Jun-01): ** code that calls pager sees only the data that follows the header.
1.95         (drh      08-Feb-04): **
1.292        (danielk1 19-Mar-07): ** Client code should call sqlite3PagerWrite() on a page prior to making
1.292        (danielk1 19-Mar-07): ** any modifications to that page.  The first time sqlite3PagerWrite()
1.95         (drh      08-Feb-04): ** is called, the original page contents are written into the rollback
1.95         (drh      08-Feb-04): ** journal and PgHdr.inJournal and PgHdr.needSync are set.  Later, once
1.95         (drh      08-Feb-04): ** the journal page has made it onto the disk surface, PgHdr.needSync
1.95         (drh      08-Feb-04): ** is cleared.  The modified page cannot be written back into the original
1.95         (drh      08-Feb-04): ** database file until the journal pages has been synced to disk and the
1.95         (drh      08-Feb-04): ** PgHdr.needSync has been cleared.
1.95         (drh      08-Feb-04): **
1.292        (danielk1 19-Mar-07): ** The PgHdr.dirty flag is set when sqlite3PagerWrite() is called and
1.95         (drh      08-Feb-04): ** is cleared again when the page content is written back to the original
1.95         (drh      08-Feb-04): ** database file.
1.346        (drh      16-Jun-07): **
1.346        (drh      16-Jun-07): ** Details of important structure elements:
1.346        (drh      16-Jun-07): **
1.346        (drh      16-Jun-07): ** needSync
1.346        (drh      16-Jun-07): **
1.346        (drh      16-Jun-07): **     If this is true, this means that it is not safe to write the page
1.346        (drh      16-Jun-07): **     content to the database because the original content needed
1.346        (drh      16-Jun-07): **     for rollback has not by synced to the main rollback journal.
1.346        (drh      16-Jun-07): **     The original content may have been written to the rollback journal
1.346        (drh      16-Jun-07): **     but it has not yet been synced.  So we cannot write to the database
1.346        (drh      16-Jun-07): **     file because power failure might cause the page in the journal file
1.346        (drh      16-Jun-07): **     to never reach the disk.  It is as if the write to the journal file
1.346        (drh      16-Jun-07): **     does not occur until the journal file is synced.
1.346        (drh      16-Jun-07): **     
1.346        (drh      16-Jun-07): **     This flag is false if the page content exactly matches what
1.346        (drh      16-Jun-07): **     currently exists in the database file.  The needSync flag is also
1.346        (drh      16-Jun-07): **     false if the original content has been written to the main rollback
1.346        (drh      16-Jun-07): **     journal and synced.  If the page represents a new page that has
1.346        (drh      16-Jun-07): **     been added onto the end of the database during the current
1.346        (drh      16-Jun-07): **     transaction, the needSync flag is true until the original database
1.346        (drh      16-Jun-07): **     size in the journal header has been synced to disk.
1.346        (drh      16-Jun-07): **
1.346        (drh      16-Jun-07): ** inJournal
1.346        (drh      16-Jun-07): **
1.346        (drh      16-Jun-07): **     This is true if the original page has been written into the main
1.346        (drh      16-Jun-07): **     rollback journal.  This is always false for new pages added to
1.346        (drh      16-Jun-07): **     the end of the database file during the current transaction.
1.346        (drh      16-Jun-07): **     And this flag says nothing about whether or not the journal
1.346        (drh      16-Jun-07): **     has been synced to disk.  For pages that are in the original
1.346        (drh      16-Jun-07): **     database file, the following expression should always be true:
1.346        (drh      16-Jun-07): **
1.346        (drh      16-Jun-07): **       inJournal = (pPager->aInJournal[(pgno-1)/8] & (1<<((pgno-1)%8))!=0
1.346        (drh      16-Jun-07): **
1.346        (drh      16-Jun-07): **     The pPager->aInJournal[] array is only valid for the original
1.346        (drh      16-Jun-07): **     pages of the database, not new pages that are added to the end
1.346        (drh      16-Jun-07): **     of the database, so obviously the above expression cannot be
1.346        (drh      16-Jun-07): **     valid for new pages.  For new pages inJournal is always 0.
1.346        (drh      16-Jun-07): **
1.346        (drh      16-Jun-07): ** dirty
1.346        (drh      16-Jun-07): **
1.346        (drh      16-Jun-07): **     When true, this means that the content of the page has been
1.346        (drh      16-Jun-07): **     modified and needs to be written back to the database file.
1.346        (drh      16-Jun-07): **     If false, it means that either the content of the page is
1.346        (drh      16-Jun-07): **     unchanged or else the content is unimportant and we do not
1.346        (drh      16-Jun-07): **     care whether or not it is preserved.
1.346        (drh      16-Jun-07): **
1.346        (drh      16-Jun-07): ** alwaysRollback
1.346        (drh      16-Jun-07): **
1.346        (drh      16-Jun-07): **     This means that the sqlite3PagerDontRollback() API should be
1.346        (drh      16-Jun-07): **     ignored for this page.  The DontRollback() API attempts to say
1.346        (drh      16-Jun-07): **     that the content of the page on disk is unimportant (it is an
1.346        (drh      16-Jun-07): **     unused page on the freelist) so that it is unnecessary to 
1.346        (drh      16-Jun-07): **     rollback changes to this page because the content of the page
1.346        (drh      16-Jun-07): **     can change without changing the meaning of the database.  This
1.346        (drh      16-Jun-07): **     flag overrides any DontRollback() attempt.  This flag is set
1.346        (drh      16-Jun-07): **     when a page that originally contained valid data is added to
1.346        (drh      16-Jun-07): **     the freelist.  Later in the same transaction, this page might
1.346        (drh      16-Jun-07): **     be pulled from the freelist and reused for something different
1.346        (drh      16-Jun-07): **     and at that point the DontRollback() API will be called because
1.346        (drh      16-Jun-07): **     pages taken from the freelist do not need to be protected by
1.346        (drh      16-Jun-07): **     the rollback journal.  But this flag says that the page was
1.346        (drh      16-Jun-07): **     not originally part of the freelist so that it still needs to
1.346        (drh      16-Jun-07): **     be rolled back in spite of any subsequent DontRollback() calls.
1.346        (drh      16-Jun-07): **
1.346        (drh      16-Jun-07): ** needRead 
1.346        (drh      16-Jun-07): **
1.346        (drh      16-Jun-07): **     This flag means (when true) that the content of the page has
1.346        (drh      16-Jun-07): **     not yet been loaded from disk.  The in-memory content is just
1.346        (drh      16-Jun-07): **     garbage.  (Actually, we zero the content, but you should not
1.346        (drh      16-Jun-07): **     make any assumptions about the content nevertheless.)  If the
1.346        (drh      16-Jun-07): **     content is needed in the future, it should be read from the
1.346        (drh      16-Jun-07): **     original database file.
1.1          (drh      11-Apr-01): */
1.3          (drh      15-Apr-01): typedef struct PgHdr PgHdr;
1.1          (drh      11-Apr-01): struct PgHdr {
1.1          (drh      11-Apr-01):   Pager *pPager;                 /* The pager to which this page belongs */
1.1          (drh      11-Apr-01):   Pgno pgno;                     /* The page number for this page */
1.2          (drh      14-Apr-01):   PgHdr *pNextHash, *pPrevHash;  /* Hash collision chain for PgHdr.pgno */
1.3          (drh      15-Apr-01):   PgHdr *pNextFree, *pPrevFree;  /* Freelist of pages where nRef==0 */
1.107        (drh      12-May-04):   PgHdr *pNextAll;               /* A list of all pages */
1.49         (drh      07-Jul-02):   u8 inJournal;                  /* TRUE if has been written to journal */
1.49         (drh      07-Jul-02):   u8 dirty;                      /* TRUE if we need to write back changes */
1.68         (drh      16-Jan-03):   u8 needSync;                   /* Sync journal before writing this page */
1.307        (drh      30-Mar-07):   u8 alwaysRollback;             /* Disable DontRollback() for this page */
1.327        (drh      13-Apr-07):   u8 needRead;                   /* Read content if PagerWrite() is called */
1.107        (drh      12-May-04):   short int nRef;                /* Number of users of this page */
1.269        (drh      15-Jun-06):   PgHdr *pDirty, *pPrevDirty;    /* Dirty pages */
1.267        (drh      03-May-06):   u32 notUsed;                   /* Buffer space */
1.189        (danielk1 15-Feb-05): #ifdef SQLITE_CHECK_PAGES
1.189        (danielk1 15-Feb-05):   u32 pageHash;
1.189        (danielk1 15-Feb-05): #endif
1.203        (drh      20-May-05):   /* pPager->pageSize bytes of page data follow this header */
1.75         (drh      12-Feb-03):   /* Pager.nExtra bytes of local data follow the page data */
1.1          (drh      11-Apr-01): };
1.1          (drh      11-Apr-01): 
1.107        (drh      12-May-04): /*
1.107        (drh      12-May-04): ** For an in-memory only database, some extra information is recorded about
1.107        (drh      12-May-04): ** each page so that changes can be rolled back.  (Journal files are not
1.107        (drh      12-May-04): ** used for in-memory databases.)  The following information is added to
1.107        (drh      12-May-04): ** the end of every EXTRA block for in-memory databases.
1.107        (drh      12-May-04): **
1.107        (drh      12-May-04): ** This information could have been added directly to the PgHdr structure.
1.107        (drh      12-May-04): ** But then it would take up an extra 8 bytes of storage on every PgHdr
1.107        (drh      12-May-04): ** even for disk-based databases.  Splitting it out saves 8 bytes.  This
1.107        (drh      12-May-04): ** is only a savings of 0.8% but those percentages add up.
1.107        (drh      12-May-04): */
1.107        (drh      12-May-04): typedef struct PgHistory PgHistory;
1.107        (drh      12-May-04): struct PgHistory {
1.107        (drh      12-May-04):   u8 *pOrig;     /* Original page text.  Restore to this on a full rollback */
1.107        (drh      12-May-04):   u8 *pStmt;     /* Text as it was at the beginning of the current statement */
1.325        (danielk1 07-Apr-07):   PgHdr *pNextStmt, *pPrevStmt;  /* List of pages in the statement journal */
1.325        (danielk1 07-Apr-07):   u8 inStmt;                     /* TRUE if in the statement subjournal */
1.107        (drh      12-May-04): };
1.99         (drh      11-Feb-04): 
1.99         (drh      11-Feb-04): /*
1.99         (drh      11-Feb-04): ** A macro used for invoking the codec if there is one
1.99         (drh      11-Feb-04): */
1.99         (drh      11-Feb-04): #ifdef SQLITE_HAS_CODEC
1.261        (drh      06-Mar-06): # define CODEC1(P,D,N,X) if( P->xCodec!=0 ){ P->xCodec(P->pCodecArg,D,N,X); }
1.261        (drh      06-Mar-06): # define CODEC2(P,D,N,X) ((char*)(P->xCodec!=0?P->xCodec(P->pCodecArg,D,N,X):D))
1.99         (drh      11-Feb-04): #else
1.261        (drh      06-Mar-06): # define CODEC1(P,D,N,X) /* NO-OP */
1.261        (drh      06-Mar-06): # define CODEC2(P,D,N,X) ((char*)D)
1.99         (drh      11-Feb-04): #endif
1.99         (drh      11-Feb-04): 
1.1          (drh      11-Apr-01): /*
1.2          (drh      14-Apr-01): ** Convert a pointer to a PgHdr into a pointer to its data
1.2          (drh      14-Apr-01): ** and back again.
1.1          (drh      11-Apr-01): */
1.1          (drh      11-Apr-01): #define PGHDR_TO_DATA(P)  ((void*)(&(P)[1]))
1.1          (drh      11-Apr-01): #define DATA_TO_PGHDR(D)  (&((PgHdr*)(D))[-1])
1.203        (drh      20-May-05): #define PGHDR_TO_EXTRA(G,P) ((void*)&((char*)(&(G)[1]))[(P)->pageSize])
1.107        (drh      12-May-04): #define PGHDR_TO_HIST(P,PGR)  \
1.203        (drh      20-May-05):             ((PgHistory*)&((char*)(&(P)[1]))[(PGR)->pageSize+(PGR)->nExtra])
1.1          (drh      11-Apr-01): 
1.1          (drh      11-Apr-01): /*
1.1          (drh      11-Apr-01): ** A open page cache is an instance of the following structure.
1.238        (danielk1 16-Jan-06): **
1.311        (drh      30-Mar-07): ** Pager.errCode may be set to SQLITE_IOERR, SQLITE_CORRUPT, or
1.238        (danielk1 16-Jan-06): ** or SQLITE_FULL. Once one of the first three errors occurs, it persists
1.238        (danielk1 16-Jan-06): ** and is returned as the result of every major pager API call.  The
1.238        (danielk1 16-Jan-06): ** SQLITE_FULL return code is slightly different. It persists only until the
1.238        (danielk1 16-Jan-06): ** next successful rollback is performed on the pager cache. Also,
1.292        (danielk1 19-Mar-07): ** SQLITE_FULL does not affect the sqlite3PagerGet() and sqlite3PagerLookup()
1.238        (danielk1 16-Jan-06): ** APIs, they may still be used successfully.
1.1          (drh      11-Apr-01): */
1.1          (drh      11-Apr-01): struct Pager {
1.42         (drh      05-Mar-02):   u8 journalOpen;             /* True if journal file descriptors is valid */
1.94         (drh      08-Feb-04):   u8 journalStarted;          /* True if header of journal is synced */
1.94         (drh      08-Feb-04):   u8 useJournal;              /* Use a rollback journal on this file */
1.188        (drh      06-Feb-05):   u8 noReadlock;              /* Do not bother to obtain readlocks */
1.107        (drh      12-May-04):   u8 stmtOpen;                /* True if the statement subjournal is open */
1.107        (drh      12-May-04):   u8 stmtInUse;               /* True we are in a statement subtransaction */
1.107        (drh      12-May-04):   u8 stmtAutoopen;            /* Open stmt journal when main journal is opened*/
1.42         (drh      05-Mar-02):   u8 noSync;                  /* Do not sync the journal if true */
1.73         (drh      11-Feb-03):   u8 fullSync;                /* Do extra syncs of the journal for robustness */
1.258        (drh      11-Feb-06):   u8 full_fsync;              /* Use F_FULLFSYNC when available */
1.115        (drh      09-Jun-04):   u8 state;                   /* PAGER_UNLOCK, _SHARED, _RESERVED, etc. */
1.42         (drh      05-Mar-02):   u8 tempFile;                /* zFilename is a temporary file */
1.42         (drh      05-Mar-02):   u8 readOnly;                /* True for a read-only database */
1.42         (drh      05-Mar-02):   u8 needSync;                /* True if an fsync() is needed on the journal */
1.115        (drh      09-Jun-04):   u8 dirtyCache;              /* True if cached pages have changed */
1.307        (drh      30-Mar-07):   u8 alwaysRollback;          /* Disable DontRollback() for all pages */
1.107        (drh      12-May-04):   u8 memDb;                   /* True to inhibit all file I/O */
1.204        (drh      20-May-05):   u8 setMaster;               /* True if a m-j name has been written to jrnl */
1.307        (drh      30-Mar-07):   u8 doNotSync;               /* Boolean. While true, do not spill the cache */
1.307        (drh      30-Mar-07):   u8 exclusiveMode;           /* Boolean. True if locking_mode==EXCLUSIVE */
1.307        (drh      30-Mar-07):   u8 changeCountDone;         /* Set after incrementing the change-counter */
1.273        (drh      15-Sep-06):   int errCode;                /* One of several kinds of errors */
1.205        (drh      21-May-05):   int dbSize;                 /* Number of pages in the file */
1.205        (drh      21-May-05):   int origDbSize;             /* dbSize before the current change */
1.205        (drh      21-May-05):   int stmtSize;               /* Size of database (in pages) at stmt_begin() */
1.205        (drh      21-May-05):   int nRec;                   /* Number of pages written to the journal */
1.205        (drh      21-May-05):   u32 cksumInit;              /* Quasi-random value added to every checksum */
1.205        (drh      21-May-05):   int stmtNRec;               /* Number of records in stmt subjournal */
1.205        (drh      21-May-05):   int nExtra;                 /* Add this many bytes to each in-memory page */
1.205        (drh      21-May-05):   int pageSize;               /* Number of bytes in a page */
1.205        (drh      21-May-05):   int nPage;                  /* Total number of in-memory pages */
1.205        (drh      21-May-05):   int nRef;                   /* Number of in-memory pages with PgHdr.nRef>0 */
1.205        (drh      21-May-05):   int mxPage;                 /* Maximum number of pages to hold in cache */
1.337        (drh      08-May-07):   Pgno mxPgno;                /* Maximum allowed size of the database */
1.42         (drh      05-Mar-02):   u8 *aInJournal;             /* One bit for each page in the database file */
1.107        (drh      12-May-04):   u8 *aInStmt;                /* One bit for each page in the database */
1.205        (drh      21-May-05):   char *zFilename;            /* Name of the database file */
1.205        (drh      21-May-05):   char *zJournal;             /* Name of the journal file */
1.205        (drh      21-May-05):   char *zDirectory;           /* Directory hold database and journal files */
1.221        (drh      29-Nov-05):   OsFile *fd, *jfd;           /* File descriptors for database and journal */
1.221        (drh      29-Nov-05):   OsFile *stfd;               /* File descriptor for the statement subjournal*/
1.123        (drh      10-Jun-04):   BusyHandler *pBusyHandler;  /* Pointer to sqlite.busyHandler */
1.1          (drh      11-Apr-01):   PgHdr *pFirst, *pLast;      /* List of free pages */
1.69         (drh      21-Jan-03):   PgHdr *pFirstSynced;        /* First free page with PgHdr.needSync==0 */
1.3          (drh      15-Apr-01):   PgHdr *pAll;                /* List of all pages */
1.107        (drh      12-May-04):   PgHdr *pStmt;               /* List of pages in the statement subjournal */
1.267        (drh      03-May-06):   PgHdr *pDirty;              /* List of all dirty pages */
1.165        (drh      01-Oct-04):   i64 journalOff;             /* Current byte offset in the journal file */
1.165        (drh      01-Oct-04):   i64 journalHdr;             /* Byte offset to previous journal header */
1.165        (drh      01-Oct-04):   i64 stmtHdrOff;             /* First journal header written this statement */
1.165        (drh      01-Oct-04):   i64 stmtCksum;              /* cksumInit when statement was started */
1.204        (drh      20-May-05):   i64 stmtJSize;              /* Size of journal at stmt_begin() */
1.138        (danielk1 25-Jun-04):   int sectorSize;             /* Assumed sector size during rollback */
1.205        (drh      21-May-05): #ifdef SQLITE_TEST
1.319        (drh      05-Apr-07):   int nHit, nMiss;            /* Cache hits and missing */
1.319        (drh      05-Apr-07):   int nRead, nWrite;          /* Database pages read/written */
1.205        (drh      21-May-05): #endif
1.292        (danielk1 19-Mar-07):   void (*xDestructor)(DbPage*,int); /* Call this routine when freeing pages */
1.292        (danielk1 19-Mar-07):   void (*xReiniter)(DbPage*,int);   /* Call this routine when reloading pages */
1.319        (drh      05-Apr-07): #ifdef SQLITE_HAS_CODEC
1.261        (drh      06-Mar-06):   void *(*xCodec)(void*,void*,Pgno,int); /* Routine for en/decoding data */
1.204        (drh      20-May-05):   void *pCodecArg;            /* First argument to xCodec() */
1.319        (drh      05-Apr-07): #endif
1.268        (drh      07-May-06):   int nHash;                  /* Size of the pager hash table */
1.268        (drh      07-May-06):   PgHdr **aHash;              /* Hash table to map page number to PgHdr */
1.236        (drh      11-Jan-06): #ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
1.225        (danielk1 18-Dec-05):   Pager *pNext;               /* Linked list of pagers in this thread */
1.225        (danielk1 18-Dec-05): #endif
1.286        (danielk1 06-Mar-07):   char *pTmpSpace;            /* Pager.pageSize bytes of space for tmp use */
1.329        (drh      16-Apr-07):   char dbFileVers[16];        /* Changes whenever database file changes */
1.3          (drh      15-Apr-01): };
1.3          (drh      15-Apr-01): 
1.3          (drh      15-Apr-01): /*
1.327        (drh      13-Apr-07): ** The following global variables hold counters used for
1.327        (drh      13-Apr-07): ** testing purposes only.  These variables do not exist in
1.327        (drh      13-Apr-07): ** a non-testing build.  These variables are not thread-safe.
1.205        (drh      21-May-05): */
1.205        (drh      21-May-05): #ifdef SQLITE_TEST
1.327        (drh      13-Apr-07): int sqlite3_pager_readdb_count = 0;    /* Number of full pages read from DB */
1.327        (drh      13-Apr-07): int sqlite3_pager_writedb_count = 0;   /* Number of full pages written to DB */
1.327        (drh      13-Apr-07): int sqlite3_pager_writej_count = 0;    /* Number of pages written to journal */
1.327        (drh      13-Apr-07): int sqlite3_pager_pgfree_count = 0;    /* Number of cache pages freed */
1.327        (drh      13-Apr-07): # define PAGER_INCR(v)  v++
1.205        (drh      21-May-05): #else
1.327        (drh      13-Apr-07): # define PAGER_INCR(v)
1.205        (drh      21-May-05): #endif
1.205        (drh      21-May-05): 
1.327        (drh      13-Apr-07): 
1.327        (drh      13-Apr-07): 
1.205        (drh      21-May-05): /*
1.14         (drh      13-Sep-01): ** Journal files begin with the following magic string.  The data
1.14         (drh      13-Sep-01): ** was obtained from /dev/random.  It is used only as a sanity check.
1.50         (drh      12-Aug-02): **
1.116        (drh      09-Jun-04): ** Since version 2.8.0, the journal format contains additional sanity
1.116        (drh      09-Jun-04): ** checking information.  If the power fails while the journal is begin
1.116        (drh      09-Jun-04): ** written, semi-random garbage data might appear in the journal
1.116        (drh      09-Jun-04): ** file after power is restored.  If an attempt is then made
1.73         (drh      11-Feb-03): ** to roll the journal back, the database could be corrupted.  The additional
1.73         (drh      11-Feb-03): ** sanity checking data is an attempt to discover the garbage in the
1.73         (drh      11-Feb-03): ** journal and ignore it.
1.73         (drh      11-Feb-03): **
1.116        (drh      09-Jun-04): ** The sanity checking information for the new journal format consists
1.73         (drh      11-Feb-03): ** of a 32-bit checksum on each page of data.  The checksum covers both
1.152        (drh      22-Jul-04): ** the page number and the pPager->pageSize bytes of data for the page.
1.73         (drh      11-Feb-03): ** This cksum is initialized to a 32-bit random value that appears in the
1.73         (drh      11-Feb-03): ** journal file right after the header.  The random initializer is important,
1.73         (drh      11-Feb-03): ** because garbage data that appears at the end of a journal is likely
1.73         (drh      11-Feb-03): ** data that was once in other files that have now been deleted.  If the
1.73         (drh      11-Feb-03): ** garbage data came from an obsolete journal file, the checksums might
1.73         (drh      11-Feb-03): ** be correct.  But by initializing the checksum to random value which
1.73         (drh      11-Feb-03): ** is different for every journal, we minimize that risk.
1.3          (drh      15-Apr-01): */
1.116        (drh      09-Jun-04): static const unsigned char aJournalMagic[] = {
1.116        (drh      09-Jun-04):   0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7,
1.1          (drh      11-Apr-01): };
1.1          (drh      11-Apr-01): 
1.1          (drh      11-Apr-01): /*
1.123        (drh      10-Jun-04): ** The size of the header and of each page in the journal is determined
1.123        (drh      10-Jun-04): ** by the following macros.
1.73         (drh      11-Feb-03): */
1.116        (drh      09-Jun-04): #define JOURNAL_PG_SZ(pPager)  ((pPager->pageSize) + 8)
1.73         (drh      11-Feb-03): 
1.138        (danielk1 25-Jun-04): /*
1.138        (danielk1 25-Jun-04): ** The journal header size for this pager. In the future, this could be
1.138        (danielk1 25-Jun-04): ** set to some value read from the disk controller. The important
1.138        (danielk1 25-Jun-04): ** characteristic is that it is the same size as a disk sector.
1.138        (danielk1 25-Jun-04): */
1.138        (danielk1 25-Jun-04): #define JOURNAL_HDR_SZ(pPager) (pPager->sectorSize)
1.138        (danielk1 25-Jun-04): 
1.169        (drh      31-Oct-04): /*
1.169        (drh      31-Oct-04): ** The macro MEMDB is true if we are dealing with an in-memory database.
1.169        (drh      31-Oct-04): ** We do this as a macro so that if the SQLITE_OMIT_MEMORYDB macro is set,
1.169        (drh      31-Oct-04): ** the value of MEMDB will be a constant and the compiler will optimize
1.169        (drh      31-Oct-04): ** out code that would never execute.
1.169        (drh      31-Oct-04): */
1.169        (drh      31-Oct-04): #ifdef SQLITE_OMIT_MEMORYDB
1.169        (drh      31-Oct-04): # define MEMDB 0
1.169        (drh      31-Oct-04): #else
1.169        (drh      31-Oct-04): # define MEMDB pPager->memDb
1.169        (drh      31-Oct-04): #endif
1.169        (drh      31-Oct-04): 
1.169        (drh      31-Oct-04): /*
1.138        (danielk1 25-Jun-04): ** Page number PAGER_MJ_PGNO is never used in an SQLite database (it is
1.138        (danielk1 25-Jun-04): ** reserved for working around a windows/posix incompatibility). It is
1.138        (danielk1 25-Jun-04): ** used in the journal to signify that the remainder of the journal file 
1.138        (danielk1 25-Jun-04): ** is devoted to storing a master journal name - there are no more pages to
1.138        (danielk1 25-Jun-04): ** roll back. See comments for function writeMasterJournal() for details.
1.138        (danielk1 25-Jun-04): */
1.175        (danielk1 08-Nov-04): /* #define PAGER_MJ_PGNO(x) (PENDING_BYTE/((x)->pageSize)) */
1.175        (danielk1 08-Nov-04): #define PAGER_MJ_PGNO(x) ((PENDING_BYTE/((x)->pageSize))+1)
1.110        (danielk1 03-Jun-04): 
1.73         (drh      11-Feb-03): /*
1.183        (danielk1 17-Jan-05): ** The maximum legal page number is (2^31 - 1).
1.183        (danielk1 17-Jan-05): */
1.183        (danielk1 17-Jan-05): #define PAGER_MAX_PGNO 2147483647
1.183        (danielk1 17-Jan-05): 
1.183        (danielk1 17-Jan-05): /*
1.123        (drh      10-Jun-04): ** Enable reference count tracking (for debugging) here:
1.12         (drh      28-Jun-01): */
1.319        (drh      05-Apr-07): #ifdef SQLITE_DEBUG
1.102        (drh      26-Apr-04):   int pager3_refinfo_enable = 0;
1.12         (drh      28-Jun-01):   static void pager_refinfo(PgHdr *p){
1.12         (drh      28-Jun-01):     static int cnt = 0;
1.102        (drh      26-Apr-04):     if( !pager3_refinfo_enable ) return;
1.163        (drh      08-Sep-04):     sqlite3DebugPrintf(
1.282        (drh      05-Jan-07):        "REFCNT: %4d addr=%p nRef=%-3d total=%d\n",
1.282        (drh      05-Jan-07):        p->pgno, PGHDR_TO_DATA(p), p->nRef, p->pPager->nRef
1.12         (drh      28-Jun-01):     );
1.12         (drh      28-Jun-01):     cnt++;   /* Something to set a breakpoint on */
1.12         (drh      28-Jun-01):   }
1.12         (drh      28-Jun-01): # define REFINFO(X)  pager_refinfo(X)
1.12         (drh      28-Jun-01): #else
1.12         (drh      28-Jun-01): # define REFINFO(X)
1.12         (drh      28-Jun-01): #endif
1.12         (drh      28-Jun-01): 
1.325        (danielk1 07-Apr-07): /*
1.325        (danielk1 07-Apr-07): ** Return true if page *pPg has already been written to the statement
1.325        (danielk1 07-Apr-07): ** journal (or statement snapshot has been created, if *pPg is part
1.325        (danielk1 07-Apr-07): ** of an in-memory database).
1.325        (danielk1 07-Apr-07): */
1.325        (danielk1 07-Apr-07): static int pageInStatement(PgHdr *pPg){
1.325        (danielk1 07-Apr-07):   Pager *pPager = pPg->pPager;
1.325        (danielk1 07-Apr-07):   if( MEMDB ){
1.325        (danielk1 07-Apr-07):     return PGHDR_TO_HIST(pPg, pPager)->inStmt;
1.325        (danielk1 07-Apr-07):   }else{
1.325        (danielk1 07-Apr-07):     Pgno pgno = pPg->pgno;
1.325        (danielk1 07-Apr-07):     u8 *a = pPager->aInStmt;
1.325        (danielk1 07-Apr-07):     return (a && (int)pgno<=pPager->stmtSize && (a[pgno/8] & (1<<(pgno&7))));
1.325        (danielk1 07-Apr-07):   }
1.325        (danielk1 07-Apr-07): }
1.268        (drh      07-May-06): 
1.268        (drh      07-May-06): /*
1.268        (drh      07-May-06): ** Change the size of the pager hash table to N.  N must be a power
1.268        (drh      07-May-06): ** of two.
1.268        (drh      07-May-06): */
1.268        (drh      07-May-06): static void pager_resize_hash_table(Pager *pPager, int N){
1.268        (drh      07-May-06):   PgHdr **aHash, *pPg;
1.268        (drh      07-May-06):   assert( N>0 && (N&(N-1))==0 );
1.268        (drh      07-May-06):   aHash = sqliteMalloc( sizeof(aHash[0])*N );
1.268        (drh      07-May-06):   if( aHash==0 ){
1.268        (drh      07-May-06):     /* Failure to rehash is not an error.  It is only a performance hit. */
1.268        (drh      07-May-06):     return;
1.268        (drh      07-May-06):   }
1.268        (drh      07-May-06):   sqliteFree(pPager->aHash);
1.268        (drh      07-May-06):   pPager->nHash = N;
1.268        (drh      07-May-06):   pPager->aHash = aHash;
1.268        (drh      07-May-06):   for(pPg=pPager->pAll; pPg; pPg=pPg->pNextAll){
1.270        (drh      28-Jun-06):     int h;
1.270        (drh      28-Jun-06):     if( pPg->pgno==0 ){
1.270        (drh      28-Jun-06):       assert( pPg->pNextHash==0 && pPg->pPrevHash==0 );
1.270        (drh      28-Jun-06):       continue;
1.270        (drh      28-Jun-06):     }
1.270        (drh      28-Jun-06):     h = pPg->pgno & (N-1);
1.268        (drh      07-May-06):     pPg->pNextHash = aHash[h];
1.268        (drh      07-May-06):     if( aHash[h] ){
1.268        (drh      07-May-06):       aHash[h]->pPrevHash = pPg;
1.268        (drh      07-May-06):     }
1.268        (drh      07-May-06):     aHash[h] = pPg;
1.268        (drh      07-May-06):     pPg->pPrevHash = 0;
1.268        (drh      07-May-06):   }
1.268        (drh      07-May-06): }
1.268        (drh      07-May-06): 
1.12         (drh      28-Jun-01): /*
1.94         (drh      08-Feb-04): ** Read a 32-bit integer from the given file descriptor.  Store the integer
1.94         (drh      08-Feb-04): ** that is read in *pRes.  Return SQLITE_OK if everything worked, or an
1.94         (drh      08-Feb-04): ** error code is something goes wrong.
1.123        (drh      10-Jun-04): **
1.123        (drh      10-Jun-04): ** All values are stored on disk as big-endian.
1.50         (drh      12-Aug-02): */
1.116        (drh      09-Jun-04): static int read32bits(OsFile *fd, u32 *pRes){
1.237        (drh      15-Jan-06):   unsigned char ac[4];
1.237        (drh      15-Jan-06):   int rc = sqlite3OsRead(fd, ac, sizeof(ac));
1.116        (drh      09-Jun-04):   if( rc==SQLITE_OK ){
1.336        (drh      05-May-07):     *pRes = sqlite3Get4byte(ac);
1.50         (drh      12-Aug-02):   }
1.50         (drh      12-Aug-02):   return rc;
1.50         (drh      12-Aug-02): }
1.50         (drh      12-Aug-02): 
1.50         (drh      12-Aug-02): /*
1.235        (drh      10-Jan-06): ** Write a 32-bit integer into a string buffer in big-endian byte order.
1.235        (drh      10-Jan-06): */
1.336        (drh      05-May-07): #define put32bits(A,B)  sqlite3Put4byte((u8*)A,B)
1.235        (drh      10-Jan-06): 
1.235        (drh      10-Jan-06): /*
1.94         (drh      08-Feb-04): ** Write a 32-bit integer into the given file descriptor.  Return SQLITE_OK
1.94         (drh      08-Feb-04): ** on success or an error code is something goes wrong.
1.50         (drh      12-Aug-02): */
1.50         (drh      12-Aug-02): static int write32bits(OsFile *fd, u32 val){
1.240        (danielk1 16-Jan-06):   char ac[4];
1.235        (drh      10-Jan-06):   put32bits(ac, val);
1.222        (drh      30-Nov-05):   return sqlite3OsWrite(fd, ac, 4);
1.50         (drh      12-Aug-02): }
1.50         (drh      12-Aug-02): 
1.70         (drh      22-Jan-03): /*
1.229        (danielk1 30-Dec-05): ** This function should be called when an error occurs within the pager
1.239        (danielk1 16-Jan-06): ** code. The first argument is a pointer to the pager structure, the
1.239        (danielk1 16-Jan-06): ** second the error-code about to be returned by a pager API function. 
1.239        (danielk1 16-Jan-06): ** The value returned is a copy of the second argument to this function. 
1.239        (danielk1 16-Jan-06): **
1.311        (drh      30-Mar-07): ** If the second argument is SQLITE_IOERR, SQLITE_CORRUPT, or SQLITE_FULL
1.239        (danielk1 16-Jan-06): ** the error becomes persistent. All subsequent API calls on this Pager
1.239        (danielk1 16-Jan-06): ** will immediately return the same error code.
1.229        (danielk1 30-Dec-05): */
1.229        (danielk1 30-Dec-05): static int pager_error(Pager *pPager, int rc){
1.272        (drh      15-Sep-06):   int rc2 = rc & 0xff;
1.238        (danielk1 16-Jan-06):   assert( pPager->errCode==SQLITE_FULL || pPager->errCode==SQLITE_OK );
1.302        (danielk1 27-Mar-07):   if(
1.272        (drh      15-Sep-06):     rc2==SQLITE_FULL ||
1.272        (drh      15-Sep-06):     rc2==SQLITE_IOERR ||
1.311        (drh      30-Mar-07):     rc2==SQLITE_CORRUPT
1.238        (danielk1 16-Jan-06):   ){
1.238        (danielk1 16-Jan-06):     pPager->errCode = rc;
1.229        (danielk1 30-Dec-05):   }
1.229        (danielk1 30-Dec-05):   return rc;
1.229        (danielk1 30-Dec-05): }
1.229        (danielk1 30-Dec-05): 
1.344        (drh      16-Jun-07): /*
1.344        (drh      16-Jun-07): ** If SQLITE_CHECK_PAGES is defined then we do some sanity checking
1.344        (drh      16-Jun-07): ** on the cache using a hash function.  This is used for testing
1.344        (drh      16-Jun-07): ** and debugging only.
1.344        (drh      16-Jun-07): */
1.189        (danielk1 15-Feb-05): #ifdef SQLITE_CHECK_PAGES
1.189        (danielk1 15-Feb-05): /*
1.189        (danielk1 15-Feb-05): ** Return a 32-bit hash of the page data for pPage.
1.189        (danielk1 15-Feb-05): */
1.344        (drh      16-Jun-07): static u32 pager_datahash(int nByte, unsigned char *pData){
1.189        (danielk1 15-Feb-05):   u32 hash = 0;
1.189        (danielk1 15-Feb-05):   int i;
1.344        (drh      16-Jun-07):   for(i=0; i<nByte; i++){
1.344        (drh      16-Jun-07):     hash = (hash*1039) + pData[i];
1.189        (danielk1 15-Feb-05):   }
1.189        (danielk1 15-Feb-05):   return hash;
1.189        (danielk1 15-Feb-05): }
1.344        (drh      16-Jun-07): static u32 pager_pagehash(PgHdr *pPage){
1.344        (drh      16-Jun-07):   return pager_datahash(pPage->pPager->pageSize, 
1.344        (drh      16-Jun-07):                         (unsigned char *)PGHDR_TO_DATA(pPage));
1.344        (drh      16-Jun-07): }
1.189        (danielk1 15-Feb-05): 
1.189        (danielk1 15-Feb-05): /*
1.189        (danielk1 15-Feb-05): ** The CHECK_PAGE macro takes a PgHdr* as an argument. If SQLITE_CHECK_PAGES
1.189        (danielk1 15-Feb-05): ** is defined, and NDEBUG is not defined, an assert() statement checks
1.189        (danielk1 15-Feb-05): ** that the page is either dirty or still matches the calculated page-hash.
1.189        (danielk1 15-Feb-05): */
1.189        (danielk1 15-Feb-05): #define CHECK_PAGE(x) checkPage(x)
1.189        (danielk1 15-Feb-05): static void checkPage(PgHdr *pPg){
1.189        (danielk1 15-Feb-05):   Pager *pPager = pPg->pPager;
1.238        (danielk1 16-Jan-06):   assert( !pPg->pageHash || pPager->errCode || MEMDB || pPg->dirty || 
1.189        (danielk1 15-Feb-05):       pPg->pageHash==pager_pagehash(pPg) );
1.189        (danielk1 15-Feb-05): }
1.189        (danielk1 15-Feb-05): 
1.189        (danielk1 15-Feb-05): #else
1.348        (drh      18-Jun-07): #define pager_datahash(X,Y)  0
1.344        (drh      16-Jun-07): #define pager_pagehash(X)  0
1.189        (danielk1 15-Feb-05): #define CHECK_PAGE(x)
1.189        (danielk1 15-Feb-05): #endif
1.189        (danielk1 15-Feb-05): 
1.1          (drh      11-Apr-01): /*
1.138        (danielk1 25-Jun-04): ** When this is called the journal file for pager pPager must be open.
1.138        (danielk1 25-Jun-04): ** The master journal file name is read from the end of the file and 
1.138        (danielk1 25-Jun-04): ** written into memory obtained from sqliteMalloc(). *pzMaster is
1.138        (danielk1 25-Jun-04): ** set to point at the memory and SQLITE_OK returned. The caller must
1.138        (danielk1 25-Jun-04): ** sqliteFree() *pzMaster.
1.138        (danielk1 25-Jun-04): **
1.138        (danielk1 25-Jun-04): ** If no master journal file name is present *pzMaster is set to 0 and
1.138        (danielk1 25-Jun-04): ** SQLITE_OK returned.
1.138        (danielk1 25-Jun-04): */
1.138        (danielk1 25-Jun-04): static int readMasterJournal(OsFile *pJrnl, char **pzMaster){
1.138        (danielk1 25-Jun-04):   int rc;
1.138        (danielk1 25-Jun-04):   u32 len;
1.165        (drh      01-Oct-04):   i64 szJ;
1.146        (danielk1 28-Jun-04):   u32 cksum;
1.142        (danielk1 25-Jun-04):   int i;
1.138        (danielk1 25-Jun-04):   unsigned char aMagic[8]; /* A buffer to hold the magic header */
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04):   *pzMaster = 0;
1.138        (danielk1 25-Jun-04): 
1.222        (drh      30-Nov-05):   rc = sqlite3OsFileSize(pJrnl, &szJ);
1.142        (danielk1 25-Jun-04):   if( rc!=SQLITE_OK || szJ<16 ) return rc;
1.138        (danielk1 25-Jun-04): 
1.222        (drh      30-Nov-05):   rc = sqlite3OsSeek(pJrnl, szJ-16);
1.138        (danielk1 25-Jun-04):   if( rc!=SQLITE_OK ) return rc;
1.138        (danielk1 25-Jun-04):  
1.138        (danielk1 25-Jun-04):   rc = read32bits(pJrnl, &len);
1.138        (danielk1 25-Jun-04):   if( rc!=SQLITE_OK ) return rc;
1.138        (danielk1 25-Jun-04): 
1.142        (danielk1 25-Jun-04):   rc = read32bits(pJrnl, &cksum);
1.142        (danielk1 25-Jun-04):   if( rc!=SQLITE_OK ) return rc;
1.142        (danielk1 25-Jun-04): 
1.222        (drh      30-Nov-05):   rc = sqlite3OsRead(pJrnl, aMagic, 8);
1.138        (danielk1 25-Jun-04):   if( rc!=SQLITE_OK || memcmp(aMagic, aJournalMagic, 8) ) return rc;
1.138        (danielk1 25-Jun-04): 
1.222        (drh      30-Nov-05):   rc = sqlite3OsSeek(pJrnl, szJ-16-len);
1.138        (danielk1 25-Jun-04):   if( rc!=SQLITE_OK ) return rc;
1.138        (danielk1 25-Jun-04): 
1.147        (danielk1 28-Jun-04):   *pzMaster = (char *)sqliteMalloc(len+1);
1.138        (danielk1 25-Jun-04):   if( !*pzMaster ){
1.138        (danielk1 25-Jun-04):     return SQLITE_NOMEM;
1.138        (danielk1 25-Jun-04):   }
1.222        (drh      30-Nov-05):   rc = sqlite3OsRead(pJrnl, *pzMaster, len);
1.138        (danielk1 25-Jun-04):   if( rc!=SQLITE_OK ){
1.138        (danielk1 25-Jun-04):     sqliteFree(*pzMaster);
1.138        (danielk1 25-Jun-04):     *pzMaster = 0;
1.138        (danielk1 25-Jun-04):     return rc;
1.138        (danielk1 25-Jun-04):   }
1.142        (danielk1 25-Jun-04): 
1.142        (danielk1 25-Jun-04):   /* See if the checksum matches the master journal name */
1.142        (danielk1 25-Jun-04):   for(i=0; i<len; i++){
1.147        (danielk1 28-Jun-04):     cksum -= (*pzMaster)[i];
1.142        (danielk1 25-Jun-04):   }
1.147        (danielk1 28-Jun-04):   if( cksum ){
1.147        (danielk1 28-Jun-04):     /* If the checksum doesn't add up, then one or more of the disk sectors
1.147        (danielk1 28-Jun-04):     ** containing the master journal filename is corrupted. This means
1.147        (danielk1 28-Jun-04):     ** definitely roll back, so just return SQLITE_OK and report a (nul)
1.147        (danielk1 28-Jun-04):     ** master-journal filename.
1.147        (danielk1 28-Jun-04):     */
1.142        (danielk1 25-Jun-04):     sqliteFree(*pzMaster);
1.142        (danielk1 25-Jun-04):     *pzMaster = 0;
1.182        (danielk1 13-Jan-05):   }else{
1.182        (danielk1 13-Jan-05):     (*pzMaster)[len] = '\0';
1.142        (danielk1 25-Jun-04):   }
1.138        (danielk1 25-Jun-04):    
1.138        (danielk1 25-Jun-04):   return SQLITE_OK;
1.138        (danielk1 25-Jun-04): }
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04): /*
1.138        (danielk1 25-Jun-04): ** Seek the journal file descriptor to the next sector boundary where a
1.138        (danielk1 25-Jun-04): ** journal header may be read or written. Pager.journalOff is updated with
1.138        (danielk1 25-Jun-04): ** the new seek offset.
1.138        (danielk1 25-Jun-04): **
1.138        (danielk1 25-Jun-04): ** i.e for a sector size of 512:
1.138        (danielk1 25-Jun-04): **
1.138        (danielk1 25-Jun-04): ** Input Offset              Output Offset
1.138        (danielk1 25-Jun-04): ** ---------------------------------------
1.138        (danielk1 25-Jun-04): ** 0                         0
1.138        (danielk1 25-Jun-04): ** 512                       512
1.138        (danielk1 25-Jun-04): ** 100                       512
1.138        (danielk1 25-Jun-04): ** 2000                      2048
1.138        (danielk1 25-Jun-04): ** 
1.138        (danielk1 25-Jun-04): */
1.138        (danielk1 25-Jun-04): static int seekJournalHdr(Pager *pPager){
1.165        (drh      01-Oct-04):   i64 offset = 0;
1.165        (drh      01-Oct-04):   i64 c = pPager->journalOff;
1.138        (danielk1 25-Jun-04):   if( c ){
1.138        (danielk1 25-Jun-04):     offset = ((c-1)/JOURNAL_HDR_SZ(pPager) + 1) * JOURNAL_HDR_SZ(pPager);
1.138        (danielk1 25-Jun-04):   }
1.138        (danielk1 25-Jun-04):   assert( offset%JOURNAL_HDR_SZ(pPager)==0 );
1.138        (danielk1 25-Jun-04):   assert( offset>=c );
1.138        (danielk1 25-Jun-04):   assert( (offset-c)<JOURNAL_HDR_SZ(pPager) );
1.138        (danielk1 25-Jun-04):   pPager->journalOff = offset;
1.222        (drh      30-Nov-05):   return sqlite3OsSeek(pPager->jfd, pPager->journalOff);
1.138        (danielk1 25-Jun-04): }
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04): /*
1.138        (danielk1 25-Jun-04): ** The journal file must be open when this routine is called. A journal
1.138        (danielk1 25-Jun-04): ** header (JOURNAL_HDR_SZ bytes) is written into the journal file at the
1.138        (danielk1 25-Jun-04): ** current location.
1.138        (danielk1 25-Jun-04): **
1.138        (danielk1 25-Jun-04): ** The format for the journal header is as follows:
1.138        (danielk1 25-Jun-04): ** - 8 bytes: Magic identifying journal format.
1.138        (danielk1 25-Jun-04): ** - 4 bytes: Number of records in journal, or -1 no-sync mode is on.
1.138        (danielk1 25-Jun-04): ** - 4 bytes: Random number used for page hash.
1.138        (danielk1 25-Jun-04): ** - 4 bytes: Initial database page count.
1.138        (danielk1 25-Jun-04): ** - 4 bytes: Sector size used by the process that wrote this journal.
1.138        (danielk1 25-Jun-04): ** 
1.140        (danielk1 25-Jun-04): ** Followed by (JOURNAL_HDR_SZ - 24) bytes of unused space.
1.138        (danielk1 25-Jun-04): */
1.138        (danielk1 25-Jun-04): static int writeJournalHdr(Pager *pPager){
1.235        (drh      10-Jan-06):   char zHeader[sizeof(aJournalMagic)+16];
1.290        (danielk1 19-Mar-07):   int rc;
1.138        (danielk1 25-Jun-04): 
1.290        (danielk1 19-Mar-07):   if( pPager->stmtHdrOff==0 ){
1.290        (danielk1 19-Mar-07):     pPager->stmtHdrOff = pPager->journalOff;
1.290        (danielk1 19-Mar-07):   }
1.290        (danielk1 19-Mar-07): 
1.290        (danielk1 19-Mar-07):   rc = seekJournalHdr(pPager);
1.138        (danielk1 25-Jun-04):   if( rc ) return rc;
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04):   pPager->journalHdr = pPager->journalOff;
1.138        (danielk1 25-Jun-04):   pPager->journalOff += JOURNAL_HDR_SZ(pPager);
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04):   /* FIX ME: 
1.138        (danielk1 25-Jun-04):   **
1.138        (danielk1 25-Jun-04):   ** Possibly for a pager not in no-sync mode, the journal magic should not
1.138        (danielk1 25-Jun-04):   ** be written until nRec is filled in as part of next syncJournal(). 
1.138        (danielk1 25-Jun-04):   **
1.138        (danielk1 25-Jun-04):   ** Actually maybe the whole journal header should be delayed until that
1.138        (danielk1 25-Jun-04):   ** point. Think about this.
1.138        (danielk1 25-Jun-04):   */
1.235        (drh      10-Jan-06):   memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
1.235        (drh      10-Jan-06):   /* The nRec Field. 0xFFFFFFFF for no-sync journals. */
1.235        (drh      10-Jan-06):   put32bits(&zHeader[sizeof(aJournalMagic)], pPager->noSync ? 0xffffffff : 0);
1.235        (drh      10-Jan-06):   /* The random check-hash initialiser */ 
1.235        (drh      10-Jan-06):   sqlite3Randomness(sizeof(pPager->cksumInit), &pPager->cksumInit);
1.235        (drh      10-Jan-06):   put32bits(&zHeader[sizeof(aJournalMagic)+4], pPager->cksumInit);
1.235        (drh      10-Jan-06):   /* The initial database size */
1.235        (drh      10-Jan-06):   put32bits(&zHeader[sizeof(aJournalMagic)+8], pPager->dbSize);
1.235        (drh      10-Jan-06):   /* The assumed sector size for this process */
1.235        (drh      10-Jan-06):   put32bits(&zHeader[sizeof(aJournalMagic)+12], pPager->sectorSize);
1.283        (drh      28-Feb-07):   IOTRACE(("JHDR %p %lld %d\n", pPager, pPager->journalHdr, sizeof(zHeader)))
1.235        (drh      10-Jan-06):   rc = sqlite3OsWrite(pPager->jfd, zHeader, sizeof(zHeader));
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04):   /* The journal header has been written successfully. Seek the journal
1.138        (danielk1 25-Jun-04):   ** file descriptor to the end of the journal header sector.
1.138        (danielk1 25-Jun-04):   */
1.138        (danielk1 25-Jun-04):   if( rc==SQLITE_OK ){
1.283        (drh      28-Feb-07):     IOTRACE(("JTAIL %p %lld\n", pPager, pPager->journalOff-1))
1.222        (drh      30-Nov-05):     rc = sqlite3OsSeek(pPager->jfd, pPager->journalOff-1);
1.212        (drh      09-Sep-05):     if( rc==SQLITE_OK ){
1.222        (drh      30-Nov-05):       rc = sqlite3OsWrite(pPager->jfd, "\000", 1);
1.212        (drh      09-Sep-05):     }
1.138        (danielk1 25-Jun-04):   }
1.138        (danielk1 25-Jun-04):   return rc;
1.138        (danielk1 25-Jun-04): }
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04): /*
1.138        (danielk1 25-Jun-04): ** The journal file must be open when this is called. A journal header file
1.138        (danielk1 25-Jun-04): ** (JOURNAL_HDR_SZ bytes) is read from the current location in the journal
1.138        (danielk1 25-Jun-04): ** file. See comments above function writeJournalHdr() for a description of
1.138        (danielk1 25-Jun-04): ** the journal header format.
1.138        (danielk1 25-Jun-04): **
1.138        (danielk1 25-Jun-04): ** If the header is read successfully, *nRec is set to the number of
1.138        (danielk1 25-Jun-04): ** page records following this header and *dbSize is set to the size of the
1.138        (danielk1 25-Jun-04): ** database before the transaction began, in pages. Also, pPager->cksumInit
1.138        (danielk1 25-Jun-04): ** is set to the value read from the journal header. SQLITE_OK is returned
1.138        (danielk1 25-Jun-04): ** in this case.
1.138        (danielk1 25-Jun-04): **
1.138        (danielk1 25-Jun-04): ** If the journal header file appears to be corrupted, SQLITE_DONE is
1.138        (danielk1 25-Jun-04): ** returned and *nRec and *dbSize are not set.  If JOURNAL_HDR_SZ bytes
1.138        (danielk1 25-Jun-04): ** cannot be read from the journal file an error code is returned.
1.138        (danielk1 25-Jun-04): */
1.138        (danielk1 25-Jun-04): static int readJournalHdr(
1.138        (danielk1 25-Jun-04):   Pager *pPager, 
1.165        (drh      01-Oct-04):   i64 journalSize,
1.138        (danielk1 25-Jun-04):   u32 *pNRec, 
1.138        (danielk1 25-Jun-04):   u32 *pDbSize
1.138        (danielk1 25-Jun-04): ){
1.138        (danielk1 25-Jun-04):   int rc;
1.138        (danielk1 25-Jun-04):   unsigned char aMagic[8]; /* A buffer to hold the magic header */
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04):   rc = seekJournalHdr(pPager);
1.138        (danielk1 25-Jun-04):   if( rc ) return rc;
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04):   if( pPager->journalOff+JOURNAL_HDR_SZ(pPager) > journalSize ){
1.138        (danielk1 25-Jun-04):     return SQLITE_DONE;
1.138        (danielk1 25-Jun-04):   }
1.138        (danielk1 25-Jun-04): 
1.222        (drh      30-Nov-05):   rc = sqlite3OsRead(pPager->jfd, aMagic, sizeof(aMagic));
1.138        (danielk1 25-Jun-04):   if( rc ) return rc;
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04):   if( memcmp(aMagic, aJournalMagic, sizeof(aMagic))!=0 ){
1.138        (danielk1 25-Jun-04):     return SQLITE_DONE;
1.138        (danielk1 25-Jun-04):   }
1.138        (danielk1 25-Jun-04): 
1.221        (drh      29-Nov-05):   rc = read32bits(pPager->jfd, pNRec);
1.138        (danielk1 25-Jun-04):   if( rc ) return rc;
1.138        (danielk1 25-Jun-04): 
1.221        (drh      29-Nov-05):   rc = read32bits(pPager->jfd, &pPager->cksumInit);
1.138        (danielk1 25-Jun-04):   if( rc ) return rc;
1.138        (danielk1 25-Jun-04): 
1.221        (drh      29-Nov-05):   rc = read32bits(pPager->jfd, pDbSize);
1.138        (danielk1 25-Jun-04):   if( rc ) return rc;
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04):   /* Update the assumed sector-size to match the value used by 
1.138        (danielk1 25-Jun-04):   ** the process that created this journal. If this journal was
1.138        (danielk1 25-Jun-04):   ** created by a process other than this one, then this routine
1.138        (danielk1 25-Jun-04):   ** is being called from within pager_playback(). The local value
1.138        (danielk1 25-Jun-04):   ** of Pager.sectorSize is restored at the end of that routine.
1.138        (danielk1 25-Jun-04):   */
1.221        (drh      29-Nov-05):   rc = read32bits(pPager->jfd, (u32 *)&pPager->sectorSize);
1.138        (danielk1 25-Jun-04):   if( rc ) return rc;
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04):   pPager->journalOff += JOURNAL_HDR_SZ(pPager);
1.222        (drh      30-Nov-05):   rc = sqlite3OsSeek(pPager->jfd, pPager->journalOff);
1.138        (danielk1 25-Jun-04):   return rc;
1.138        (danielk1 25-Jun-04): }
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04): /*
1.138        (danielk1 25-Jun-04): ** Write the supplied master journal name into the journal file for pager
1.142        (danielk1 25-Jun-04): ** pPager at the current location. The master journal name must be the last
1.142        (danielk1 25-Jun-04): ** thing written to a journal file. If the pager is in full-sync mode, the
1.142        (danielk1 25-Jun-04): ** journal file descriptor is advanced to the next sector boundary before
1.142        (danielk1 25-Jun-04): ** anything is written. The format is:
1.142        (danielk1 25-Jun-04): **
1.142        (danielk1 25-Jun-04): ** + 4 bytes: PAGER_MJ_PGNO.
1.142        (danielk1 25-Jun-04): ** + N bytes: length of master journal name.
1.142        (danielk1 25-Jun-04): ** + 4 bytes: N
1.142        (danielk1 25-Jun-04): ** + 4 bytes: Master journal name checksum.
1.142        (danielk1 25-Jun-04): ** + 8 bytes: aJournalMagic[].
1.142        (danielk1 25-Jun-04): **
1.142        (danielk1 25-Jun-04): ** The master journal page checksum is the sum of the bytes in the master
1.142        (danielk1 25-Jun-04): ** journal name.
1.229        (danielk1 30-Dec-05): **
1.229        (danielk1 30-Dec-05): ** If zMaster is a NULL pointer (occurs for a single database transaction), 
1.229        (danielk1 30-Dec-05): ** this call is a no-op.
1.138        (danielk1 25-Jun-04): */
1.138        (danielk1 25-Jun-04): static int writeMasterJournal(Pager *pPager, const char *zMaster){
1.138        (danielk1 25-Jun-04):   int rc;
1.138        (danielk1 25-Jun-04):   int len; 
1.142        (danielk1 25-Jun-04):   int i; 
1.235        (drh      10-Jan-06):   u32 cksum = 0;
1.235        (drh      10-Jan-06):   char zBuf[sizeof(aJournalMagic)+2*4];
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04):   if( !zMaster || pPager->setMaster) return SQLITE_OK;
1.138        (danielk1 25-Jun-04):   pPager->setMaster = 1;
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04):   len = strlen(zMaster);
1.142        (danielk1 25-Jun-04):   for(i=0; i<len; i++){
1.142        (danielk1 25-Jun-04):     cksum += zMaster[i];
1.142        (danielk1 25-Jun-04):   }
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04):   /* If in full-sync mode, advance to the next disk sector before writing
1.138        (danielk1 25-Jun-04):   ** the master journal name. This is in case the previous page written to
1.138        (danielk1 25-Jun-04):   ** the journal has already been synced.
1.138        (danielk1 25-Jun-04):   */
1.138        (danielk1 25-Jun-04):   if( pPager->fullSync ){
1.138        (danielk1 25-Jun-04):     rc = seekJournalHdr(pPager);
1.138        (danielk1 25-Jun-04):     if( rc!=SQLITE_OK ) return rc;
1.138        (danielk1 25-Jun-04):   }
1.142        (danielk1 25-Jun-04):   pPager->journalOff += (len+20);
1.138        (danielk1 25-Jun-04): 
1.221        (drh      29-Nov-05):   rc = write32bits(pPager->jfd, PAGER_MJ_PGNO(pPager));
1.138        (danielk1 25-Jun-04):   if( rc!=SQLITE_OK ) return rc;
1.138        (danielk1 25-Jun-04): 
1.222        (drh      30-Nov-05):   rc = sqlite3OsWrite(pPager->jfd, zMaster, len);
1.138        (danielk1 25-Jun-04):   if( rc!=SQLITE_OK ) return rc;
1.138        (danielk1 25-Jun-04): 
1.235        (drh      10-Jan-06):   put32bits(zBuf, len);
1.235        (drh      10-Jan-06):   put32bits(&zBuf[4], cksum);
1.235        (drh      10-Jan-06):   memcpy(&zBuf[8], aJournalMagic, sizeof(aJournalMagic));
1.235        (drh      10-Jan-06):   rc = sqlite3OsWrite(pPager->jfd, zBuf, 8+sizeof(aJournalMagic));
1.210        (drh      27-Aug-05):   pPager->needSync = !pPager->noSync;
1.138        (danielk1 25-Jun-04):   return rc;
1.138        (danielk1 25-Jun-04): }
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04): /*
1.57         (drh      10-Nov-02): ** Add or remove a page from the list of all pages that are in the
1.107        (drh      12-May-04): ** statement journal.
1.57         (drh      10-Nov-02): **
1.57         (drh      10-Nov-02): ** The Pager keeps a separate list of pages that are currently in
1.292        (danielk1 19-Mar-07): ** the statement journal.  This helps the sqlite3PagerStmtCommit()
1.57         (drh      10-Nov-02): ** routine run MUCH faster for the common case where there are many
1.107        (drh      12-May-04): ** pages in memory but only a few are in the statement journal.
1.57         (drh      10-Nov-02): */
1.102        (drh      26-Apr-04): static void page_add_to_stmt_list(PgHdr *pPg){
1.57         (drh      10-Nov-02):   Pager *pPager = pPg->pPager;
1.325        (danielk1 07-Apr-07):   PgHistory *pHist = PGHDR_TO_HIST(pPg, pPager);
1.325        (danielk1 07-Apr-07):   assert( MEMDB );
1.325        (danielk1 07-Apr-07):   if( !pHist->inStmt ){
1.325        (danielk1 07-Apr-07):     assert( pHist->pPrevStmt==0 && pHist->pNextStmt==0 );
1.325        (danielk1 07-Apr-07):     if( pPager->pStmt ){
1.325        (danielk1 07-Apr-07):       PGHDR_TO_HIST(pPager->pStmt, pPager)->pPrevStmt = pPg;
1.325        (danielk1 07-Apr-07):     }
1.325        (danielk1 07-Apr-07):     pHist->pNextStmt = pPager->pStmt;
1.325        (danielk1 07-Apr-07):     pPager->pStmt = pPg;
1.325        (danielk1 07-Apr-07):     pHist->inStmt = 1;
1.57         (drh      10-Nov-02):   }
1.57         (drh      10-Nov-02): }
1.57         (drh      10-Nov-02): 
1.57         (drh      10-Nov-02): /*
1.1          (drh      11-Apr-01): ** Find a page in the hash table given its page number.  Return
1.1          (drh      11-Apr-01): ** a pointer to the page or NULL if not found.
1.1          (drh      11-Apr-01): */
1.3          (drh      15-Apr-01): static PgHdr *pager_lookup(Pager *pPager, Pgno pgno){
1.268        (drh      07-May-06):   PgHdr *p;
1.268        (drh      07-May-06):   if( pPager->aHash==0 ) return 0;
1.268        (drh      07-May-06):   p = pPager->aHash[pgno & (pPager->nHash-1)];
1.1          (drh      11-Apr-01):   while( p && p->pgno!=pgno ){
1.1          (drh      11-Apr-01):     p = p->pNextHash;
1.1          (drh      11-Apr-01):   }
1.1          (drh      11-Apr-01):   return p;
1.1          (drh      11-Apr-01): }
1.1          (drh      11-Apr-01): 
1.1          (drh      11-Apr-01): /*
1.279        (drh      03-Jan-07): ** Unlock the database file.
1.279        (drh      03-Jan-07): */
1.279        (drh      03-Jan-07): static void pager_unlock(Pager *pPager){
1.294        (danielk1 24-Mar-07):   if( !pPager->exclusiveMode ){
1.294        (danielk1 24-Mar-07):     if( !MEMDB ){
1.294        (danielk1 24-Mar-07):       sqlite3OsUnlock(pPager->fd, NO_LOCK);
1.294        (danielk1 24-Mar-07):       pPager->dbSize = -1;
1.294        (danielk1 24-Mar-07):       IOTRACE(("UNLOCK %p\n", pPager))
1.294        (danielk1 24-Mar-07):     }
1.294        (danielk1 24-Mar-07):     pPager->state = PAGER_UNLOCK;
1.294        (danielk1 24-Mar-07):     pPager->changeCountDone = 0;
1.279        (drh      03-Jan-07):   }
1.293        (danielk1 23-Mar-07): }
1.293        (danielk1 23-Mar-07): 
1.293        (danielk1 23-Mar-07): /*
1.293        (danielk1 23-Mar-07): ** Execute a rollback if a transaction is active and unlock the 
1.293        (danielk1 23-Mar-07): ** database file. This is a no-op if the pager has already entered
1.293        (danielk1 23-Mar-07): ** the error-state.
1.293        (danielk1 23-Mar-07): */
1.295        (danielk1 26-Mar-07): static void pagerUnlockAndRollback(Pager *p){
1.295        (danielk1 26-Mar-07):   if( p->errCode ) return;
1.297        (danielk1 26-Mar-07):   assert( p->state>=PAGER_RESERVED || p->journalOpen==0 );
1.295        (danielk1 26-Mar-07):   if( p->state>=PAGER_RESERVED ){
1.295        (danielk1 26-Mar-07):     sqlite3PagerRollback(p);
1.295        (danielk1 26-Mar-07):   }
1.295        (danielk1 26-Mar-07):   pager_unlock(p);
1.295        (danielk1 26-Mar-07):   assert( p->errCode || !p->journalOpen || (p->exclusiveMode&&!p->journalOff) );
1.295        (danielk1 26-Mar-07):   assert( p->errCode || !p->stmtOpen || p->exclusiveMode );
1.279        (drh      03-Jan-07): }
1.279        (drh      03-Jan-07): 
1.279        (drh      03-Jan-07): 
1.279        (drh      03-Jan-07): /*
1.323        (danielk1 05-Apr-07): ** Clear the in-memory cache.  This routine
1.1          (drh      11-Apr-01): ** sets the state of the pager back to what it was when it was first
1.1          (drh      11-Apr-01): ** opened.  Any outstanding pages are invalidated and subsequent attempts
1.1          (drh      11-Apr-01): ** to access those pages will likely result in a coredump.
1.1          (drh      11-Apr-01): */
1.3          (drh      15-Apr-01): static void pager_reset(Pager *pPager){
1.1          (drh      11-Apr-01):   PgHdr *pPg, *pNext;
1.238        (danielk1 16-Jan-06):   if( pPager->errCode ) return;
1.3          (drh      15-Apr-01):   for(pPg=pPager->pAll; pPg; pPg=pNext){
1.327        (drh      13-Apr-07):     IOTRACE(("PGFREE %p %d\n", pPager, pPg->pgno));
1.327        (drh      13-Apr-07):     PAGER_INCR(sqlite3_pager_pgfree_count);
1.3          (drh      15-Apr-01):     pNext = pPg->pNextAll;
1.3          (drh      15-Apr-01):     sqliteFree(pPg);
1.1          (drh      11-Apr-01):   }
1.291        (danielk1 19-Mar-07):   pPager->pStmt = 0;
1.1          (drh      11-Apr-01):   pPager->pFirst = 0;
1.69         (drh      21-Jan-03):   pPager->pFirstSynced = 0;
1.3          (drh      15-Apr-01):   pPager->pLast = 0;
1.3          (drh      15-Apr-01):   pPager->pAll = 0;
1.268        (drh      07-May-06):   pPager->nHash = 0;
1.268        (drh      07-May-06):   sqliteFree(pPager->aHash);
1.1          (drh      11-Apr-01):   pPager->nPage = 0;
1.268        (drh      07-May-06):   pPager->aHash = 0;
1.293        (danielk1 23-Mar-07):   pPager->nRef = 0;
1.293        (danielk1 23-Mar-07): }
1.293        (danielk1 23-Mar-07): 
1.293        (danielk1 23-Mar-07): /*
1.307        (drh      30-Mar-07): ** This routine ends a transaction.  A transaction is ended by either
1.307        (drh      30-Mar-07): ** a COMMIT or a ROLLBACK.
1.307        (drh      30-Mar-07): **
1.1          (drh      11-Apr-01): ** When this routine is called, the pager has the journal file open and
1.307        (drh      30-Mar-07): ** a RESERVED or EXCLUSIVE lock on the database.  This routine will release
1.307        (drh      30-Mar-07): ** the database lock and acquires a SHARED lock in its place if that is
1.307        (drh      30-Mar-07): ** the appropriate thing to do.  Release locks usually is appropriate,
1.307        (drh      30-Mar-07): ** unless we are in exclusive access mode or unless this is a 
1.307        (drh      30-Mar-07): ** COMMIT AND BEGIN or ROLLBACK AND BEGIN operation.
1.307        (drh      30-Mar-07): **
1.307        (drh      30-Mar-07): ** The journal file is either deleted or truncated.
1.90         (drh      06-Sep-03): **
1.90         (drh      06-Sep-03): ** TODO: Consider keeping the journal file open for temporary databases.
1.90         (drh      06-Sep-03): ** This might give a performance improvement on windows where opening
1.90         (drh      06-Sep-03): ** a file is an expensive operation.
1.1          (drh      11-Apr-01): */
1.307        (drh      30-Mar-07): static int pager_end_transaction(Pager *pPager){
1.3          (drh      15-Apr-01):   PgHdr *pPg;
1.294        (danielk1 24-Mar-07):   int rc = SQLITE_OK;
1.302        (danielk1 27-Mar-07):   int rc2 = SQLITE_OK;
1.169        (drh      31-Oct-04):   assert( !MEMDB );
1.115        (drh      09-Jun-04):   if( pPager->state<PAGER_RESERVED ){
1.115        (drh      09-Jun-04):     return SQLITE_OK;
1.115        (drh      09-Jun-04):   }
1.292        (danielk1 19-Mar-07):   sqlite3PagerStmtCommit(pPager);
1.295        (danielk1 26-Mar-07):   if( pPager->stmtOpen && !pPager->exclusiveMode ){
1.302        (danielk1 27-Mar-07):     sqlite3OsClose(&pPager->stfd);
1.302        (danielk1 27-Mar-07):     pPager->stmtOpen = 0;
1.46         (drh      30-May-02):   }
1.60         (drh      02-Dec-02):   if( pPager->journalOpen ){
1.316        (drh      02-Apr-07):     if( pPager->exclusiveMode 
1.316        (drh      02-Apr-07):           && (rc = sqlite3OsTruncate(pPager->jfd, 0))==SQLITE_OK ){;
1.294        (danielk1 24-Mar-07):       sqlite3OsSeek(pPager->jfd, 0);
1.294        (danielk1 24-Mar-07):       pPager->journalOff = 0;
1.295        (danielk1 26-Mar-07):       pPager->journalStarted = 0;
1.294        (danielk1 24-Mar-07):     }else{
1.294        (danielk1 24-Mar-07):       sqlite3OsClose(&pPager->jfd);
1.294        (danielk1 24-Mar-07):       pPager->journalOpen = 0;
1.316        (drh      02-Apr-07):       if( rc==SQLITE_OK ){
1.305        (danielk1 29-Mar-07):         rc = sqlite3OsDelete(pPager->zJournal);
1.305        (danielk1 29-Mar-07):       }
1.294        (danielk1 24-Mar-07):     }
1.60         (drh      02-Dec-02):     sqliteFree( pPager->aInJournal );
1.60         (drh      02-Dec-02):     pPager->aInJournal = 0;
1.60         (drh      02-Dec-02):     for(pPg=pPager->pAll; pPg; pPg=pPg->pNextAll){
1.60         (drh      02-Dec-02):       pPg->inJournal = 0;
1.60         (drh      02-Dec-02):       pPg->dirty = 0;
1.68         (drh      16-Jan-03):       pPg->needSync = 0;
1.294        (danielk1 24-Mar-07):       pPg->alwaysRollback = 0;
1.189        (danielk1 15-Feb-05): #ifdef SQLITE_CHECK_PAGES
1.189        (danielk1 15-Feb-05):       pPg->pageHash = pager_pagehash(pPg);
1.189        (danielk1 15-Feb-05): #endif
1.60         (drh      02-Dec-02):     }
1.267        (drh      03-May-06):     pPager->pDirty = 0;
1.137        (danielk1 23-Jun-04):     pPager->dirtyCache = 0;
1.137        (danielk1 23-Jun-04):     pPager->nRec = 0;
1.60         (drh      02-Dec-02):   }else{
1.201        (drh      28-Mar-05):     assert( pPager->aInJournal==0 );
1.115        (drh      09-Jun-04):     assert( pPager->dirtyCache==0 || pPager->useJournal==0 );
1.60         (drh      02-Dec-02):   }
1.302        (danielk1 27-Mar-07): 
1.294        (danielk1 24-Mar-07):   if( !pPager->exclusiveMode ){
1.302        (danielk1 27-Mar-07):     rc2 = sqlite3OsUnlock(pPager->fd, SHARED_LOCK);
1.294        (danielk1 24-Mar-07):     pPager->state = PAGER_SHARED;
1.295        (danielk1 26-Mar-07):   }else if( pPager->state==PAGER_SYNCED ){
1.295        (danielk1 26-Mar-07):     pPager->state = PAGER_EXCLUSIVE;
1.294        (danielk1 24-Mar-07):   }
1.295        (danielk1 26-Mar-07):   pPager->origDbSize = 0;
1.138        (danielk1 25-Jun-04):   pPager->setMaster = 0;
1.249        (danielk1 21-Jan-06):   pPager->needSync = 0;
1.249        (danielk1 21-Jan-06):   pPager->pFirstSynced = pPager->pFirst;
1.278        (drh      02-Jan-07):   pPager->dbSize = -1;
1.302        (danielk1 27-Mar-07): 
1.302        (danielk1 27-Mar-07):   return (rc==SQLITE_OK?rc2:rc);
1.1          (drh      11-Apr-01): }
1.1          (drh      11-Apr-01): 
1.1          (drh      11-Apr-01): /*
1.73         (drh      11-Feb-03): ** Compute and return a checksum for the page of data.
1.94         (drh      08-Feb-04): **
1.94         (drh      08-Feb-04): ** This is not a real checksum.  It is really just the sum of the 
1.123        (drh      10-Jun-04): ** random initial value and the page number.  We experimented with
1.123        (drh      10-Jun-04): ** a checksum of the entire data, but that was found to be too slow.
1.123        (drh      10-Jun-04): **
1.123        (drh      10-Jun-04): ** Note that the page number is stored at the beginning of data and
1.123        (drh      10-Jun-04): ** the checksum is stored at the end.  This is important.  If journal
1.123        (drh      10-Jun-04): ** corruption occurs due to a power failure, the most likely scenario
1.123        (drh      10-Jun-04): ** is that one end or the other of the record will be changed.  It is
1.123        (drh      10-Jun-04): ** much less likely that the two ends of the journal record will be
1.123        (drh      10-Jun-04): ** correct and the middle be corrupt.  Thus, this "checksum" scheme,
1.123        (drh      10-Jun-04): ** though fast and simple, catches the mostly likely kind of corruption.
1.123        (drh      10-Jun-04): **
1.123        (drh      10-Jun-04): ** FIX ME:  Consider adding every 200th (or so) byte of the data to the
1.123        (drh      10-Jun-04): ** checksum.  That way if a single page spans 3 or more disk sectors and
1.123        (drh      10-Jun-04): ** only the middle sector is corrupt, we will still have a reasonable
1.123        (drh      10-Jun-04): ** chance of failing the checksum and thus detecting the problem.
1.73         (drh      11-Feb-03): */
1.259        (drh      24-Feb-06): static u32 pager_cksum(Pager *pPager, const u8 *aData){
1.137        (danielk1 23-Jun-04):   u32 cksum = pPager->cksumInit;
1.137        (danielk1 23-Jun-04):   int i = pPager->pageSize-200;
1.137        (danielk1 23-Jun-04):   while( i>0 ){
1.137        (danielk1 23-Jun-04):     cksum += aData[i];
1.137        (danielk1 23-Jun-04):     i -= 200;
1.137        (danielk1 23-Jun-04):   }
1.73         (drh      11-Feb-03):   return cksum;
1.73         (drh      11-Feb-03): }
1.73         (drh      11-Feb-03): 
1.267        (drh      03-May-06): /* Forward declaration */
1.267        (drh      03-May-06): static void makeClean(PgHdr*);
1.267        (drh      03-May-06): 
1.73         (drh      11-Feb-03): /*
1.37         (drh      02-Feb-02): ** Read a single page from the journal file opened on file descriptor
1.37         (drh      02-Feb-02): ** jfd.  Playback this one page.
1.73         (drh      11-Feb-03): **
1.123        (drh      10-Jun-04): ** If useCksum==0 it means this journal does not use checksums.  Checksums
1.123        (drh      10-Jun-04): ** are not used in statement journals because statement journals do not
1.123        (drh      10-Jun-04): ** need to survive power failures.
1.37         (drh      02-Feb-02): */
1.116        (drh      09-Jun-04): static int pager_playback_one_page(Pager *pPager, OsFile *jfd, int useCksum){
1.37         (drh      02-Feb-02):   int rc;
1.116        (drh      09-Jun-04):   PgHdr *pPg;                   /* An existing page in the cache */
1.116        (drh      09-Jun-04):   Pgno pgno;                    /* The page number of a page in journal */
1.116        (drh      09-Jun-04):   u32 cksum;                    /* Checksum used for sanity checking */
1.286        (danielk1 06-Mar-07):   u8 *aData = (u8 *)pPager->pTmpSpace;   /* Temp storage for a page */
1.37         (drh      02-Feb-02): 
1.196        (drh      20-Mar-05):   /* useCksum should be true for the main journal and false for
1.196        (drh      20-Mar-05):   ** statement journals.  Verify that this is always the case
1.196        (drh      20-Mar-05):   */
1.221        (drh      29-Nov-05):   assert( jfd == (useCksum ? pPager->jfd : pPager->stfd) );
1.286        (danielk1 06-Mar-07):   assert( aData );
1.196        (drh      20-Mar-05): 
1.116        (drh      09-Jun-04):   rc = read32bits(jfd, &pgno);
1.78         (drh      16-Feb-03):   if( rc!=SQLITE_OK ) return rc;
1.286        (danielk1 06-Mar-07):   rc = sqlite3OsRead(jfd, aData, pPager->pageSize);
1.78         (drh      16-Feb-03):   if( rc!=SQLITE_OK ) return rc;
1.138        (danielk1 25-Jun-04):   pPager->journalOff += pPager->pageSize + 4;
1.37         (drh      02-Feb-02): 
1.73         (drh      11-Feb-03):   /* Sanity checking on the page.  This is more important that I originally
1.73         (drh      11-Feb-03):   ** thought.  If a power failure occurs while the journal is being written,
1.73         (drh      11-Feb-03):   ** it could cause invalid data to be written into the journal.  We need to
1.73         (drh      11-Feb-03):   ** detect this invalid data (with high probability) and ignore it.
1.73         (drh      11-Feb-03):   */
1.143        (danielk1 26-Jun-04):   if( pgno==0 || pgno==PAGER_MJ_PGNO(pPager) ){
1.73         (drh      11-Feb-03):     return SQLITE_DONE;
1.73         (drh      11-Feb-03):   }
1.116        (drh      09-Jun-04):   if( pgno>(unsigned)pPager->dbSize ){
1.73         (drh      11-Feb-03):     return SQLITE_OK;
1.73         (drh      11-Feb-03):   }
1.116        (drh      09-Jun-04):   if( useCksum ){
1.116        (drh      09-Jun-04):     rc = read32bits(jfd, &cksum);
1.78         (drh      16-Feb-03):     if( rc ) return rc;
1.138        (danielk1 25-Jun-04):     pPager->journalOff += 4;
1.259        (drh      24-Feb-06):     if( pager_cksum(pPager, aData)!=cksum ){
1.73         (drh      11-Feb-03):       return SQLITE_DONE;
1.73         (drh      11-Feb-03):     }
1.73         (drh      11-Feb-03):   }
1.37         (drh      02-Feb-02): 
1.125        (danielk1 14-Jun-04):   assert( pPager->state==PAGER_RESERVED || pPager->state>=PAGER_EXCLUSIVE );
1.121        (danielk1 10-Jun-04): 
1.121        (danielk1 10-Jun-04):   /* If the pager is in RESERVED state, then there must be a copy of this
1.121        (danielk1 10-Jun-04):   ** page in the pager cache. In this case just update the pager cache,
1.122        (danielk1 10-Jun-04):   ** not the database file. The page is left marked dirty in this case.
1.122        (danielk1 10-Jun-04):   **
1.341        (danielk1 24-May-07):   ** An exception to the above rule: If the database is in no-sync mode
1.341        (danielk1 24-May-07):   ** and a page is moved during an incremental vacuum then the page may
1.342        (danielk1 24-May-07):   ** not be in the pager cache. Later: if a malloc() or IO error occurs
1.342        (danielk1 24-May-07):   ** during a Movepage() call, then the page may not be in the cache
1.342        (danielk1 24-May-07):   ** either. So the condition described in the above paragraph is not
1.342        (danielk1 24-May-07):   ** assert()able.
1.341        (danielk1 24-May-07):   **
1.121        (danielk1 10-Jun-04):   ** If in EXCLUSIVE state, then we update the pager cache if it exists
1.121        (danielk1 10-Jun-04):   ** and the main file. The page is then marked not dirty.
1.196        (drh      20-Mar-05):   **
1.196        (drh      20-Mar-05):   ** Ticket #1171:  The statement journal might contain page content that is
1.196        (drh      20-Mar-05):   ** different from the page content at the start of the transaction.
1.196        (drh      20-Mar-05):   ** This occurs when a page is changed prior to the start of a statement
1.196        (drh      20-Mar-05):   ** then changed again within the statement.  When rolling back such a
1.196        (drh      20-Mar-05):   ** statement we must not write to the original database unless we know
1.345        (drh      16-Jun-07):   ** for certain that original page contents are synced into the main rollback
1.345        (drh      16-Jun-07):   ** journal.  Otherwise, a power loss might leave modified data in the
1.345        (drh      16-Jun-07):   ** database file without an entry in the rollback journal that can
1.345        (drh      16-Jun-07):   ** restore the database to its original form.  Two conditions must be
1.345        (drh      16-Jun-07):   ** met before writing to the database files. (1) the database must be
1.345        (drh      16-Jun-07):   ** locked.  (2) we know that the original page content is fully synced
1.345        (drh      16-Jun-07):   ** in the main journal either because the page is not in cache or else
1.345        (drh      16-Jun-07):   ** the page is marked as needSync==0.
1.37         (drh      02-Feb-02):   */
1.116        (drh      09-Jun-04):   pPg = pager_lookup(pPager, pgno);
1.344        (drh      16-Jun-07):   PAGERTRACE4("PLAYBACK %d page %d hash(%08x)\n",
1.344        (drh      16-Jun-07):                PAGERID(pPager), pgno, pager_datahash(pPager->pageSize, aData));
1.196        (drh      20-Mar-05):   if( pPager->state>=PAGER_EXCLUSIVE && (pPg==0 || pPg->needSync==0) ){
1.222        (drh      30-Nov-05):     rc = sqlite3OsSeek(pPager->fd, (pgno-1)*(i64)pPager->pageSize);
1.212        (drh      09-Sep-05):     if( rc==SQLITE_OK ){
1.222        (drh      30-Nov-05):       rc = sqlite3OsWrite(pPager->fd, aData, pPager->pageSize);
1.212        (drh      09-Sep-05):     }
1.267        (drh      03-May-06):     if( pPg ){
1.267        (drh      03-May-06):       makeClean(pPg);
1.267        (drh      03-May-06):     }
1.121        (danielk1 10-Jun-04):   }
1.37         (drh      02-Feb-02):   if( pPg ){
1.181        (danielk1 11-Jan-05):     /* No page should ever be explicitly rolled back that is in use, except
1.181        (danielk1 11-Jan-05):     ** for page 1 which is held in use in order to keep the lock on the
1.181        (danielk1 11-Jan-05):     ** database active. However such a page may be rolled back as a result
1.181        (danielk1 11-Jan-05):     ** of an internal error resulting in an automatic call to
1.292        (danielk1 19-Mar-07):     ** sqlite3PagerRollback().
1.91         (drh      17-Dec-03):     */
1.108        (drh      14-May-04):     void *pData;
1.181        (danielk1 11-Jan-05):     /* assert( pPg->nRef==0 || pPg->pgno==1 ); */
1.108        (drh      14-May-04):     pData = PGHDR_TO_DATA(pPg);
1.116        (drh      09-Jun-04):     memcpy(pData, aData, pPager->pageSize);
1.326        (danielk1 09-Apr-07):     if( pPager->xReiniter ){
1.326        (danielk1 09-Apr-07):       pPager->xReiniter(pPg, pPager->pageSize);
1.103        (drh      07-May-04):     }
1.189        (danielk1 15-Feb-05): #ifdef SQLITE_CHECK_PAGES
1.196        (drh      20-Mar-05):     pPg->pageHash = pager_pagehash(pPg);
1.189        (danielk1 15-Feb-05): #endif
1.329        (drh      16-Apr-07):     /* If this was page 1, then restore the value of Pager.dbFileVers.
1.329        (drh      16-Apr-07):     ** Do this before any decoding. */
1.294        (danielk1 24-Mar-07):     if( pgno==1 ){
1.329        (drh      16-Apr-07):       memcpy(&pPager->dbFileVers, &((u8*)pData)[24],sizeof(pPager->dbFileVers));
1.294        (danielk1 24-Mar-07):     }
1.329        (drh      16-Apr-07): 
1.329        (drh      16-Apr-07):     /* Decode the page just read from disk */
1.329        (drh      16-Apr-07):     CODEC1(pPager, pData, pPg->pgno, 3);
1.37         (drh      02-Feb-02):   }
1.37         (drh      02-Feb-02):   return rc;
1.37         (drh      02-Feb-02): }
1.37         (drh      02-Feb-02): 
1.37         (drh      02-Feb-02): /*
1.110        (danielk1 03-Jun-04): ** Parameter zMaster is the name of a master journal file. A single journal
1.110        (danielk1 03-Jun-04): ** file that referred to the master journal file has just been rolled back.
1.110        (danielk1 03-Jun-04): ** This routine checks if it is possible to delete the master journal file,
1.110        (danielk1 03-Jun-04): ** and does so if it is.
1.123        (drh      10-Jun-04): **
1.123        (drh      10-Jun-04): ** The master journal file contains the names of all child journals.
1.123        (drh      10-Jun-04): ** To tell if a master journal can be deleted, check to each of the
1.123        (drh      10-Jun-04): ** children.  If all children are either missing or do not refer to
1.123        (drh      10-Jun-04): ** a different master journal, then this master journal can be deleted.
1.110        (danielk1 03-Jun-04): */
1.110        (danielk1 03-Jun-04): static int pager_delmaster(const char *zMaster){
1.110        (danielk1 03-Jun-04):   int rc;
1.110        (danielk1 03-Jun-04):   int master_open = 0;
1.221        (drh      29-Nov-05):   OsFile *master = 0;
1.110        (danielk1 03-Jun-04):   char *zMasterJournal = 0; /* Contents of master journal file */
1.165        (drh      01-Oct-04):   i64 nMasterJournal;       /* Size of master journal file */
1.110        (danielk1 03-Jun-04): 
1.110        (danielk1 03-Jun-04):   /* Open the master journal file exclusively in case some other process
1.110        (danielk1 03-Jun-04):   ** is running this routine also. Not that it makes too much difference.
1.110        (danielk1 03-Jun-04):   */
1.231        (drh      06-Jan-06):   rc = sqlite3OsOpenReadOnly(zMaster, &master);
1.320        (danielk1 05-Apr-07):   assert( rc!=SQLITE_OK || master );
1.110        (danielk1 03-Jun-04):   if( rc!=SQLITE_OK ) goto delmaster_out;
1.110        (danielk1 03-Jun-04):   master_open = 1;
1.222        (drh      30-Nov-05):   rc = sqlite3OsFileSize(master, &nMasterJournal);
1.110        (danielk1 03-Jun-04):   if( rc!=SQLITE_OK ) goto delmaster_out;
1.110        (danielk1 03-Jun-04): 
1.110        (danielk1 03-Jun-04):   if( nMasterJournal>0 ){
1.126        (danielk1 14-Jun-04):     char *zJournal;
1.138        (danielk1 25-Jun-04):     char *zMasterPtr = 0;
1.126        (danielk1 14-Jun-04): 
1.126        (danielk1 14-Jun-04):     /* Load the entire master journal file into space obtained from
1.126        (danielk1 14-Jun-04):     ** sqliteMalloc() and pointed to by zMasterJournal. 
1.126        (danielk1 14-Jun-04):     */
1.138        (danielk1 25-Jun-04):     zMasterJournal = (char *)sqliteMalloc(nMasterJournal);
1.110        (danielk1 03-Jun-04):     if( !zMasterJournal ){
1.110        (danielk1 03-Jun-04):       rc = SQLITE_NOMEM;
1.110        (danielk1 03-Jun-04):       goto delmaster_out;
1.110        (danielk1 03-Jun-04):     }
1.222        (drh      30-Nov-05):     rc = sqlite3OsRead(master, zMasterJournal, nMasterJournal);
1.110        (danielk1 03-Jun-04):     if( rc!=SQLITE_OK ) goto delmaster_out;
1.110        (danielk1 03-Jun-04): 
1.126        (danielk1 14-Jun-04):     zJournal = zMasterJournal;
1.126        (danielk1 14-Jun-04):     while( (zJournal-zMasterJournal)<nMasterJournal ){
1.231        (drh      06-Jan-06):       if( sqlite3OsFileExists(zJournal) ){
1.110        (danielk1 03-Jun-04):         /* One of the journals pointed to by the master journal exists.
1.110        (danielk1 03-Jun-04):         ** Open it and check if it points at the master journal. If
1.110        (danielk1 03-Jun-04):         ** so, return without deleting the master journal file.
1.110        (danielk1 03-Jun-04):         */
1.221        (drh      29-Nov-05):         OsFile *journal = 0;
1.179        (drh      24-Nov-04):         int c;
1.110        (danielk1 03-Jun-04): 
1.231        (drh      06-Jan-06):         rc = sqlite3OsOpenReadOnly(zJournal, &journal);
1.320        (danielk1 05-Apr-07):         assert( rc!=SQLITE_OK || journal );
1.110        (danielk1 03-Jun-04):         if( rc!=SQLITE_OK ){
1.110        (danielk1 03-Jun-04):           goto delmaster_out;
1.110        (danielk1 03-Jun-04):         }
1.110        (danielk1 03-Jun-04): 
1.221        (drh      29-Nov-05):         rc = readMasterJournal(journal, &zMasterPtr);
1.222        (drh      30-Nov-05):         sqlite3OsClose(&journal);
1.112        (danielk1 04-Jun-04):         if( rc!=SQLITE_OK ){
1.112        (danielk1 04-Jun-04):           goto delmaster_out;
1.112        (danielk1 04-Jun-04):         }
1.138        (danielk1 25-Jun-04): 
1.179        (drh      24-Nov-04):         c = zMasterPtr!=0 && strcmp(zMasterPtr, zMaster)==0;
1.179        (drh      24-Nov-04):         sqliteFree(zMasterPtr);
1.179        (drh      24-Nov-04):         if( c ){
1.138        (danielk1 25-Jun-04):           /* We have a match. Do not delete the master journal file. */
1.138        (danielk1 25-Jun-04):           goto delmaster_out;
1.110        (danielk1 03-Jun-04):         }
1.110        (danielk1 03-Jun-04):       }
1.126        (danielk1 14-Jun-04):       zJournal += (strlen(zJournal)+1);
1.110        (danielk1 03-Jun-04):     }
1.110        (danielk1 03-Jun-04):   }
1.110        (danielk1 03-Jun-04):   
1.302        (danielk1 27-Mar-07):   rc = sqlite3OsDelete(zMaster);
1.110        (danielk1 03-Jun-04): 
1.110        (danielk1 03-Jun-04): delmaster_out:
1.110        (danielk1 03-Jun-04):   if( zMasterJournal ){
1.110        (danielk1 03-Jun-04):     sqliteFree(zMasterJournal);
1.110        (danielk1 03-Jun-04):   }  
1.110        (danielk1 03-Jun-04):   if( master_open ){
1.222        (drh      30-Nov-05):     sqlite3OsClose(&master);
1.110        (danielk1 03-Jun-04):   }
1.110        (danielk1 03-Jun-04):   return rc;
1.110        (danielk1 03-Jun-04): }
1.110        (danielk1 03-Jun-04): 
1.115        (drh      09-Jun-04): 
1.323        (danielk1 05-Apr-07): static void pager_truncate_cache(Pager *pPager);
1.323        (danielk1 05-Apr-07): 
1.115        (drh      09-Jun-04): /*
1.158        (drh      18-Aug-04): ** Truncate the main file of the given pager to the number of pages
1.323        (danielk1 05-Apr-07): ** indicated. Also truncate the cached representation of the file.
1.158        (drh      18-Aug-04): */
1.158        (drh      18-Aug-04): static int pager_truncate(Pager *pPager, int nPage){
1.323        (danielk1 05-Apr-07):   int rc = SQLITE_OK;
1.323        (danielk1 05-Apr-07):   if( pPager->state>=PAGER_EXCLUSIVE ){
1.323        (danielk1 05-Apr-07):     rc = sqlite3OsTruncate(pPager->fd, pPager->pageSize*(i64)nPage);
1.323        (danielk1 05-Apr-07):   }
1.323        (danielk1 05-Apr-07):   if( rc==SQLITE_OK ){
1.323        (danielk1 05-Apr-07):     pPager->dbSize = nPage;
1.323        (danielk1 05-Apr-07):     pager_truncate_cache(pPager);
1.323        (danielk1 05-Apr-07):   }
1.323        (danielk1 05-Apr-07):   return rc;
1.158        (drh      18-Aug-04): }
1.158        (drh      18-Aug-04): 
1.158        (drh      18-Aug-04): /*
1.332        (drh      01-May-07): ** Set the sectorSize for the given pager.
1.332        (drh      01-May-07): **
1.332        (drh      01-May-07): ** The sector size is the larger of the sector size reported
1.332        (drh      01-May-07): ** by sqlite3OsSectorSize() and the pageSize.
1.332        (drh      01-May-07): */
1.332        (drh      01-May-07): static void setSectorSize(Pager *pPager){
1.332        (drh      01-May-07):   pPager->sectorSize = sqlite3OsSectorSize(pPager->fd);
1.332        (drh      01-May-07):   if( pPager->sectorSize<pPager->pageSize ){
1.332        (drh      01-May-07):     pPager->sectorSize = pPager->pageSize;
1.332        (drh      01-May-07):   }
1.332        (drh      01-May-07): }
1.332        (drh      01-May-07): 
1.332        (drh      01-May-07): /*
1.1          (drh      11-Apr-01): ** Playback the journal and thus restore the database file to
1.1          (drh      11-Apr-01): ** the state it was in before we started making changes.  
1.1          (drh      11-Apr-01): **
1.94         (drh      08-Feb-04): ** The journal file format is as follows: 
1.94         (drh      08-Feb-04): **
1.116        (drh      09-Jun-04): **  (1)  8 byte prefix.  A copy of aJournalMagic[].
1.116        (drh      09-Jun-04): **  (2)  4 byte big-endian integer which is the number of valid page records
1.94         (drh      08-Feb-04): **       in the journal.  If this value is 0xffffffff, then compute the
1.116        (drh      09-Jun-04): **       number of page records from the journal size.
1.116        (drh      09-Jun-04): **  (3)  4 byte big-endian integer which is the initial value for the 
1.116        (drh      09-Jun-04): **       sanity checksum.
1.116        (drh      09-Jun-04): **  (4)  4 byte integer which is the number of pages to truncate the
1.94         (drh      08-Feb-04): **       database to during a rollback.
1.116        (drh      09-Jun-04): **  (5)  4 byte integer which is the number of bytes in the master journal
1.116        (drh      09-Jun-04): **       name.  The value may be zero (indicate that there is no master
1.116        (drh      09-Jun-04): **       journal.)
1.116        (drh      09-Jun-04): **  (6)  N bytes of the master journal name.  The name will be nul-terminated
1.116        (drh      09-Jun-04): **       and might be shorter than the value read from (5).  If the first byte
1.116        (drh      09-Jun-04): **       of the name is \000 then there is no master journal.  The master
1.116        (drh      09-Jun-04): **       journal name is stored in UTF-8.
1.116        (drh      09-Jun-04): **  (7)  Zero or more pages instances, each as follows:
1.94         (drh      08-Feb-04): **        +  4 byte page number.
1.116        (drh      09-Jun-04): **        +  pPager->pageSize bytes of data.
1.116        (drh      09-Jun-04): **        +  4 byte checksum
1.94         (drh      08-Feb-04): **
1.116        (drh      09-Jun-04): ** When we speak of the journal header, we mean the first 6 items above.
1.116        (drh      09-Jun-04): ** Each entry in the journal is an instance of the 7th item.
1.94         (drh      08-Feb-04): **
1.94         (drh      08-Feb-04): ** Call the value from the second bullet "nRec".  nRec is the number of
1.94         (drh      08-Feb-04): ** valid page entries in the journal.  In most cases, you can compute the
1.94         (drh      08-Feb-04): ** value of nRec from the size of the journal file.  But if a power
1.94         (drh      08-Feb-04): ** failure occurred while the journal was being written, it could be the
1.94         (drh      08-Feb-04): ** case that the size of the journal file had already been increased but
1.94         (drh      08-Feb-04): ** the extra entries had not yet made it safely to disk.  In such a case,
1.94         (drh      08-Feb-04): ** the value of nRec computed from the file size would be too large.  For
1.94         (drh      08-Feb-04): ** that reason, we always use the nRec value in the header.
1.94         (drh      08-Feb-04): **
1.94         (drh      08-Feb-04): ** If the nRec value is 0xffffffff it means that nRec should be computed
1.94         (drh      08-Feb-04): ** from the file size.  This value is used when the user selects the
1.94         (drh      08-Feb-04): ** no-sync option for the journal.  A power failure could lead to corruption
1.94         (drh      08-Feb-04): ** in this case.  But for things like temporary table (which will be
1.94         (drh      08-Feb-04): ** deleted when the power is restored) we don't care.  
1.94         (drh      08-Feb-04): **
1.3          (drh      15-Apr-01): ** If the file opened as the journal file is not a well-formed
1.136        (danielk1 23-Jun-04): ** journal file then all pages up to the first corrupted page are rolled
1.136        (danielk1 23-Jun-04): ** back (or no pages if the journal header is corrupted). The journal file
1.136        (danielk1 23-Jun-04): ** is then deleted and SQLITE_OK returned, just as if no corruption had
1.136        (danielk1 23-Jun-04): ** been encountered.
1.136        (danielk1 23-Jun-04): **
1.136        (danielk1 23-Jun-04): ** If an I/O or malloc() error occurs, the journal-file is not deleted
1.136        (danielk1 23-Jun-04): ** and an error code is returned.
1.3          (drh      15-Apr-01): */
1.293        (danielk1 23-Mar-07): static int pager_playback(Pager *pPager, int isHot){
1.165        (drh      01-Oct-04):   i64 szJ;                 /* Size of the journal file in bytes */
1.146        (danielk1 28-Jun-04):   u32 nRec;                /* Number of Records in the journal */
1.3          (drh      15-Apr-01):   int i;                   /* Loop counter */
1.3          (drh      15-Apr-01):   Pgno mxPg = 0;           /* Size of the original file in pages */
1.116        (drh      09-Jun-04):   int rc;                  /* Result code of a subroutine */
1.110        (danielk1 03-Jun-04):   char *zMaster = 0;       /* Name of master journal file if any */
1.1          (drh      11-Apr-01): 
1.31         (drh      22-Nov-01):   /* Figure out how many records are in the journal.  Abort early if
1.31         (drh      22-Nov-01):   ** the journal is empty.
1.31         (drh      22-Nov-01):   */
1.31         (drh      22-Nov-01):   assert( pPager->journalOpen );
1.222        (drh      30-Nov-05):   rc = sqlite3OsFileSize(pPager->jfd, &szJ);
1.295        (danielk1 26-Mar-07):   if( rc!=SQLITE_OK || szJ==0 ){
1.31         (drh      22-Nov-01):     goto end_playback;
1.31         (drh      22-Nov-01):   }
1.93         (drh      08-Feb-04): 
1.138        (danielk1 25-Jun-04):   /* Read the master journal name from the journal, if it is present.
1.138        (danielk1 25-Jun-04):   ** If a master journal file name is specified, but the file is not
1.138        (danielk1 25-Jun-04):   ** present on disk, then the journal is not hot and does not need to be
1.138        (danielk1 25-Jun-04):   ** played back.
1.138        (danielk1 25-Jun-04):   */
1.221        (drh      29-Nov-05):   rc = readMasterJournal(pPager->jfd, &zMaster);
1.138        (danielk1 25-Jun-04):   assert( rc!=SQLITE_DONE );
1.231        (drh      06-Jan-06):   if( rc!=SQLITE_OK || (zMaster && !sqlite3OsFileExists(zMaster)) ){
1.138        (danielk1 25-Jun-04):     sqliteFree(zMaster);
1.138        (danielk1 25-Jun-04):     zMaster = 0;
1.138        (danielk1 25-Jun-04):     if( rc==SQLITE_DONE ) rc = SQLITE_OK;
1.31         (drh      22-Nov-01):     goto end_playback;
1.31         (drh      22-Nov-01):   }
1.222        (drh      30-Nov-05):   sqlite3OsSeek(pPager->jfd, 0);
1.138        (danielk1 25-Jun-04):   pPager->journalOff = 0;
1.31         (drh      22-Nov-01): 
1.138        (danielk1 25-Jun-04):   /* This loop terminates either when the readJournalHdr() call returns
1.138        (danielk1 25-Jun-04):   ** SQLITE_DONE or an IO error occurs. */
1.138        (danielk1 25-Jun-04):   while( 1 ){
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04):     /* Read the next journal header from the journal file.  If there are
1.138        (danielk1 25-Jun-04):     ** not enough bytes left in the journal file for a complete header, or
1.138        (danielk1 25-Jun-04):     ** it is corrupted, then a process must of failed while writing it.
1.138        (danielk1 25-Jun-04):     ** This indicates nothing more needs to be rolled back.
1.138        (danielk1 25-Jun-04):     */
1.138        (danielk1 25-Jun-04):     rc = readJournalHdr(pPager, szJ, &nRec, &mxPg);
1.138        (danielk1 25-Jun-04):     if( rc!=SQLITE_OK ){ 
1.138        (danielk1 25-Jun-04):       if( rc==SQLITE_DONE ){
1.138        (danielk1 25-Jun-04):         rc = SQLITE_OK;
1.138        (danielk1 25-Jun-04):       }
1.138        (danielk1 25-Jun-04):       goto end_playback;
1.138        (danielk1 25-Jun-04):     }
1.116        (drh      09-Jun-04): 
1.138        (danielk1 25-Jun-04):     /* If nRec is 0xffffffff, then this journal was created by a process
1.138        (danielk1 25-Jun-04):     ** working in no-sync mode. This means that the rest of the journal
1.138        (danielk1 25-Jun-04):     ** file consists of pages, there are no more journal headers. Compute
1.138        (danielk1 25-Jun-04):     ** the value of nRec based on this assumption.
1.138        (danielk1 25-Jun-04):     */
1.138        (danielk1 25-Jun-04):     if( nRec==0xffffffff ){
1.138        (danielk1 25-Jun-04):       assert( pPager->journalOff==JOURNAL_HDR_SZ(pPager) );
1.138        (danielk1 25-Jun-04):       nRec = (szJ - JOURNAL_HDR_SZ(pPager))/JOURNAL_PG_SZ(pPager);
1.138        (danielk1 25-Jun-04):     }
1.116        (drh      09-Jun-04): 
1.293        (danielk1 23-Mar-07):     /* If nRec is 0 and this rollback is of a transaction created by this
1.293        (danielk1 23-Mar-07):     ** process. In this case the rest of the journal file consists of
1.293        (danielk1 23-Mar-07):     ** journalled copies of pages that need to be read back into the cache.
1.293        (danielk1 23-Mar-07):     */
1.293        (danielk1 23-Mar-07):     if( nRec==0 && !isHot ){
1.293        (danielk1 23-Mar-07):       nRec = (szJ - pPager->journalOff) / JOURNAL_PG_SZ(pPager);
1.293        (danielk1 23-Mar-07):     }
1.293        (danielk1 23-Mar-07): 
1.138        (danielk1 25-Jun-04):     /* If this is the first header read from the journal, truncate the
1.138        (danielk1 25-Jun-04):     ** database file back to it's original size.
1.138        (danielk1 25-Jun-04):     */
1.323        (danielk1 05-Apr-07):     if( pPager->journalOff==JOURNAL_HDR_SZ(pPager) ){
1.158        (drh      18-Aug-04):       rc = pager_truncate(pPager, mxPg);
1.138        (danielk1 25-Jun-04):       if( rc!=SQLITE_OK ){
1.138        (danielk1 25-Jun-04):         goto end_playback;
1.138        (danielk1 25-Jun-04):       }
1.93         (drh      08-Feb-04):     }
1.110        (danielk1 03-Jun-04): 
1.138        (danielk1 25-Jun-04):     /* Copy original pages out of the journal and back into the database file.
1.138        (danielk1 25-Jun-04):     */
1.138        (danielk1 25-Jun-04):     for(i=0; i<nRec; i++){
1.221        (drh      29-Nov-05):       rc = pager_playback_one_page(pPager, pPager->jfd, 1);
1.138        (danielk1 25-Jun-04):       if( rc!=SQLITE_OK ){
1.138        (danielk1 25-Jun-04):         if( rc==SQLITE_DONE ){
1.138        (danielk1 25-Jun-04):           rc = SQLITE_OK;
1.138        (danielk1 25-Jun-04):           pPager->journalOff = szJ;
1.138        (danielk1 25-Jun-04):           break;
1.138        (danielk1 25-Jun-04):         }else{
1.138        (danielk1 25-Jun-04):           goto end_playback;
1.138        (danielk1 25-Jun-04):         }
1.73         (drh      11-Feb-03):       }
1.73         (drh      11-Feb-03):     }
1.37         (drh      02-Feb-02):   }
1.260        (drh      24-Feb-06):   /*NOTREACHED*/
1.260        (drh      24-Feb-06):   assert( 0 );
1.76         (drh      13-Feb-03): 
1.76         (drh      13-Feb-03): end_playback:
1.147        (danielk1 28-Jun-04):   if( rc==SQLITE_OK ){
1.307        (drh      30-Mar-07):     rc = pager_end_transaction(pPager);
1.147        (danielk1 28-Jun-04):   }
1.110        (danielk1 03-Jun-04):   if( zMaster ){
1.302        (danielk1 27-Mar-07):     /* If there was a master journal and this routine will return success,
1.186        (danielk1 22-Jan-05):     ** see if it is possible to delete the master journal.
1.110        (danielk1 03-Jun-04):     */
1.110        (danielk1 03-Jun-04):     if( rc==SQLITE_OK ){
1.186        (danielk1 22-Jan-05):       rc = pager_delmaster(zMaster);
1.110        (danielk1 03-Jun-04):     }
1.110        (danielk1 03-Jun-04):     sqliteFree(zMaster);
1.110        (danielk1 03-Jun-04):   }
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04):   /* The Pager.sectorSize variable may have been updated while rolling
1.306        (drh      29-Mar-07):   ** back a journal created by a process with a different sector size
1.138        (danielk1 25-Jun-04):   ** value. Reset it to the correct value for this process.
1.138        (danielk1 25-Jun-04):   */
1.332        (drh      01-May-07):   setSectorSize(pPager);
1.37         (drh      02-Feb-02):   return rc;
1.37         (drh      02-Feb-02): }
1.37         (drh      02-Feb-02): 
1.37         (drh      02-Feb-02): /*
1.107        (drh      12-May-04): ** Playback the statement journal.
1.37         (drh      02-Feb-02): **
1.37         (drh      02-Feb-02): ** This is similar to playing back the transaction journal but with
1.37         (drh      02-Feb-02): ** a few extra twists.
1.37         (drh      02-Feb-02): **
1.38         (drh      02-Feb-02): **    (1)  The number of pages in the database file at the start of
1.107        (drh      12-May-04): **         the statement is stored in pPager->stmtSize, not in the
1.38         (drh      02-Feb-02): **         journal file itself.
1.37         (drh      02-Feb-02): **
1.107        (drh      12-May-04): **    (2)  In addition to playing back the statement journal, also
1.37         (drh      02-Feb-02): **         playback all pages of the transaction journal beginning
1.107        (drh      12-May-04): **         at offset pPager->stmtJSize.
1.37         (drh      02-Feb-02): */
1.102        (drh      26-Apr-04): static int pager_stmt_playback(Pager *pPager){
1.165        (drh      01-Oct-04):   i64 szJ;                 /* Size of the full journal */
1.165        (drh      01-Oct-04):   i64 hdrOff;
1.73         (drh      11-Feb-03):   int nRec;                /* Number of Records */
1.37         (drh      02-Feb-02):   int i;                   /* Loop counter */
1.37         (drh      02-Feb-02):   int rc;
1.37         (drh      02-Feb-02): 
1.138        (danielk1 25-Jun-04):   szJ = pPager->journalOff;
1.138        (danielk1 25-Jun-04): #ifndef NDEBUG 
1.138        (danielk1 25-Jun-04):   {
1.165        (drh      01-Oct-04):     i64 os_szJ;
1.222        (drh      30-Nov-05):     rc = sqlite3OsFileSize(pPager->jfd, &os_szJ);
1.138        (danielk1 25-Jun-04):     if( rc!=SQLITE_OK ) return rc;
1.138        (danielk1 25-Jun-04):     assert( szJ==os_szJ );
1.138        (danielk1 25-Jun-04):   }
1.138        (danielk1 25-Jun-04): #endif
1.138        (danielk1 25-Jun-04): 
1.290        (danielk1 19-Mar-07):   /* Set hdrOff to be the offset just after the end of the last journal
1.290        (danielk1 19-Mar-07):   ** page written before the first journal-header for this statement
1.290        (danielk1 19-Mar-07):   ** transaction was written, or the end of the file if no journal
1.138        (danielk1 25-Jun-04):   ** header was written.
1.138        (danielk1 25-Jun-04):   */
1.138        (danielk1 25-Jun-04):   hdrOff = pPager->stmtHdrOff;
1.138        (danielk1 25-Jun-04):   assert( pPager->fullSync || !hdrOff );
1.138        (danielk1 25-Jun-04):   if( !hdrOff ){
1.138        (danielk1 25-Jun-04):     hdrOff = szJ;
1.138        (danielk1 25-Jun-04):   }
1.138        (danielk1 25-Jun-04):   
1.37         (drh      02-Feb-02):   /* Truncate the database back to its original size.
1.37         (drh      02-Feb-02):   */
1.323        (danielk1 05-Apr-07):   rc = pager_truncate(pPager, pPager->stmtSize);
1.279        (drh      03-Jan-07):   assert( pPager->state>=PAGER_SHARED );
1.3          (drh      15-Apr-01): 
1.107        (drh      12-May-04):   /* Figure out how many records are in the statement journal.
1.37         (drh      02-Feb-02):   */
1.107        (drh      12-May-04):   assert( pPager->stmtInUse && pPager->journalOpen );
1.222        (drh      30-Nov-05):   sqlite3OsSeek(pPager->stfd, 0);
1.107        (drh      12-May-04):   nRec = pPager->stmtNRec;
1.37         (drh      02-Feb-02):   
1.107        (drh      12-May-04):   /* Copy original pages out of the statement journal and back into the
1.116        (drh      09-Jun-04):   ** database file.  Note that the statement journal omits checksums from
1.116        (drh      09-Jun-04):   ** each record since power-failure recovery is not important to statement
1.116        (drh      09-Jun-04):   ** journals.
1.37         (drh      02-Feb-02):   */
1.37         (drh      02-Feb-02):   for(i=nRec-1; i>=0; i--){
1.221        (drh      29-Nov-05):     rc = pager_playback_one_page(pPager, pPager->stfd, 0);
1.73         (drh      11-Feb-03):     assert( rc!=SQLITE_DONE );
1.102        (drh      26-Apr-04):     if( rc!=SQLITE_OK ) goto end_stmt_playback;
1.37         (drh      02-Feb-02):   }
1.1          (drh      11-Apr-01): 
1.138        (danielk1 25-Jun-04):   /* Now roll some pages back from the transaction journal. Pager.stmtJSize
1.138        (danielk1 25-Jun-04):   ** was the size of the journal file when this statement was started, so
1.138        (danielk1 25-Jun-04):   ** everything after that needs to be rolled back, either into the
1.138        (danielk1 25-Jun-04):   ** database, the memory cache, or both.
1.138        (danielk1 25-Jun-04):   **
1.138        (danielk1 25-Jun-04):   ** If it is not zero, then Pager.stmtHdrOff is the offset to the start
1.138        (danielk1 25-Jun-04):   ** of the first journal header written during this statement transaction.
1.37         (drh      02-Feb-02):   */
1.222        (drh      30-Nov-05):   rc = sqlite3OsSeek(pPager->jfd, pPager->stmtJSize);
1.37         (drh      02-Feb-02):   if( rc!=SQLITE_OK ){
1.102        (drh      26-Apr-04):     goto end_stmt_playback;
1.37         (drh      02-Feb-02):   }
1.138        (danielk1 25-Jun-04):   pPager->journalOff = pPager->stmtJSize;
1.143        (danielk1 26-Jun-04):   pPager->cksumInit = pPager->stmtCksum;
1.290        (danielk1 19-Mar-07):   while( pPager->journalOff < hdrOff ){
1.221        (drh      29-Nov-05):     rc = pager_playback_one_page(pPager, pPager->jfd, 1);
1.138        (danielk1 25-Jun-04):     assert( rc!=SQLITE_DONE );
1.138        (danielk1 25-Jun-04):     if( rc!=SQLITE_OK ) goto end_stmt_playback;
1.37         (drh      02-Feb-02):   }
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04):   while( pPager->journalOff < szJ ){
1.255        (danielk1 24-Jan-06):     u32 nJRec;         /* Number of Journal Records */
1.138        (danielk1 25-Jun-04):     u32 dummy;
1.255        (danielk1 24-Jan-06):     rc = readJournalHdr(pPager, szJ, &nJRec, &dummy);
1.73         (drh      11-Feb-03):     if( rc!=SQLITE_OK ){
1.73         (drh      11-Feb-03):       assert( rc!=SQLITE_DONE );
1.102        (drh      26-Apr-04):       goto end_stmt_playback;
1.73         (drh      11-Feb-03):     }
1.255        (danielk1 24-Jan-06):     if( nJRec==0 ){
1.255        (danielk1 24-Jan-06):       nJRec = (szJ - pPager->journalOff) / (pPager->pageSize+8);
1.143        (danielk1 26-Jun-04):     }
1.255        (danielk1 24-Jan-06):     for(i=nJRec-1; i>=0 && pPager->journalOff < szJ; i--){
1.221        (drh      29-Nov-05):       rc = pager_playback_one_page(pPager, pPager->jfd, 1);
1.138        (danielk1 25-Jun-04):       assert( rc!=SQLITE_DONE );
1.138        (danielk1 25-Jun-04):       if( rc!=SQLITE_OK ) goto end_stmt_playback;
1.138        (danielk1 25-Jun-04):     }
1.1          (drh      11-Apr-01):   }
1.138        (danielk1 25-Jun-04): 
1.138        (danielk1 25-Jun-04):   pPager->journalOff = szJ;
1.37         (drh      02-Feb-02):   
1.102        (drh      26-Apr-04): end_stmt_playback:
1.252        (danielk1 23-Jan-06):   if( rc==SQLITE_OK) {
1.143        (danielk1 26-Jun-04):     pPager->journalOff = szJ;
1.143        (danielk1 26-Jun-04):     /* pager_reload_cache(pPager); */
1.1          (drh      11-Apr-01):   }
1.3          (drh      15-Apr-01):   return rc;
1.1          (drh      11-Apr-01): }
1.1          (drh      11-Apr-01): 
1.1          (drh      11-Apr-01): /*
1.18         (drh      14-Sep-01): ** Change the maximum number of in-memory pages that are allowed.
1.18         (drh      14-Sep-01): */
1.292        (danielk1 19-Mar-07): void sqlite3PagerSetCachesize(Pager *pPager, int mxPage){
1.18         (drh      14-Sep-01):   if( mxPage>10 ){
1.18         (drh      14-Sep-01):     pPager->mxPage = mxPage;
1.137        (danielk1 23-Jun-04):   }else{
1.137        (danielk1 23-Jun-04):     pPager->mxPage = 10;
1.18         (drh      14-Sep-01):   }
1.75         (drh      12-Feb-03): }
1.75         (drh      12-Feb-03): 
1.75         (drh      12-Feb-03): /*
1.75         (drh      12-Feb-03): ** Adjust the robustness of the database to damage due to OS crashes
1.75         (drh      12-Feb-03): ** or power failures by changing the number of syncs()s when writing
1.75         (drh      12-Feb-03): ** the rollback journal.  There are three levels:
1.75         (drh      12-Feb-03): **
1.222        (drh      30-Nov-05): **    OFF       sqlite3OsSync() is never called.  This is the default
1.75         (drh      12-Feb-03): **              for temporary and transient files.
1.75         (drh      12-Feb-03): **
1.75         (drh      12-Feb-03): **    NORMAL    The journal is synced once before writes begin on the
1.75         (drh      12-Feb-03): **              database.  This is normally adequate protection, but
1.75         (drh      12-Feb-03): **              it is theoretically possible, though very unlikely,
1.75         (drh      12-Feb-03): **              that an inopertune power failure could leave the journal
1.75         (drh      12-Feb-03): **              in a state which would cause damage to the database
1.75         (drh      12-Feb-03): **              when it is rolled back.
1.75         (drh      12-Feb-03): **
1.75         (drh      12-Feb-03): **    FULL      The journal is synced twice before writes begin on the
1.94         (drh      08-Feb-04): **              database (with some additional information - the nRec field
1.94         (drh      08-Feb-04): **              of the journal header - being written in between the two
1.94         (drh      08-Feb-04): **              syncs).  If we assume that writing a
1.75         (drh      12-Feb-03): **              single disk sector is atomic, then this mode provides
1.75         (drh      12-Feb-03): **              assurance that the journal will not be corrupted to the
1.75         (drh      12-Feb-03): **              point of causing damage to the database during rollback.
1.75         (drh      12-Feb-03): **
1.75         (drh      12-Feb-03): ** Numeric values associated with these states are OFF==1, NORMAL=2,
1.75         (drh      12-Feb-03): ** and FULL=3.
1.75         (drh      12-Feb-03): */
1.185        (danielk1 21-Jan-05): #ifndef SQLITE_OMIT_PAGER_PRAGMAS
1.292        (danielk1 19-Mar-07): void sqlite3PagerSetSafetyLevel(Pager *pPager, int level, int full_fsync){
1.75         (drh      12-Feb-03):   pPager->noSync =  level==1 || pPager->tempFile;
1.75         (drh      12-Feb-03):   pPager->fullSync = level==3 && !pPager->tempFile;
1.258        (drh      11-Feb-06):   pPager->full_fsync = full_fsync;
1.109        (danielk1 31-May-04):   if( pPager->noSync ) pPager->needSync = 0;
1.18         (drh      14-Sep-01): }
1.185        (danielk1 21-Jan-05): #endif
1.18         (drh      14-Sep-01): 
1.18         (drh      14-Sep-01): /*
1.207        (drh      07-Jun-05): ** The following global variable is incremented whenever the library
1.207        (drh      07-Jun-05): ** attempts to open a temporary file.  This information is used for
1.207        (drh      07-Jun-05): ** testing and analysis only.  
1.207        (drh      07-Jun-05): */
1.271        (drh      08-Aug-06): #ifdef SQLITE_TEST
1.207        (drh      07-Jun-05): int sqlite3_opentemp_count = 0;
1.271        (drh      08-Aug-06): #endif
1.207        (drh      07-Jun-05): 
1.207        (drh      07-Jun-05): /*
1.287        (drh      15-Mar-07): ** Open a temporary file. 
1.287        (drh      15-Mar-07): **
1.287        (drh      15-Mar-07): ** Write the file descriptor into *fd.  Return SQLITE_OK on success or some
1.37         (drh      02-Feb-02): ** other error code if we fail.
1.37         (drh      02-Feb-02): **
1.37         (drh      02-Feb-02): ** The OS will automatically delete the temporary file when it is
1.37         (drh      02-Feb-02): ** closed.
1.37         (drh      02-Feb-02): */
1.292        (danielk1 19-Mar-07): static int sqlite3PagerOpentemp(OsFile **pFd){
1.37         (drh      02-Feb-02):   int cnt = 8;
1.37         (drh      02-Feb-02):   int rc;
1.287        (drh      15-Mar-07):   char zFile[SQLITE_TEMPNAME_SIZE];
1.287        (drh      15-Mar-07): 
1.271        (drh      08-Aug-06): #ifdef SQLITE_TEST
1.207        (drh      07-Jun-05):   sqlite3_opentemp_count++;  /* Used for testing and analysis only */
1.271        (drh      08-Aug-06): #endif
1.37         (drh      02-Feb-02):   do{
1.37         (drh      02-Feb-02):     cnt--;
1.231        (drh      06-Jan-06):     sqlite3OsTempFileName(zFile);
1.231        (drh      06-Jan-06):     rc = sqlite3OsOpenExclusive(zFile, pFd, 1);
1.320        (danielk1 05-Apr-07):     assert( rc!=SQLITE_OK || *pFd );
1.149        (danielk1 30-Jun-04):   }while( cnt>0 && rc!=SQLITE_OK && rc!=SQLITE_NOMEM );
1.37         (drh      02-Feb-02):   return rc;
1.37         (drh      02-Feb-02): }
1.37         (drh      02-Feb-02): 
1.37         (drh      02-Feb-02): /*
1.1          (drh      11-Apr-01): ** Create a new page cache and put a pointer to the page cache in *ppPager.
1.14         (drh      13-Sep-01): ** The file to be cached need not exist.  The file is not locked until
1.292        (danielk1 19-Mar-07): ** the first call to sqlite3PagerGet() and is only held open until the
1.292        (danielk1 19-Mar-07): ** last page is released using sqlite3PagerUnref().
1.25         (drh      06-Oct-01): **
1.34         (drh      15-Dec-01): ** If zFilename is NULL then a randomly-named temporary file is created
1.34         (drh      15-Dec-01): ** and used as the file to be cached.  The file will be deleted
1.34         (drh      15-Dec-01): ** automatically when it is closed.
1.152        (drh      22-Jul-04): **
1.152        (drh      22-Jul-04): ** If zFilename is ":memory:" then all information is held in cache.
1.152        (drh      22-Jul-04): ** It is never written to disk.  This can be used to implement an
1.152        (drh      22-Jul-04): ** in-memory database.
1.1          (drh      11-Apr-01): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerOpen(
1.5          (drh      28-Apr-01):   Pager **ppPager,         /* Return the Pager structure here */
1.5          (drh      28-Apr-01):   const char *zFilename,   /* Name of the database file to open */
1.60         (drh      02-Dec-02):   int nExtra,              /* Extra bytes append to each in-memory page */
1.188        (drh      06-Feb-05):   int flags                /* flags controlling this file */
1.5          (drh      28-Apr-01): ){
1.229        (danielk1 30-Dec-05):   Pager *pPager = 0;
1.130        (danielk1 16-Jun-04):   char *zFullPathname = 0;
1.248        (drh      20-Jan-06):   int nameLen;  /* Compiler is wrong. This is always initialized before use */
1.312        (danielk1 31-Mar-07):   OsFile *fd = 0;
1.131        (danielk1 16-Jun-04):   int rc = SQLITE_OK;
1.131        (danielk1 16-Jun-04):   int i;
1.130        (danielk1 16-Jun-04):   int tempFile = 0;
1.107        (drh      12-May-04):   int memDb = 0;
1.14         (drh      13-Sep-01):   int readOnly = 0;
1.188        (drh      06-Feb-05):   int useJournal = (flags & PAGER_OMIT_JOURNAL)==0;
1.188        (drh      06-Feb-05):   int noReadlock = (flags & PAGER_NO_READLOCK)!=0;
1.22         (drh      19-Sep-01):   char zTemp[SQLITE_TEMPNAME_SIZE];
1.236        (drh      11-Jan-06): #ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
1.242        (danielk1 18-Jan-06):   /* A malloc() cannot fail in sqlite3ThreadData() as one or more calls to 
1.242        (danielk1 18-Jan-06):   ** malloc() must have already been made by this thread before it gets
1.242        (danielk1 18-Jan-06):   ** to this point. This means the ThreadData must have been allocated already
1.242        (danielk1 18-Jan-06):   ** so that ThreadData.nAlloc can be set. It would be nice to assert
1.242        (danielk1 18-Jan-06):   ** that ThreadData.nAlloc is non-zero, but alas this breaks test cases 
1.242        (danielk1 18-Jan-06):   ** written to invoke the pager directly.
1.242        (danielk1 18-Jan-06):   */
1.241        (danielk1 16-Jan-06):   ThreadData *pTsd = sqlite3ThreadData();
1.242        (danielk1 18-Jan-06):   assert( pTsd );
1.233        (danielk1 09-Jan-06): #endif
1.1          (drh      11-Apr-01): 
1.312        (danielk1 31-Mar-07):   /* We used to test if malloc() had already failed before proceeding. 
1.312        (danielk1 31-Mar-07):   ** But the way this function is used in SQLite means that can never
1.312        (danielk1 31-Mar-07):   ** happen. Furthermore, if the malloc-failed flag is already set, 
1.312        (danielk1 31-Mar-07):   ** either the call to sqliteStrDup() or sqliteMalloc() below will
1.312        (danielk1 31-Mar-07):   ** fail shortly and SQLITE_NOMEM returned anyway.
1.229        (danielk1 30-Dec-05):   */
1.3          (drh      15-Apr-01):   *ppPager = 0;
1.229        (danielk1 30-Dec-05): 
1.229        (danielk1 30-Dec-05):   /* Open the pager file and set zFullPathname to point at malloc()ed 
1.229        (danielk1 30-Dec-05):   ** memory containing the complete filename (i.e. including the directory).
1.229        (danielk1 30-Dec-05):   */
1.88         (drh      26-Aug-03):   if( zFilename && zFilename[0] ){
1.169        (drh      31-Oct-04): #ifndef SQLITE_OMIT_MEMORYDB
1.107        (drh      12-May-04):     if( strcmp(zFilename,":memory:")==0 ){
1.107        (drh      12-May-04):       memDb = 1;
1.133        (drh      21-Jun-04):       zFullPathname = sqliteStrDup("");
1.169        (drh      31-Oct-04):     }else
1.169        (drh      31-Oct-04): #endif
1.169        (drh      31-Oct-04):     {
1.231        (drh      06-Jan-06):       zFullPathname = sqlite3OsFullPathname(zFilename);
1.130        (danielk1 16-Jun-04):       if( zFullPathname ){
1.231        (drh      06-Jan-06):         rc = sqlite3OsOpenReadWrite(zFullPathname, &fd, &readOnly);
1.320        (danielk1 05-Apr-07):         assert( rc!=SQLITE_OK || fd );
1.130        (danielk1 16-Jun-04):       }
1.107        (drh      12-May-04):     }
1.14         (drh      13-Sep-01):   }else{
1.292        (danielk1 19-Mar-07):     rc = sqlite3PagerOpentemp(&fd);
1.287        (drh      15-Mar-07):     sqlite3OsTempFileName(zTemp);
1.14         (drh      13-Sep-01):     zFilename = zTemp;
1.231        (drh      06-Jan-06):     zFullPathname = sqlite3OsFullPathname(zFilename);
1.130        (danielk1 16-Jun-04):     if( rc==SQLITE_OK ){
1.130        (danielk1 16-Jun-04):       tempFile = 1;
1.130        (danielk1 16-Jun-04):     }
1.14         (drh      13-Sep-01):   }
1.229        (danielk1 30-Dec-05): 
1.229        (danielk1 30-Dec-05):   /* Allocate the Pager structure. As part of the same allocation, allocate
1.229        (danielk1 30-Dec-05):   ** space for the full paths of the file, directory and journal 
1.229        (danielk1 30-Dec-05):   ** (Pager.zFilename, Pager.zDirectory and Pager.zJournal).
1.229        (danielk1 30-Dec-05):   */
1.229        (danielk1 30-Dec-05):   if( zFullPathname ){
1.229        (danielk1 30-Dec-05):     nameLen = strlen(zFullPathname);
1.229        (danielk1 30-Dec-05):     pPager = sqliteMalloc( sizeof(*pPager) + nameLen*3 + 30 );
1.286        (danielk1 06-Mar-07):     if( pPager && rc==SQLITE_OK ){
1.286        (danielk1 06-Mar-07):       pPager->pTmpSpace = (char *)sqliteMallocRaw(SQLITE_DEFAULT_PAGE_SIZE);
1.286        (danielk1 06-Mar-07):     }
1.61         (drh      07-Dec-02):   }
1.229        (danielk1 30-Dec-05): 
1.286        (danielk1 06-Mar-07): 
1.229        (danielk1 30-Dec-05):   /* If an error occured in either of the blocks above, free the memory 
1.229        (danielk1 30-Dec-05):   ** pointed to by zFullPathname, free the Pager structure and close the 
1.229        (danielk1 30-Dec-05):   ** file. Since the pager is not allocated there is no need to set 
1.229        (danielk1 30-Dec-05):   ** any Pager.errMask variables.
1.229        (danielk1 30-Dec-05):   */
1.286        (danielk1 06-Mar-07):   if( !pPager || !zFullPathname || !pPager->pTmpSpace || rc!=SQLITE_OK ){
1.222        (drh      30-Nov-05):     sqlite3OsClose(&fd);
1.133        (drh      21-Jun-04):     sqliteFree(zFullPathname);
1.229        (danielk1 30-Dec-05):     sqliteFree(pPager);
1.229        (danielk1 30-Dec-05):     return ((rc==SQLITE_OK)?SQLITE_NOMEM:rc);
1.3          (drh      15-Apr-01):   }
1.229        (danielk1 30-Dec-05): 
1.300        (drh      26-Mar-07):   PAGERTRACE3("OPEN %d %s\n", FILEHANDLEID(fd), zFullPathname);
1.283        (drh      28-Feb-07):   IOTRACE(("OPEN %p %s\n", pPager, zFullPathname))
1.1          (drh      11-Apr-01):   pPager->zFilename = (char*)&pPager[1];
1.87         (drh      27-Jul-03):   pPager->zDirectory = &pPager->zFilename[nameLen+1];
1.87         (drh      27-Jul-03):   pPager->zJournal = &pPager->zDirectory[nameLen+1];
1.335        (drh      04-May-07):   memcpy(pPager->zFilename, zFullPathname, nameLen+1);
1.335        (drh      04-May-07):   memcpy(pPager->zDirectory, zFullPathname, nameLen+1);
1.229        (danielk1 30-Dec-05): 
1.87         (drh      27-Jul-03):   for(i=nameLen; i>0 && pPager->zDirectory[i-1]!='/'; i--){}
1.87         (drh      27-Jul-03):   if( i>0 ) pPager->zDirectory[i-1] = 0;
1.335        (drh      04-May-07):   memcpy(pPager->zJournal, zFullPathname,nameLen);
1.61         (drh      07-Dec-02):   sqliteFree(zFullPathname);
1.335        (drh      04-May-07):   memcpy(&pPager->zJournal[nameLen], "-journal",sizeof("-journal"));
1.221        (drh      29-Nov-05):   pPager->fd = fd;
1.237        (drh      15-Jan-06):   /* pPager->journalOpen = 0; */
1.107        (drh      12-May-04):   pPager->useJournal = useJournal && !memDb;
1.188        (drh      06-Feb-05):   pPager->noReadlock = noReadlock && readOnly;
1.237        (drh      15-Jan-06):   /* pPager->stmtOpen = 0; */
1.237        (drh      15-Jan-06):   /* pPager->stmtInUse = 0; */
1.237        (drh      15-Jan-06):   /* pPager->nRef = 0; */
1.107        (drh      12-May-04):   pPager->dbSize = memDb-1;
1.152        (drh      22-Jul-04):   pPager->pageSize = SQLITE_DEFAULT_PAGE_SIZE;
1.237        (drh      15-Jan-06):   /* pPager->stmtSize = 0; */
1.237        (drh      15-Jan-06):   /* pPager->stmtJSize = 0; */
1.237        (drh      15-Jan-06):   /* pPager->nPage = 0; */
1.152        (drh      22-Jul-04):   pPager->mxPage = 100;
1.337        (drh      08-May-07):   pPager->mxPgno = SQLITE_MAX_PAGE_COUNT;
1.237        (drh      15-Jan-06):   assert( PAGER_UNLOCK==0 );
1.237        (drh      15-Jan-06):   /* pPager->state = PAGER_UNLOCK; */
1.237        (drh      15-Jan-06):   /* pPager->errMask = 0; */
1.14         (drh      13-Sep-01):   pPager->tempFile = tempFile;
1.309        (drh      30-Mar-07):   assert( tempFile==PAGER_LOCKINGMODE_NORMAL 
1.309        (drh      30-Mar-07):           || tempFile==PAGER_LOCKINGMODE_EXCLUSIVE );
1.309        (drh      30-Mar-07):   assert( PAGER_LOCKINGMODE_EXCLUSIVE==1 );
1.309        (drh      30-Mar-07):   pPager->exclusiveMode = tempFile; 
1.107        (drh      12-May-04):   pPager->memDb = memDb;
1.14         (drh      13-Sep-01):   pPager->readOnly = readOnly;
1.237        (drh      15-Jan-06):   /* pPager->needSync = 0; */
1.60         (drh      02-Dec-02):   pPager->noSync = pPager->tempFile || !useJournal;
1.143        (danielk1 26-Jun-04):   pPager->fullSync = (pPager->noSync?0:1);
1.237        (drh      15-Jan-06):   /* pPager->pFirst = 0; */
1.237        (drh      15-Jan-06):   /* pPager->pFirstSynced = 0; */
1.237        (drh      15-Jan-06):   /* pPager->pLast = 0; */
1.168        (drh      22-Oct-04):   pPager->nExtra = FORCE_ALIGNMENT(nExtra);
1.289        (danielk1 19-Mar-07):   assert(fd||memDb);
1.289        (danielk1 19-Mar-07):   if( !memDb ){
1.332        (drh      01-May-07):     setSectorSize(pPager);
1.289        (danielk1 19-Mar-07):   }
1.237        (drh      15-Jan-06):   /* pPager->pBusyHandler = 0; */
1.237        (drh      15-Jan-06):   /* memset(pPager->aHash, 0, sizeof(pPager->aHash)); */
1.1          (drh      11-Apr-01):   *ppPager = pPager;
1.236        (drh      11-Jan-06): #ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
1.241        (danielk1 16-Jan-06):   pPager->pNext = pTsd->pPager;
1.241        (danielk1 16-Jan-06):   pTsd->pPager = pPager;
1.233        (danielk1 09-Jan-06): #endif
1.1          (drh      11-Apr-01):   return SQLITE_OK;
1.1          (drh      11-Apr-01): }
1.1          (drh      11-Apr-01): 
1.1          (drh      11-Apr-01): /*
1.152        (drh      22-Jul-04): ** Set the busy handler function.
1.152        (drh      22-Jul-04): */
1.292        (danielk1 19-Mar-07): void sqlite3PagerSetBusyhandler(Pager *pPager, BusyHandler *pBusyHandler){
1.152        (drh      22-Jul-04):   pPager->pBusyHandler = pBusyHandler;
1.152        (drh      22-Jul-04): }
1.152        (drh      22-Jul-04): 
1.152        (drh      22-Jul-04): /*
1.7          (drh      24-May-01): ** Set the destructor for this pager.  If not NULL, the destructor is called
1.14         (drh      13-Sep-01): ** when the reference count on each page reaches zero.  The destructor can
1.14         (drh      13-Sep-01): ** be used to clean up information in the extra segment appended to each page.
1.7          (drh      24-May-01): **
1.292        (danielk1 19-Mar-07): ** The destructor is not called as a result sqlite3PagerClose().  
1.292        (danielk1 19-Mar-07): ** Destructors are only called by sqlite3PagerUnref().
1.7          (drh      24-May-01): */
1.292        (danielk1 19-Mar-07): void sqlite3PagerSetDestructor(Pager *pPager, void (*xDesc)(DbPage*,int)){
1.7          (drh      24-May-01):   pPager->xDestructor = xDesc;
1.7          (drh      24-May-01): }
1.7          (drh      24-May-01): 
1.7          (drh      24-May-01): /*
1.115        (drh      09-Jun-04): ** Set the reinitializer for this pager.  If not NULL, the reinitializer
1.115        (drh      09-Jun-04): ** is called when the content of a page in cache is restored to its original
1.115        (drh      09-Jun-04): ** value as a result of a rollback.  The callback gives higher-level code
1.115        (drh      09-Jun-04): ** an opportunity to restore the EXTRA section to agree with the restored
1.115        (drh      09-Jun-04): ** page data.
1.115        (drh      09-Jun-04): */
1.292        (danielk1 19-Mar-07): void sqlite3PagerSetReiniter(Pager *pPager, void (*xReinit)(DbPage*,int)){
1.115        (drh      09-Jun-04):   pPager->xReiniter = xReinit;
1.115        (drh      09-Jun-04): }
1.115        (drh      09-Jun-04): 
1.115        (drh      09-Jun-04): /*
1.203        (drh      20-May-05): ** Set the page size.  Return the new size.  If the suggest new page
1.203        (drh      20-May-05): ** size is inappropriate, then an alternative page size is selected
1.203        (drh      20-May-05): ** and returned.
1.152        (drh      22-Jul-04): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerSetPagesize(Pager *pPager, int pageSize){
1.152        (drh      22-Jul-04):   assert( pageSize>=512 && pageSize<=SQLITE_MAX_PAGE_SIZE );
1.299        (danielk1 26-Mar-07):   if( !pPager->memDb && pPager->nRef==0 ){
1.299        (danielk1 26-Mar-07):     pager_reset(pPager);
1.203        (drh      20-May-05):     pPager->pageSize = pageSize;
1.301        (drh      27-Mar-07):     pPager->pTmpSpace = sqlite3ReallocOrFree(pPager->pTmpSpace, pageSize);
1.203        (drh      20-May-05):   }
1.203        (drh      20-May-05):   return pPager->pageSize;
1.152        (drh      22-Jul-04): }
1.152        (drh      22-Jul-04): 
1.152        (drh      22-Jul-04): /*
1.337        (drh      08-May-07): ** Attempt to set the maximum database page count if mxPage is positive. 
1.337        (drh      08-May-07): ** Make no changes if mxPage is zero or negative.  And never reduce the
1.337        (drh      08-May-07): ** maximum page count below the current size of the database.
1.337        (drh      08-May-07): **
1.337        (drh      08-May-07): ** Regardless of mxPage, return the current maximum page count.
1.337        (drh      08-May-07): */
1.337        (drh      08-May-07): int sqlite3PagerMaxPageCount(Pager *pPager, int mxPage){
1.337        (drh      08-May-07):   if( mxPage>0 ){
1.337        (drh      08-May-07):     pPager->mxPgno = mxPage;
1.337        (drh      08-May-07):   }
1.337        (drh      08-May-07):   sqlite3PagerPagecount(pPager);
1.337        (drh      08-May-07):   return pPager->mxPgno;
1.337        (drh      08-May-07): }
1.337        (drh      08-May-07): 
1.337        (drh      08-May-07): /*
1.216        (drh      04-Nov-05): ** The following set of routines are used to disable the simulated
1.216        (drh      04-Nov-05): ** I/O error mechanism.  These routines are used to avoid simulated
1.216        (drh      04-Nov-05): ** errors in places where we do not care about errors.
1.216        (drh      04-Nov-05): **
1.216        (drh      04-Nov-05): ** Unless -DSQLITE_TEST=1 is used, these routines are all no-ops
1.216        (drh      04-Nov-05): ** and generate no code.
1.216        (drh      04-Nov-05): */
1.216        (drh      04-Nov-05): #ifdef SQLITE_TEST
1.216        (drh      04-Nov-05): extern int sqlite3_io_error_pending;
1.216        (drh      04-Nov-05): extern int sqlite3_io_error_hit;
1.216        (drh      04-Nov-05): static int saved_cnt;
1.216        (drh      04-Nov-05): void disable_simulated_io_errors(void){
1.216        (drh      04-Nov-05):   saved_cnt = sqlite3_io_error_pending;
1.216        (drh      04-Nov-05):   sqlite3_io_error_pending = -1;
1.216        (drh      04-Nov-05): }
1.216        (drh      04-Nov-05): void enable_simulated_io_errors(void){
1.216        (drh      04-Nov-05):   sqlite3_io_error_pending = saved_cnt;
1.216        (drh      04-Nov-05): }
1.216        (drh      04-Nov-05): #else
1.217        (drh      05-Nov-05): # define disable_simulated_io_errors()
1.217        (drh      05-Nov-05): # define enable_simulated_io_errors()
1.216        (drh      04-Nov-05): #endif
1.216        (drh      04-Nov-05): 
1.216        (drh      04-Nov-05): /*
1.152        (drh      22-Jul-04): ** Read the first N bytes from the beginning of the file into memory
1.229        (danielk1 30-Dec-05): ** that pDest points to. 
1.229        (danielk1 30-Dec-05): **
1.229        (danielk1 30-Dec-05): ** No error checking is done. The rational for this is that this function 
1.229        (danielk1 30-Dec-05): ** may be called even if the file does not exist or contain a header. In 
1.229        (danielk1 30-Dec-05): ** these cases sqlite3OsRead() will return an error, to which the correct 
1.229        (danielk1 30-Dec-05): ** response is to zero the memory at pDest and continue.  A real IO error 
1.229        (danielk1 30-Dec-05): ** will presumably recur and be picked up later (Todo: Think about this).
1.152        (drh      22-Jul-04): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerReadFileheader(Pager *pPager, int N, unsigned char *pDest){
1.275        (drh      06-Nov-06):   int rc = SQLITE_OK;
1.152        (drh      22-Jul-04):   memset(pDest, 0, N);
1.169        (drh      31-Oct-04):   if( MEMDB==0 ){
1.256        (danielk1 24-Jan-06):     disable_simulated_io_errors();
1.222        (drh      30-Nov-05):     sqlite3OsSeek(pPager->fd, 0);
1.256        (danielk1 24-Jan-06):     enable_simulated_io_errors();
1.283        (drh      28-Feb-07):     IOTRACE(("DBHDR %p 0 %d\n", pPager, N))
1.275        (drh      06-Nov-06):     rc = sqlite3OsRead(pPager->fd, pDest, N);
1.275        (drh      06-Nov-06):     if( rc==SQLITE_IOERR_SHORT_READ ){
1.275        (drh      06-Nov-06):       rc = SQLITE_OK;
1.275        (drh      06-Nov-06):     }
1.152        (drh      22-Jul-04):   }
1.275        (drh      06-Nov-06):   return rc;
1.152        (drh      22-Jul-04): }
1.152        (drh      22-Jul-04): 
1.152        (drh      22-Jul-04): /*
1.14         (drh      13-Sep-01): ** Return the total number of pages in the disk file associated with
1.213        (danielk1 16-Sep-05): ** pPager. 
1.213        (danielk1 16-Sep-05): **
1.213        (danielk1 16-Sep-05): ** If the PENDING_BYTE lies on the page directly after the end of the
1.213        (danielk1 16-Sep-05): ** file, then consider this page part of the file too. For example, if
1.213        (danielk1 16-Sep-05): ** PENDING_BYTE is byte 4096 (the first byte of page 5) and the size of the
1.213        (danielk1 16-Sep-05): ** file is 4096 bytes, 5 is returned instead of 4.
1.1          (drh      11-Apr-01): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerPagecount(Pager *pPager){
1.165        (drh      01-Oct-04):   i64 n;
1.273        (drh      15-Sep-06):   int rc;
1.3          (drh      15-Apr-01):   assert( pPager!=0 );
1.288        (drh      15-Mar-07):   if( pPager->errCode ){
1.288        (drh      15-Mar-07):     return 0;
1.288        (drh      15-Mar-07):   }
1.1          (drh      11-Apr-01):   if( pPager->dbSize>=0 ){
1.213        (danielk1 16-Sep-05):     n = pPager->dbSize;
1.213        (danielk1 16-Sep-05):   } else {
1.273        (drh      15-Sep-06):     if( (rc = sqlite3OsFileSize(pPager->fd, &n))!=SQLITE_OK ){
1.273        (drh      15-Sep-06):       pager_error(pPager, rc);
1.213        (danielk1 16-Sep-05):       return 0;
1.213        (danielk1 16-Sep-05):     }
1.213        (danielk1 16-Sep-05):     if( n>0 && n<pPager->pageSize ){
1.213        (danielk1 16-Sep-05):       n = 1;
1.213        (danielk1 16-Sep-05):     }else{
1.213        (danielk1 16-Sep-05):       n /= pPager->pageSize;
1.213        (danielk1 16-Sep-05):     }
1.213        (danielk1 16-Sep-05):     if( pPager->state!=PAGER_UNLOCK ){
1.213        (danielk1 16-Sep-05):       pPager->dbSize = n;
1.213        (danielk1 16-Sep-05):     }
1.1          (drh      11-Apr-01):   }
1.213        (danielk1 16-Sep-05):   if( n==(PENDING_BYTE/pPager->pageSize) ){
1.127        (drh      15-Jun-04):     n++;
1.127        (drh      15-Jun-04):   }
1.337        (drh      08-May-07):   if( n>pPager->mxPgno ){
1.337        (drh      08-May-07):     pPager->mxPgno = n;
1.337        (drh      08-May-07):   }
1.1          (drh      11-Apr-01):   return n;
1.1          (drh      11-Apr-01): }
1.1          (drh      11-Apr-01): 
1.266        (drh      07-Apr-06): 
1.266        (drh      07-Apr-06): #ifndef SQLITE_OMIT_MEMORYDB
1.266        (drh      07-Apr-06): /*
1.266        (drh      07-Apr-06): ** Clear a PgHistory block
1.266        (drh      07-Apr-06): */
1.266        (drh      07-Apr-06): static void clearHistory(PgHistory *pHist){
1.266        (drh      07-Apr-06):   sqliteFree(pHist->pOrig);
1.266        (drh      07-Apr-06):   sqliteFree(pHist->pStmt);
1.266        (drh      07-Apr-06):   pHist->pOrig = 0;
1.266        (drh      07-Apr-06):   pHist->pStmt = 0;
1.266        (drh      07-Apr-06): }
1.266        (drh      07-Apr-06): #else
1.266        (drh      07-Apr-06): #define clearHistory(x)
1.266        (drh      07-Apr-06): #endif
1.266        (drh      07-Apr-06): 
1.1          (drh      11-Apr-01): /*
1.82         (drh      25-Apr-03): ** Forward declaration
1.82         (drh      25-Apr-03): */
1.138        (danielk1 25-Jun-04): static int syncJournal(Pager*);
1.107        (drh      12-May-04): 
1.107        (drh      12-May-04): /*
1.171        (danielk1 03-Nov-04): ** Unlink pPg from it's hash chain. Also set the page number to 0 to indicate
1.171        (danielk1 03-Nov-04): ** that the page is not part of any hash chain. This is required because the
1.292        (danielk1 19-Mar-07): ** sqlite3PagerMovepage() routine can leave a page in the 
1.171        (danielk1 03-Nov-04): ** pNextFree/pPrevFree list that is not a part of any hash-chain.
1.171        (danielk1 03-Nov-04): */
1.171        (danielk1 03-Nov-04): static void unlinkHashChain(Pager *pPager, PgHdr *pPg){
1.171        (danielk1 03-Nov-04):   if( pPg->pgno==0 ){
1.270        (drh      28-Jun-06):     assert( pPg->pNextHash==0 && pPg->pPrevHash==0 );
1.171        (danielk1 03-Nov-04):     return;
1.171        (danielk1 03-Nov-04):   }
1.171        (danielk1 03-Nov-04):   if( pPg->pNextHash ){
1.171        (danielk1 03-Nov-04):     pPg->pNextHash->pPrevHash = pPg->pPrevHash;
1.171        (danielk1 03-Nov-04):   }
1.171        (danielk1 03-Nov-04):   if( pPg->pPrevHash ){
1.268        (drh      07-May-06):     assert( pPager->aHash[pPg->pgno & (pPager->nHash-1)]!=pPg );
1.171        (danielk1 03-Nov-04):     pPg->pPrevHash->pNextHash = pPg->pNextHash;
1.171        (danielk1 03-Nov-04):   }else{
1.268        (drh      07-May-06):     int h = pPg->pgno & (pPager->nHash-1);
1.171        (danielk1 03-Nov-04):     pPager->aHash[h] = pPg->pNextHash;
1.171        (danielk1 03-Nov-04):   }
1.264        (drh      23-Mar-06):   if( MEMDB ){
1.264        (drh      23-Mar-06):     clearHistory(PGHDR_TO_HIST(pPg, pPager));
1.264        (drh      23-Mar-06):   }
1.171        (danielk1 03-Nov-04):   pPg->pgno = 0;
1.171        (danielk1 03-Nov-04):   pPg->pNextHash = pPg->pPrevHash = 0;
1.171        (danielk1 03-Nov-04): }
1.171        (danielk1 03-Nov-04): 
1.171        (danielk1 03-Nov-04): /*
1.107        (drh      12-May-04): ** Unlink a page from the free list (the list of all pages where nRef==0)
1.107        (drh      12-May-04): ** and from its hash collision chain.
1.107        (drh      12-May-04): */
1.107        (drh      12-May-04): static void unlinkPage(PgHdr *pPg){
1.107        (drh      12-May-04):   Pager *pPager = pPg->pPager;
1.107        (drh      12-May-04): 
1.107        (drh      12-May-04):   /* Keep the pFirstSynced pointer pointing at the first synchronized page */
1.107        (drh      12-May-04):   if( pPg==pPager->pFirstSynced ){
1.107        (drh      12-May-04):     PgHdr *p = pPg->pNextFree;
1.107        (drh      12-May-04):     while( p && p->needSync ){ p = p->pNextFree; }
1.107        (drh      12-May-04):     pPager->pFirstSynced = p;
1.107        (drh      12-May-04):   }
1.107        (drh      12-May-04): 
1.107        (drh      12-May-04):   /* Unlink from the freelist */
1.107        (drh      12-May-04):   if( pPg->pPrevFree ){
1.107        (drh      12-May-04):     pPg->pPrevFree->pNextFree = pPg->pNextFree;
1.107        (drh      12-May-04):   }else{
1.107        (drh      12-May-04):     assert( pPager->pFirst==pPg );
1.107        (drh      12-May-04):     pPager->pFirst = pPg->pNextFree;
1.107        (drh      12-May-04):   }
1.107        (drh      12-May-04):   if( pPg->pNextFree ){
1.107        (drh      12-May-04):     pPg->pNextFree->pPrevFree = pPg->pPrevFree;
1.107        (drh      12-May-04):   }else{
1.107        (drh      12-May-04):     assert( pPager->pLast==pPg );
1.107        (drh      12-May-04):     pPager->pLast = pPg->pPrevFree;
1.107        (drh      12-May-04):   }
1.107        (drh      12-May-04):   pPg->pNextFree = pPg->pPrevFree = 0;
1.107        (drh      12-May-04): 
1.107        (drh      12-May-04):   /* Unlink from the pgno hash table */
1.171        (danielk1 03-Nov-04):   unlinkHashChain(pPager, pPg);
1.107        (drh      12-May-04): }
1.107        (drh      12-May-04): 
1.107        (drh      12-May-04): /*
1.323        (danielk1 05-Apr-07): ** This routine is used to truncate the cache when a database
1.323        (danielk1 05-Apr-07): ** is truncated.  Drop from the cache all pages whose pgno is
1.323        (danielk1 05-Apr-07): ** larger than pPager->dbSize and is unreferenced.
1.323        (danielk1 05-Apr-07): **
1.107        (drh      12-May-04): ** Referenced pages larger than pPager->dbSize are zeroed.
1.323        (danielk1 05-Apr-07): **
1.323        (danielk1 05-Apr-07): ** Actually, at the point this routine is called, it would be
1.323        (danielk1 05-Apr-07): ** an error to have a referenced page.  But rather than delete
1.323        (danielk1 05-Apr-07): ** that page and guarantee a subsequent segfault, it seems better
1.323        (danielk1 05-Apr-07): ** to zero it and hope that we error out sanely.
1.107        (drh      12-May-04): */
1.323        (danielk1 05-Apr-07): static void pager_truncate_cache(Pager *pPager){
1.107        (drh      12-May-04):   PgHdr *pPg;
1.107        (drh      12-May-04):   PgHdr **ppPg;
1.107        (drh      12-May-04):   int dbSize = pPager->dbSize;
1.107        (drh      12-May-04): 
1.107        (drh      12-May-04):   ppPg = &pPager->pAll;
1.107        (drh      12-May-04):   while( (pPg = *ppPg)!=0 ){
1.107        (drh      12-May-04):     if( pPg->pgno<=dbSize ){
1.107        (drh      12-May-04):       ppPg = &pPg->pNextAll;
1.107        (drh      12-May-04):     }else if( pPg->nRef>0 ){
1.107        (drh      12-May-04):       memset(PGHDR_TO_DATA(pPg), 0, pPager->pageSize);
1.107        (drh      12-May-04):       ppPg = &pPg->pNextAll;
1.107        (drh      12-May-04):     }else{
1.107        (drh      12-May-04):       *ppPg = pPg->pNextAll;
1.327        (drh      13-Apr-07):       IOTRACE(("PGFREE %p %d\n", pPager, pPg->pgno));
1.327        (drh      13-Apr-07):       PAGER_INCR(sqlite3_pager_pgfree_count);
1.107        (drh      12-May-04):       unlinkPage(pPg);
1.267        (drh      03-May-06):       makeClean(pPg);
1.107        (drh      12-May-04):       sqliteFree(pPg);
1.107        (drh      12-May-04):       pPager->nPage--;
1.107        (drh      12-May-04):     }
1.107        (drh      12-May-04):   }
1.107        (drh      12-May-04): }
1.107        (drh      12-May-04): 
1.82         (drh      25-Apr-03): /*
1.190        (danielk1 15-Feb-05): ** Try to obtain a lock on a file.  Invoke the busy callback if the lock
1.208        (drh      09-Jul-05): ** is currently not available.  Repeat until the busy callback returns
1.190        (danielk1 15-Feb-05): ** false or until the lock succeeds.
1.190        (danielk1 15-Feb-05): **
1.190        (danielk1 15-Feb-05): ** Return SQLITE_OK on success and an error code if we cannot obtain
1.190        (danielk1 15-Feb-05): ** the lock.
1.190        (danielk1 15-Feb-05): */
1.190        (danielk1 15-Feb-05): static int pager_wait_on_lock(Pager *pPager, int locktype){
1.190        (danielk1 15-Feb-05):   int rc;
1.279        (drh      03-Jan-07): 
1.279        (drh      03-Jan-07):   /* The OS lock values must be the same as the Pager lock values */
1.190        (danielk1 15-Feb-05):   assert( PAGER_SHARED==SHARED_LOCK );
1.190        (danielk1 15-Feb-05):   assert( PAGER_RESERVED==RESERVED_LOCK );
1.190        (danielk1 15-Feb-05):   assert( PAGER_EXCLUSIVE==EXCLUSIVE_LOCK );
1.279        (drh      03-Jan-07): 
1.279        (drh      03-Jan-07):   /* If the file is currently unlocked then the size must be unknown */
1.279        (drh      03-Jan-07):   assert( pPager->state>=PAGER_SHARED || pPager->dbSize<0 || MEMDB );
1.279        (drh      03-Jan-07): 
1.190        (danielk1 15-Feb-05):   if( pPager->state>=locktype ){
1.190        (danielk1 15-Feb-05):     rc = SQLITE_OK;
1.190        (danielk1 15-Feb-05):   }else{
1.190        (danielk1 15-Feb-05):     do {
1.222        (drh      30-Nov-05):       rc = sqlite3OsLock(pPager->fd, locktype);
1.208        (drh      09-Jul-05):     }while( rc==SQLITE_BUSY && sqlite3InvokeBusyHandler(pPager->pBusyHandler) );
1.190        (danielk1 15-Feb-05):     if( rc==SQLITE_OK ){
1.190        (danielk1 15-Feb-05):       pPager->state = locktype;
1.283        (drh      28-Feb-07):       IOTRACE(("LOCK %p %d\n", pPager, locktype))
1.190        (danielk1 15-Feb-05):     }
1.190        (danielk1 15-Feb-05):   }
1.190        (danielk1 15-Feb-05):   return rc;
1.190        (danielk1 15-Feb-05): }
1.190        (danielk1 15-Feb-05): 
1.190        (danielk1 15-Feb-05): /*
1.82         (drh      25-Apr-03): ** Truncate the file to the number of pages specified.
1.82         (drh      25-Apr-03): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerTruncate(Pager *pPager, Pgno nPage){
1.82         (drh      25-Apr-03):   int rc;
1.279        (drh      03-Jan-07):   assert( pPager->state>=PAGER_SHARED || MEMDB );
1.292        (danielk1 19-Mar-07):   sqlite3PagerPagecount(pPager);
1.238        (danielk1 16-Jan-06):   if( pPager->errCode ){
1.238        (danielk1 16-Jan-06):     rc = pPager->errCode;
1.83         (drh      25-Apr-03):     return rc;
1.83         (drh      25-Apr-03):   }
1.84         (drh      04-Jun-03):   if( nPage>=(unsigned)pPager->dbSize ){
1.82         (drh      25-Apr-03):     return SQLITE_OK;
1.82         (drh      25-Apr-03):   }
1.169        (drh      31-Oct-04):   if( MEMDB ){
1.107        (drh      12-May-04):     pPager->dbSize = nPage;
1.323        (danielk1 05-Apr-07):     pager_truncate_cache(pPager);
1.107        (drh      12-May-04):     return SQLITE_OK;
1.107        (drh      12-May-04):   }
1.138        (danielk1 25-Jun-04):   rc = syncJournal(pPager);
1.128        (danielk1 15-Jun-04):   if( rc!=SQLITE_OK ){
1.128        (danielk1 15-Jun-04):     return rc;
1.128        (danielk1 15-Jun-04):   }
1.190        (danielk1 15-Feb-05): 
1.190        (danielk1 15-Feb-05):   /* Get an exclusive lock on the database before truncating. */
1.190        (danielk1 15-Feb-05):   rc = pager_wait_on_lock(pPager, EXCLUSIVE_LOCK);
1.190        (danielk1 15-Feb-05):   if( rc!=SQLITE_OK ){
1.190        (danielk1 15-Feb-05):     return rc;
1.190        (danielk1 15-Feb-05):   }
1.190        (danielk1 15-Feb-05): 
1.158        (drh      18-Aug-04):   rc = pager_truncate(pPager, nPage);
1.82         (drh      25-Apr-03):   return rc;
1.82         (drh      25-Apr-03): }
1.82         (drh      25-Apr-03): 
1.82         (drh      25-Apr-03): /*
1.1          (drh      11-Apr-01): ** Shutdown the page cache.  Free all memory and close all files.
1.1          (drh      11-Apr-01): **
1.1          (drh      11-Apr-01): ** If a transaction was in progress when this routine is called, that
1.1          (drh      11-Apr-01): ** transaction is rolled back.  All outstanding pages are invalidated
1.1          (drh      11-Apr-01): ** and their memory is freed.  Any attempt to use a page associated
1.1          (drh      11-Apr-01): ** with this page cache after this function returns will likely
1.1          (drh      11-Apr-01): ** result in a coredump.
1.229        (danielk1 30-Dec-05): **
1.229        (danielk1 30-Dec-05): ** This function always succeeds. If a transaction is active an attempt
1.229        (danielk1 30-Dec-05): ** is made to roll it back. If an error occurs during the rollback 
1.229        (danielk1 30-Dec-05): ** a hot journal may be left in the filesystem but no error is returned
1.229        (danielk1 30-Dec-05): ** to the caller.
1.1          (drh      11-Apr-01): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerClose(Pager *pPager){
1.236        (drh      11-Jan-06): #ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
1.242        (danielk1 18-Jan-06):   /* A malloc() cannot fail in sqlite3ThreadData() as one or more calls to 
1.242        (danielk1 18-Jan-06):   ** malloc() must have already been made by this thread before it gets
1.242        (danielk1 18-Jan-06):   ** to this point. This means the ThreadData must have been allocated already
1.242        (danielk1 18-Jan-06):   ** so that ThreadData.nAlloc can be set.
1.242        (danielk1 18-Jan-06):   */
1.241        (danielk1 16-Jan-06):   ThreadData *pTsd = sqlite3ThreadData();
1.245        (danielk1 18-Jan-06):   assert( pPager );
1.242        (danielk1 18-Jan-06):   assert( pTsd && pTsd->nAlloc );
1.225        (danielk1 18-Dec-05): #endif
1.225        (danielk1 18-Dec-05): 
1.280        (drh      03-Jan-07):   disable_simulated_io_errors();
1.281        (drh      04-Jan-07):   pPager->errCode = 0;
1.294        (danielk1 24-Mar-07):   pPager->exclusiveMode = 0;
1.280        (drh      03-Jan-07):   pager_reset(pPager);
1.293        (danielk1 23-Mar-07):   pagerUnlockAndRollback(pPager);
1.280        (drh      03-Jan-07):   enable_simulated_io_errors();
1.300        (drh      26-Mar-07):   PAGERTRACE2("CLOSE %d\n", PAGERID(pPager));
1.283        (drh      28-Feb-07):   IOTRACE(("CLOSE %p\n", pPager))
1.238        (danielk1 16-Jan-06):   assert( pPager->errCode || (pPager->journalOpen==0 && pPager->stmtOpen==0) );
1.197        (danielk1 21-Mar-05):   if( pPager->journalOpen ){
1.222        (drh      30-Nov-05):     sqlite3OsClose(&pPager->jfd);
1.197        (danielk1 21-Mar-05):   }
1.201        (drh      28-Mar-05):   sqliteFree(pPager->aInJournal);
1.197        (danielk1 21-Mar-05):   if( pPager->stmtOpen ){
1.222        (drh      30-Nov-05):     sqlite3OsClose(&pPager->stfd);
1.197        (danielk1 21-Mar-05):   }
1.222        (drh      30-Nov-05):   sqlite3OsClose(&pPager->fd);
1.46         (drh      30-May-02):   /* Temp files are automatically deleted by the OS
1.46         (drh      30-May-02):   ** if( pPager->tempFile ){
1.231        (drh      06-Jan-06):   **   sqlite3OsDelete(pPager->zFilename);
1.46         (drh      30-May-02):   ** }
1.46         (drh      30-May-02):   */
1.182        (danielk1 13-Jan-05): 
1.236        (drh      11-Jan-06): #ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
1.229        (danielk1 30-Dec-05):   /* Remove the pager from the linked list of pagers starting at 
1.233        (danielk1 09-Jan-06):   ** ThreadData.pPager if memory-management is enabled.
1.229        (danielk1 30-Dec-05):   */
1.241        (danielk1 16-Jan-06):   if( pPager==pTsd->pPager ){
1.241        (danielk1 16-Jan-06):     pTsd->pPager = pPager->pNext;
1.241        (danielk1 16-Jan-06):   }else{
1.241        (danielk1 16-Jan-06):     Pager *pTmp;
1.259        (drh      24-Feb-06):     for(pTmp = pTsd->pPager; pTmp->pNext!=pPager; pTmp=pTmp->pNext){}
1.241        (danielk1 16-Jan-06):     pTmp->pNext = pPager->pNext;
1.225        (danielk1 18-Dec-05):   }
1.225        (danielk1 18-Dec-05): #endif
1.268        (drh      07-May-06):   sqliteFree(pPager->aHash);
1.286        (danielk1 06-Mar-07):   sqliteFree(pPager->pTmpSpace);
1.1          (drh      11-Apr-01):   sqliteFree(pPager);
1.1          (drh      11-Apr-01):   return SQLITE_OK;
1.1          (drh      11-Apr-01): }
1.1          (drh      11-Apr-01): 
1.338        (drh      08-May-07): #if !defined(NDEBUG) || defined(SQLITE_TEST)
1.1          (drh      11-Apr-01): /*
1.14         (drh      13-Sep-01): ** Return the page number for the given page data.
1.1          (drh      11-Apr-01): */
1.292        (danielk1 19-Mar-07): Pgno sqlite3PagerPagenumber(DbPage *p){
1.1          (drh      11-Apr-01):   return p->pgno;
1.1          (drh      11-Apr-01): }
1.338        (drh      08-May-07): #endif
1.1          (drh      11-Apr-01): 
1.1          (drh      11-Apr-01): /*
1.105        (drh      08-May-04): ** The page_ref() function increments the reference count for a page.
1.105        (drh      08-May-04): ** If the page is currently on the freelist (the reference count is zero) then
1.5          (drh      28-Apr-01): ** remove it from the freelist.
1.105        (drh      08-May-04): **
1.105        (drh      08-May-04): ** For non-test systems, page_ref() is a macro that calls _page_ref()
1.105        (drh      08-May-04): ** online of the reference count is zero.  For test systems, page_ref()
1.105        (drh      08-May-04): ** is a real function so that we can set breakpoints and trace it.
1.5          (drh      28-Apr-01): */
1.66         (drh      11-Jan-03): static void _page_ref(PgHdr *pPg){
1.5          (drh      28-Apr-01):   if( pPg->nRef==0 ){
1.5          (drh      28-Apr-01):     /* The page is currently on the freelist.  Remove it. */
1.69         (drh      21-Jan-03):     if( pPg==pPg->pPager->pFirstSynced ){
1.69         (drh      21-Jan-03):       PgHdr *p = pPg->pNextFree;
1.69         (drh      21-Jan-03):       while( p && p->needSync ){ p = p->pNextFree; }
1.69         (drh      21-Jan-03):       pPg->pPager->pFirstSynced = p;
1.69         (drh      21-Jan-03):     }
1.5          (drh      28-Apr-01):     if( pPg->pPrevFree ){
1.5          (drh      28-Apr-01):       pPg->pPrevFree->pNextFree = pPg->pNextFree;
1.5          (drh      28-Apr-01):     }else{
1.5          (drh      28-Apr-01):       pPg->pPager->pFirst = pPg->pNextFree;
1.5          (drh      28-Apr-01):     }
1.5          (drh      28-Apr-01):     if( pPg->pNextFree ){
1.5          (drh      28-Apr-01):       pPg->pNextFree->pPrevFree = pPg->pPrevFree;
1.5          (drh      28-Apr-01):     }else{
1.5          (drh      28-Apr-01):       pPg->pPager->pLast = pPg->pPrevFree;
1.5          (drh      28-Apr-01):     }
1.5          (drh      28-Apr-01):     pPg->pPager->nRef++;
1.5          (drh      28-Apr-01):   }
1.5          (drh      28-Apr-01):   pPg->nRef++;
1.12         (drh      28-Jun-01):   REFINFO(pPg);
1.10         (drh      23-Jun-01): }
1.182        (danielk1 13-Jan-05): #ifdef SQLITE_DEBUG
1.105        (drh      08-May-04):   static void page_ref(PgHdr *pPg){
1.105        (drh      08-May-04):     if( pPg->nRef==0 ){
1.105        (drh      08-May-04):       _page_ref(pPg);
1.105        (drh      08-May-04):     }else{
1.105        (drh      08-May-04):       pPg->nRef++;
1.105        (drh      08-May-04):       REFINFO(pPg);
1.105        (drh      08-May-04):     }
1.105        (drh      08-May-04):   }
1.105        (drh      08-May-04): #else
1.105        (drh      08-May-04): # define page_ref(P)   ((P)->nRef==0?_page_ref(P):(void)(P)->nRef++)
1.105        (drh      08-May-04): #endif
1.10         (drh      23-Jun-01): 
1.10         (drh      23-Jun-01): /*
1.10         (drh      23-Jun-01): ** Increment the reference count for a page.  The input pointer is
1.10         (drh      23-Jun-01): ** a reference to the page data.
1.10         (drh      23-Jun-01): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerRef(DbPage *pPg){
1.10         (drh      23-Jun-01):   page_ref(pPg);
1.9          (drh      22-Jun-01):   return SQLITE_OK;
1.5          (drh      28-Apr-01): }
1.5          (drh      28-Apr-01): 
1.5          (drh      28-Apr-01): /*
1.94         (drh      08-Feb-04): ** Sync the journal.  In other words, make sure all the pages that have
1.94         (drh      08-Feb-04): ** been written to the journal have actually reached the surface of the
1.94         (drh      08-Feb-04): ** disk.  It is not safe to modify the original database file until after
1.94         (drh      08-Feb-04): ** the journal has been synced.  If the original database is modified before
1.94         (drh      08-Feb-04): ** the journal is synced and a power failure occurs, the unsynced journal
1.94         (drh      08-Feb-04): ** data would be lost and we would be unable to completely rollback the
1.94         (drh      08-Feb-04): ** database changes.  Database corruption would occur.
1.94         (drh      08-Feb-04): ** 
1.94         (drh      08-Feb-04): ** This routine also updates the nRec field in the header of the journal.
1.94         (drh      08-Feb-04): ** (See comments on the pager_playback() routine for additional information.)
1.94         (drh      08-Feb-04): ** If the sync mode is FULL, two syncs will occur.  First the whole journal
1.94         (drh      08-Feb-04): ** is synced, then the nRec field is updated, then a second sync occurs.
1.94         (drh      08-Feb-04): **
1.94         (drh      08-Feb-04): ** For temporary databases, we do not care if we are able to rollback
1.94         (drh      08-Feb-04): ** after a power failure, so sync occurs.
1.20         (drh      16-Sep-01): **
1.94         (drh      08-Feb-04): ** This routine clears the needSync field of every page current held in
1.94         (drh      08-Feb-04): ** memory.
1.19         (drh      15-Sep-01): */
1.138        (danielk1 25-Jun-04): static int syncJournal(Pager *pPager){
1.19         (drh      15-Sep-01):   PgHdr *pPg;
1.19         (drh      15-Sep-01):   int rc = SQLITE_OK;
1.57         (drh      10-Nov-02): 
1.57         (drh      10-Nov-02):   /* Sync the journal before modifying the main database
1.57         (drh      10-Nov-02):   ** (assuming there is a journal and it needs to be synced.)
1.57         (drh      10-Nov-02):   */
1.138        (danielk1 25-Jun-04):   if( pPager->needSync ){
1.37         (drh      02-Feb-02):     if( !pPager->tempFile ){
1.68         (drh      16-Jan-03):       assert( pPager->journalOpen );
1.101        (drh      25-Feb-04):       /* assert( !pPager->noSync ); // noSync might be set if synchronous
1.101        (drh      25-Feb-04):       ** was turned off after the transaction was started.  Ticket #615 */
1.73         (drh      11-Feb-03): #ifndef NDEBUG
1.73         (drh      11-Feb-03):       {
1.94         (drh      08-Feb-04):         /* Make sure the pPager->nRec counter we are keeping agrees
1.94         (drh      08-Feb-04):         ** with the nRec computed from the size of the journal file.
1.94         (drh      08-Feb-04):         */
1.165        (drh      01-Oct-04):         i64 jSz;
1.222        (drh      30-Nov-05):         rc = sqlite3OsFileSize(pPager->jfd, &jSz);
1.73         (drh      11-Feb-03):         if( rc!=0 ) return rc;
1.138        (danielk1 25-Jun-04):         assert( pPager->journalOff==jSz );
1.73         (drh      11-Feb-03):       }
1.73         (drh      11-Feb-03): #endif
1.116        (drh      09-Jun-04):       {
1.138        (danielk1 25-Jun-04):         /* Write the nRec value into the journal file header. If in
1.138        (danielk1 25-Jun-04):         ** full-synchronous mode, sync the journal first. This ensures that
1.138        (danielk1 25-Jun-04):         ** all data has really hit the disk before nRec is updated to mark
1.138        (danielk1 25-Jun-04):         ** it as a candidate for rollback. 
1.138        (danielk1 25-Jun-04):         */
1.74         (drh      12-Feb-03):         if( pPager->fullSync ){
1.300        (drh      26-Mar-07):           PAGERTRACE2("SYNC journal of %d\n", PAGERID(pPager));
1.283        (drh      28-Feb-07):           IOTRACE(("JSYNC %p\n", pPager))
1.222        (drh      30-Nov-05):           rc = sqlite3OsSync(pPager->jfd, 0);
1.74         (drh      12-Feb-03):           if( rc!=0 ) return rc;
1.74         (drh      12-Feb-03):         }
1.222        (drh      30-Nov-05):         rc = sqlite3OsSeek(pPager->jfd,
1.212        (drh      09-Sep-05):                            pPager->journalHdr + sizeof(aJournalMagic));
1.212        (drh      09-Sep-05):         if( rc ) return rc;
1.283        (drh      28-Feb-07):         IOTRACE(("JHDR %p %lld %d\n", pPager,
1.283        (drh      28-Feb-07):                   pPager->journalHdr + sizeof(aJournalMagic), 4))
1.221        (drh      29-Nov-05):         rc = write32bits(pPager->jfd, pPager->nRec);
1.78         (drh      16-Feb-03):         if( rc ) return rc;
1.110        (danielk1 03-Jun-04): 
1.222        (drh      30-Nov-05):         rc = sqlite3OsSeek(pPager->jfd, pPager->journalOff);
1.212        (drh      09-Sep-05):         if( rc ) return rc;
1.73         (drh      11-Feb-03):       }
1.300        (drh      26-Mar-07):       PAGERTRACE2("SYNC journal of %d\n", PAGERID(pPager));
1.334        (drh      04-May-07):       IOTRACE(("JSYNC %p\n", pPager))
1.258        (drh      11-Feb-06):       rc = sqlite3OsSync(pPager->jfd, pPager->full_fsync);
1.37         (drh      02-Feb-02):       if( rc!=0 ) return rc;
1.68         (drh      16-Jan-03):       pPager->journalStarted = 1;
1.37         (drh      02-Feb-02):     }
1.19         (drh      15-Sep-01):     pPager->needSync = 0;
1.69         (drh      21-Jan-03): 
1.69         (drh      21-Jan-03):     /* Erase the needSync flag from every page.
1.69         (drh      21-Jan-03):     */
1.69         (drh      21-Jan-03):     for(pPg=pPager->pAll; pPg; pPg=pPg->pNextAll){
1.69         (drh      21-Jan-03):       pPg->needSync = 0;
1.69         (drh      21-Jan-03):     }
1.69         (drh      21-Jan-03):     pPager->pFirstSynced = pPager->pFirst;
1.19         (drh      15-Sep-01):   }
1.57         (drh      10-Nov-02): 
1.69         (drh      21-Jan-03): #ifndef NDEBUG
1.69         (drh      21-Jan-03):   /* If the Pager.needSync flag is clear then the PgHdr.needSync
1.69         (drh      21-Jan-03):   ** flag must also be clear for all pages.  Verify that this
1.69         (drh      21-Jan-03):   ** invariant is true.
1.68         (drh      16-Jan-03):   */
1.69         (drh      21-Jan-03):   else{
1.69         (drh      21-Jan-03):     for(pPg=pPager->pAll; pPg; pPg=pPg->pNextAll){
1.69         (drh      21-Jan-03):       assert( pPg->needSync==0 );
1.69         (drh      21-Jan-03):     }
1.69         (drh      21-Jan-03):     assert( pPager->pFirstSynced==pPager->pFirst );
1.19         (drh      15-Sep-01):   }
1.69         (drh      21-Jan-03): #endif
1.69         (drh      21-Jan-03): 
1.70         (drh      22-Jan-03):   return rc;
1.70         (drh      22-Jan-03): }
1.70         (drh      22-Jan-03): 
1.70         (drh      22-Jan-03): /*
1.269        (drh      15-Jun-06): ** Merge two lists of pages connected by pDirty and in pgno order.
1.269        (drh      15-Jun-06): ** Do not both fixing the pPrevDirty pointers.
1.269        (drh      15-Jun-06): */
1.269        (drh      15-Jun-06): static PgHdr *merge_pagelist(PgHdr *pA, PgHdr *pB){
1.269        (drh      15-Jun-06):   PgHdr result, *pTail;
1.269        (drh      15-Jun-06):   pTail = &result;
1.269        (drh      15-Jun-06):   while( pA && pB ){
1.269        (drh      15-Jun-06):     if( pA->pgno<pB->pgno ){
1.269        (drh      15-Jun-06):       pTail->pDirty = pA;
1.269        (drh      15-Jun-06):       pTail = pA;
1.269        (drh      15-Jun-06):       pA = pA->pDirty;
1.269        (drh      15-Jun-06):     }else{
1.269        (drh      15-Jun-06):       pTail->pDirty = pB;
1.269        (drh      15-Jun-06):       pTail = pB;
1.269        (drh      15-Jun-06):       pB = pB->pDirty;
1.269        (drh      15-Jun-06):     }
1.269        (drh      15-Jun-06):   }
1.269        (drh      15-Jun-06):   if( pA ){
1.269        (drh      15-Jun-06):     pTail->pDirty = pA;
1.269        (drh      15-Jun-06):   }else if( pB ){
1.269        (drh      15-Jun-06):     pTail->pDirty = pB;
1.269        (drh      15-Jun-06):   }else{
1.269        (drh      15-Jun-06):     pTail->pDirty = 0;
1.269        (drh      15-Jun-06):   }
1.269        (drh      15-Jun-06):   return result.pDirty;
1.269        (drh      15-Jun-06): }
1.269        (drh      15-Jun-06): 
1.269        (drh      15-Jun-06): /*
1.269        (drh      15-Jun-06): ** Sort the list of pages in accending order by pgno.  Pages are
1.269        (drh      15-Jun-06): ** connected by pDirty pointers.  The pPrevDirty pointers are
1.269        (drh      15-Jun-06): ** corrupted by this sort.
1.269        (drh      15-Jun-06): */
1.314        (danielk1 02-Apr-07): #define N_SORT_BUCKET_ALLOC 25
1.314        (danielk1 02-Apr-07): #define N_SORT_BUCKET       25
1.314        (danielk1 02-Apr-07): #ifdef SQLITE_TEST
1.314        (danielk1 02-Apr-07):   int sqlite3_pager_n_sort_bucket = 0;
1.314        (danielk1 02-Apr-07):   #undef N_SORT_BUCKET
1.314        (danielk1 02-Apr-07):   #define N_SORT_BUCKET \
1.314        (danielk1 02-Apr-07):    (sqlite3_pager_n_sort_bucket?sqlite3_pager_n_sort_bucket:N_SORT_BUCKET_ALLOC)
1.314        (danielk1 02-Apr-07): #endif
1.269        (drh      15-Jun-06): static PgHdr *sort_pagelist(PgHdr *pIn){
1.314        (danielk1 02-Apr-07):   PgHdr *a[N_SORT_BUCKET_ALLOC], *p;
1.269        (drh      15-Jun-06):   int i;
1.269        (drh      15-Jun-06):   memset(a, 0, sizeof(a));
1.269        (drh      15-Jun-06):   while( pIn ){
1.269        (drh      15-Jun-06):     p = pIn;
1.269        (drh      15-Jun-06):     pIn = p->pDirty;
1.269        (drh      15-Jun-06):     p->pDirty = 0;
1.269        (drh      15-Jun-06):     for(i=0; i<N_SORT_BUCKET-1; i++){
1.269        (drh      15-Jun-06):       if( a[i]==0 ){
1.269        (drh      15-Jun-06):         a[i] = p;
1.269        (drh      15-Jun-06):         break;
1.269        (drh      15-Jun-06):       }else{
1.269        (drh      15-Jun-06):         p = merge_pagelist(a[i], p);
1.269        (drh      15-Jun-06):         a[i] = 0;
1.269        (drh      15-Jun-06):       }
1.269        (drh      15-Jun-06):     }
1.269        (drh      15-Jun-06):     if( i==N_SORT_BUCKET-1 ){
1.314        (danielk1 02-Apr-07):       /* Coverage: To get here, there need to be 2^(N_SORT_BUCKET) 
1.314        (danielk1 02-Apr-07):       ** elements in the input list. This is possible, but impractical.
1.314        (danielk1 02-Apr-07):       ** Testing this line is the point of global variable
1.314        (danielk1 02-Apr-07):       ** sqlite3_pager_n_sort_bucket.
1.314        (danielk1 02-Apr-07):       */
1.269        (drh      15-Jun-06):       a[i] = merge_pagelist(a[i], p);
1.269        (drh      15-Jun-06):     }
1.269        (drh      15-Jun-06):   }
1.269        (drh      15-Jun-06):   p = a[0];
1.269        (drh      15-Jun-06):   for(i=1; i<N_SORT_BUCKET; i++){
1.269        (drh      15-Jun-06):     p = merge_pagelist(p, a[i]);
1.269        (drh      15-Jun-06):   }
1.269        (drh      15-Jun-06):   return p;
1.269        (drh      15-Jun-06): }
1.269        (drh      15-Jun-06): 
1.269        (drh      15-Jun-06): /*
1.70         (drh      22-Jan-03): ** Given a list of pages (connected by the PgHdr.pDirty pointer) write
1.70         (drh      22-Jan-03): ** every one of those pages out to the database file and mark them all
1.70         (drh      22-Jan-03): ** as clean.
1.70         (drh      22-Jan-03): */
1.70         (drh      22-Jan-03): static int pager_write_pagelist(PgHdr *pList){
1.70         (drh      22-Jan-03):   Pager *pPager;
1.70         (drh      22-Jan-03):   int rc;
1.70         (drh      22-Jan-03): 
1.70         (drh      22-Jan-03):   if( pList==0 ) return SQLITE_OK;
1.70         (drh      22-Jan-03):   pPager = pList->pPager;
1.112        (danielk1 04-Jun-04): 
1.112        (danielk1 04-Jun-04):   /* At this point there may be either a RESERVED or EXCLUSIVE lock on the
1.112        (danielk1 04-Jun-04):   ** database file. If there is already an EXCLUSIVE lock, the following
1.222        (drh      30-Nov-05):   ** calls to sqlite3OsLock() are no-ops.
1.112        (danielk1 04-Jun-04):   **
1.115        (drh      09-Jun-04):   ** Moving the lock from RESERVED to EXCLUSIVE actually involves going
1.115        (drh      09-Jun-04):   ** through an intermediate state PENDING.   A PENDING lock prevents new
1.115        (drh      09-Jun-04):   ** readers from attaching to the database but is unsufficient for us to
1.115        (drh      09-Jun-04):   ** write.  The idea of a PENDING lock is to prevent new readers from
1.115        (drh      09-Jun-04):   ** coming in while we wait for existing readers to clear.
1.112        (danielk1 04-Jun-04):   **
1.115        (drh      09-Jun-04):   ** While the pager is in the RESERVED state, the original database file
1.115        (drh      09-Jun-04):   ** is unchanged and we can rollback without having to playback the
1.115        (drh      09-Jun-04):   ** journal into the original database file.  Once we transition to
1.115        (drh      09-Jun-04):   ** EXCLUSIVE, it means the database file has been changed and any rollback
1.115        (drh      09-Jun-04):   ** will require a journal playback.
1.112        (danielk1 04-Jun-04):   */
1.167        (drh      05-Oct-04):   rc = pager_wait_on_lock(pPager, EXCLUSIVE_LOCK);
1.112        (danielk1 04-Jun-04):   if( rc!=SQLITE_OK ){
1.112        (danielk1 04-Jun-04):     return rc;
1.112        (danielk1 04-Jun-04):   }
1.112        (danielk1 04-Jun-04): 
1.269        (drh      15-Jun-06):   pList = sort_pagelist(pList);
1.70         (drh      22-Jan-03):   while( pList ){
1.70         (drh      22-Jan-03):     assert( pList->dirty );
1.222        (drh      30-Nov-05):     rc = sqlite3OsSeek(pPager->fd, (pList->pgno-1)*(i64)pPager->pageSize);
1.212        (drh      09-Sep-05):     if( rc ) return rc;
1.170        (danielk1 02-Nov-04):     /* If there are dirty pages in the page cache with page numbers greater
1.292        (danielk1 19-Mar-07):     ** than Pager.dbSize, this means sqlite3PagerTruncate() was called to
1.170        (danielk1 02-Nov-04):     ** make the file smaller (presumably by auto-vacuum code). Do not write
1.170        (danielk1 02-Nov-04):     ** any such pages to the file.
1.170        (danielk1 02-Nov-04):     */
1.170        (danielk1 02-Nov-04):     if( pList->pgno<=pPager->dbSize ){
1.261        (drh      06-Mar-06):       char *pData = CODEC2(pPager, PGHDR_TO_DATA(pList), pList->pgno, 6);
1.344        (drh      16-Jun-07):       PAGERTRACE4("STORE %d page %d hash(%08x)\n",
1.344        (drh      16-Jun-07):                    PAGERID(pPager), pList->pgno, pager_pagehash(pList));
1.327        (drh      13-Apr-07):       IOTRACE(("PGOUT %p %d\n", pPager, pList->pgno));
1.261        (drh      06-Mar-06):       rc = sqlite3OsWrite(pPager->fd, pData, pPager->pageSize);
1.327        (drh      13-Apr-07):       PAGER_INCR(sqlite3_pager_writedb_count);
1.327        (drh      13-Apr-07):       PAGER_INCR(pPager->nWrite);
1.329        (drh      16-Apr-07):       if( pList->pgno==1 ){
1.329        (drh      16-Apr-07):         memcpy(&pPager->dbFileVers, &pData[24], sizeof(pPager->dbFileVers));
1.329        (drh      16-Apr-07):       }
1.170        (danielk1 02-Nov-04):     }
1.170        (danielk1 02-Nov-04): #ifndef NDEBUG
1.170        (danielk1 02-Nov-04):     else{
1.300        (drh      26-Mar-07):       PAGERTRACE3("NOSTORE %d page %d\n", PAGERID(pPager), pList->pgno);
1.170        (danielk1 02-Nov-04):     }
1.170        (danielk1 02-Nov-04): #endif
1.70         (drh      22-Jan-03):     if( rc ) return rc;
1.70         (drh      22-Jan-03):     pList->dirty = 0;
1.189        (danielk1 15-Feb-05): #ifdef SQLITE_CHECK_PAGES
1.189        (danielk1 15-Feb-05):     pList->pageHash = pager_pagehash(pList);
1.189        (danielk1 15-Feb-05): #endif
1.70         (drh      22-Jan-03):     pList = pList->pDirty;
1.70         (drh      22-Jan-03):   }
1.70         (drh      22-Jan-03):   return SQLITE_OK;
1.70         (drh      22-Jan-03): }
1.68         (drh      16-Jan-03): 
1.70         (drh      22-Jan-03): /*
1.70         (drh      22-Jan-03): ** Collect every dirty page into a dirty list and
1.70         (drh      22-Jan-03): ** return a pointer to the head of that list.  All pages are
1.70         (drh      22-Jan-03): ** collected even if they are still in use.
1.70         (drh      22-Jan-03): */
1.70         (drh      22-Jan-03): static PgHdr *pager_get_all_dirty_pages(Pager *pPager){
1.267        (drh      03-May-06):   return pPager->pDirty;
1.19         (drh      15-Sep-01): }
1.19         (drh      15-Sep-01): 
1.19         (drh      15-Sep-01): /*
1.194        (drh      15-Mar-05): ** Return TRUE if there is a hot journal on the given pager.
1.194        (drh      15-Mar-05): ** A hot journal is one that needs to be played back.
1.194        (drh      15-Mar-05): **
1.194        (drh      15-Mar-05): ** If the current size of the database file is 0 but a journal file
1.194        (drh      15-Mar-05): ** exists, that is probably an old journal left over from a prior
1.194        (drh      15-Mar-05): ** database with the same name.  Just delete the journal.
1.194        (drh      15-Mar-05): */
1.194        (drh      15-Mar-05): static int hasHotJournal(Pager *pPager){
1.194        (drh      15-Mar-05):   if( !pPager->useJournal ) return 0;
1.324        (drh      06-Apr-07):   if( !sqlite3OsFileExists(pPager->zJournal) ){
1.324        (drh      06-Apr-07):     return 0;
1.324        (drh      06-Apr-07):   }
1.324        (drh      06-Apr-07):   if( sqlite3OsCheckReservedLock(pPager->fd) ){
1.324        (drh      06-Apr-07):     return 0;
1.324        (drh      06-Apr-07):   }
1.292        (danielk1 19-Mar-07):   if( sqlite3PagerPagecount(pPager)==0 ){
1.231        (drh      06-Jan-06):     sqlite3OsDelete(pPager->zJournal);
1.194        (drh      15-Mar-05):     return 0;
1.194        (drh      15-Mar-05):   }else{
1.194        (drh      15-Mar-05):     return 1;
1.194        (drh      15-Mar-05):   }
1.194        (drh      15-Mar-05): }
1.194        (drh      15-Mar-05): 
1.228        (danielk1 20-Dec-05): /*
1.229        (danielk1 30-Dec-05): ** Try to find a page in the cache that can be recycled. 
1.229        (danielk1 30-Dec-05): **
1.229        (danielk1 30-Dec-05): ** This routine may return SQLITE_IOERR, SQLITE_FULL or SQLITE_OK. It 
1.238        (danielk1 16-Jan-06): ** does not set the pPager->errCode variable.
1.228        (danielk1 20-Dec-05): */
1.225        (danielk1 18-Dec-05): static int pager_recycle(Pager *pPager, int syncOk, PgHdr **ppPg){
1.225        (danielk1 18-Dec-05):   PgHdr *pPg;
1.225        (danielk1 18-Dec-05):   *ppPg = 0;
1.225        (danielk1 18-Dec-05): 
1.321        (danielk1 05-Apr-07):   assert(!MEMDB);
1.321        (danielk1 05-Apr-07): 
1.225        (danielk1 18-Dec-05):   /* Find a page to recycle.  Try to locate a page that does not
1.225        (danielk1 18-Dec-05):   ** require us to do an fsync() on the journal.
1.225        (danielk1 18-Dec-05):   */
1.225        (danielk1 18-Dec-05):   pPg = pPager->pFirstSynced;
1.225        (danielk1 18-Dec-05): 
1.225        (danielk1 18-Dec-05):   /* If we could not find a page that does not require an fsync()
1.225        (danielk1 18-Dec-05):   ** on the journal file then fsync the journal file.  This is a
1.225        (danielk1 18-Dec-05):   ** very slow operation, so we work hard to avoid it.  But sometimes
1.225        (danielk1 18-Dec-05):   ** it can't be helped.
1.225        (danielk1 18-Dec-05):   */
1.228        (danielk1 20-Dec-05):   if( pPg==0 && pPager->pFirst && syncOk && !MEMDB){
1.225        (danielk1 18-Dec-05):     int rc = syncJournal(pPager);
1.225        (danielk1 18-Dec-05):     if( rc!=0 ){
1.229        (danielk1 30-Dec-05):       return rc;
1.225        (danielk1 18-Dec-05):     }
1.225        (danielk1 18-Dec-05):     if( pPager->fullSync ){
1.225        (danielk1 18-Dec-05):       /* If in full-sync mode, write a new journal header into the
1.225        (danielk1 18-Dec-05):       ** journal file. This is done to avoid ever modifying a journal
1.225        (danielk1 18-Dec-05):       ** header that is involved in the rollback of pages that have
1.225        (danielk1 18-Dec-05):       ** already been written to the database (in case the header is
1.225        (danielk1 18-Dec-05):       ** trashed when the nRec field is updated).
1.225        (danielk1 18-Dec-05):       */
1.225        (danielk1 18-Dec-05):       pPager->nRec = 0;
1.225        (danielk1 18-Dec-05):       assert( pPager->journalOff > 0 );
1.290        (danielk1 19-Mar-07):       assert( pPager->doNotSync==0 );
1.225        (danielk1 18-Dec-05):       rc = writeJournalHdr(pPager);
1.225        (danielk1 18-Dec-05):       if( rc!=0 ){
1.229        (danielk1 30-Dec-05):         return rc;
1.225        (danielk1 18-Dec-05):       }
1.225        (danielk1 18-Dec-05):     }
1.225        (danielk1 18-Dec-05):     pPg = pPager->pFirst;
1.225        (danielk1 18-Dec-05):   }
1.225        (danielk1 18-Dec-05):   if( pPg==0 ){
1.225        (danielk1 18-Dec-05):     return SQLITE_OK;
1.225        (danielk1 18-Dec-05):   }
1.225        (danielk1 18-Dec-05): 
1.225        (danielk1 18-Dec-05):   assert( pPg->nRef==0 );
1.225        (danielk1 18-Dec-05): 
1.225        (danielk1 18-Dec-05):   /* Write the page to the database file if it is dirty.
1.225        (danielk1 18-Dec-05):   */
1.225        (danielk1 18-Dec-05):   if( pPg->dirty ){
1.225        (danielk1 18-Dec-05):     int rc;
1.225        (danielk1 18-Dec-05):     assert( pPg->needSync==0 );
1.267        (drh      03-May-06):     makeClean(pPg);
1.267        (drh      03-May-06):     pPg->dirty = 1;
1.225        (danielk1 18-Dec-05):     pPg->pDirty = 0;
1.225        (danielk1 18-Dec-05):     rc = pager_write_pagelist( pPg );
1.225        (danielk1 18-Dec-05):     if( rc!=SQLITE_OK ){
1.229        (danielk1 30-Dec-05):       return rc;
1.225        (danielk1 18-Dec-05):     }
1.225        (danielk1 18-Dec-05):   }
1.225        (danielk1 18-Dec-05):   assert( pPg->dirty==0 );
1.225        (danielk1 18-Dec-05): 
1.225        (danielk1 18-Dec-05):   /* If the page we are recycling is marked as alwaysRollback, then
1.225        (danielk1 18-Dec-05):   ** set the global alwaysRollback flag, thus disabling the
1.307        (drh      30-Mar-07):   ** sqlite3PagerDontRollback() optimization for the rest of this transaction.
1.225        (danielk1 18-Dec-05):   ** It is necessary to do this because the page marked alwaysRollback
1.225        (danielk1 18-Dec-05):   ** might be reloaded at a later time but at that point we won't remember
1.225        (danielk1 18-Dec-05):   ** that is was marked alwaysRollback.  This means that all pages must
1.225        (danielk1 18-Dec-05):   ** be marked as alwaysRollback from here on out.
1.225        (danielk1 18-Dec-05):   */
1.225        (danielk1 18-Dec-05):   if( pPg->alwaysRollback ){
1.284        (drh      01-Mar-07):     IOTRACE(("ALWAYS_ROLLBACK %p\n", pPager))
1.225        (danielk1 18-Dec-05):     pPager->alwaysRollback = 1;
1.225        (danielk1 18-Dec-05):   }
1.225        (danielk1 18-Dec-05): 
1.225        (danielk1 18-Dec-05):   /* Unlink the old page from the free list and the hash table
1.225        (danielk1 18-Dec-05):   */
1.225        (danielk1 18-Dec-05):   unlinkPage(pPg);
1.319        (drh      05-Apr-07):   assert( pPg->pgno==0 );
1.225        (danielk1 18-Dec-05): 
1.225        (danielk1 18-Dec-05):   *ppPg = pPg;
1.225        (danielk1 18-Dec-05):   return SQLITE_OK;
1.225        (danielk1 18-Dec-05): }
1.225        (danielk1 18-Dec-05): 
1.225        (danielk1 18-Dec-05): /*
1.225        (danielk1 18-Dec-05): ** This function is called to free superfluous dynamically allocated memory
1.225        (danielk1 18-Dec-05): ** held by the pager system. Memory in use by any SQLite pager allocated
1.225        (danielk1 18-Dec-05): ** by the current thread may be sqliteFree()ed.
1.225        (danielk1 18-Dec-05): **
1.225        (danielk1 18-Dec-05): ** nReq is the number of bytes of memory required. Once this much has
1.226        (danielk1 19-Dec-05): ** been released, the function returns. A negative value for nReq means
1.226        (danielk1 19-Dec-05): ** free as much memory as possible. The return value is the total number 
1.225        (danielk1 18-Dec-05): ** of bytes of memory released.
1.225        (danielk1 18-Dec-05): */
1.338        (drh      08-May-07): #if defined(SQLITE_ENABLE_MEMORY_MANAGEMENT) && !defined(SQLITE_OMIT_DISKIO)
1.292        (danielk1 19-Mar-07): int sqlite3PagerReleaseMemory(int nReq){
1.236        (drh      11-Jan-06):   const ThreadData *pTsdro = sqlite3ThreadDataReadOnly();
1.225        (danielk1 18-Dec-05):   int nReleased = 0;
1.225        (danielk1 18-Dec-05):   int i;
1.225        (danielk1 18-Dec-05): 
1.234        (drh      09-Jan-06):   /* If the the global mutex is held, this subroutine becomes a
1.234        (drh      09-Jan-06):   ** o-op; zero bytes of memory are freed.  This is because
1.234        (drh      09-Jan-06):   ** some of the code invoked by this function may also
1.234        (drh      09-Jan-06):   ** try to obtain the mutex, resulting in a deadlock.
1.230        (danielk1 05-Jan-06):   */
1.244        (drh      18-Jan-06):   if( sqlite3OsInMutex(0) ){
1.230        (danielk1 05-Jan-06):     return 0;
1.230        (danielk1 05-Jan-06):   }
1.230        (danielk1 05-Jan-06): 
1.225        (danielk1 18-Dec-05):   /* Outermost loop runs for at most two iterations. First iteration we
1.225        (danielk1 18-Dec-05):   ** try to find memory that can be released without calling fsync(). Second
1.225        (danielk1 18-Dec-05):   ** iteration (which only runs if the first failed to free nReq bytes of
1.225        (danielk1 18-Dec-05):   ** memory) is permitted to call fsync(). This is of course much more 
1.225        (danielk1 18-Dec-05):   ** expensive.
1.225        (danielk1 18-Dec-05):   */
1.234        (drh      09-Jan-06):   for(i=0; i<=1; i++){
1.225        (danielk1 18-Dec-05): 
1.225        (danielk1 18-Dec-05):     /* Loop through all the SQLite pagers opened by the current thread. */
1.322        (danielk1 05-Apr-07):     Pager *pPager = pTsdro->pPager;
1.322        (danielk1 05-Apr-07):     for( ; pPager && (nReq<0 || nReleased<nReq); pPager=pPager->pNext){
1.225        (danielk1 18-Dec-05):       PgHdr *pPg;
1.225        (danielk1 18-Dec-05):       int rc;
1.225        (danielk1 18-Dec-05): 
1.322        (danielk1 05-Apr-07):       if( MEMDB ){
1.321        (danielk1 05-Apr-07):         continue;
1.321        (danielk1 05-Apr-07):       }
1.321        (danielk1 05-Apr-07): 
1.225        (danielk1 18-Dec-05):       /* For each pager, try to free as many pages as possible (without 
1.225        (danielk1 18-Dec-05):       ** calling fsync() if this is the first iteration of the outermost 
1.225        (danielk1 18-Dec-05):       ** loop).
1.225        (danielk1 18-Dec-05):       */
1.322        (danielk1 05-Apr-07):       while( SQLITE_OK==(rc = pager_recycle(pPager, i, &pPg)) && pPg) {
1.229        (danielk1 30-Dec-05):         /* We've found a page to free. At this point the page has been 
1.225        (danielk1 18-Dec-05):         ** removed from the page hash-table, free-list and synced-list 
1.229        (danielk1 30-Dec-05):         ** (pFirstSynced). It is still in the all pages (pAll) list. 
1.225        (danielk1 18-Dec-05):         ** Remove it from this list before freeing.
1.225        (danielk1 18-Dec-05):         **
1.225        (danielk1 18-Dec-05):         ** Todo: Check the Pager.pStmt list to make sure this is Ok. It 
1.225        (danielk1 18-Dec-05):         ** probably is though.
1.225        (danielk1 18-Dec-05):         */
1.225        (danielk1 18-Dec-05):         PgHdr *pTmp;
1.226        (danielk1 19-Dec-05):         assert( pPg );
1.322        (danielk1 05-Apr-07):         if( pPg==pPager->pAll ){
1.322        (danielk1 05-Apr-07):            pPager->pAll = pPg->pNextAll;
1.225        (danielk1 18-Dec-05):         }else{
1.322        (danielk1 05-Apr-07):           for( pTmp=pPager->pAll; pTmp->pNextAll!=pPg; pTmp=pTmp->pNextAll ){}
1.225        (danielk1 18-Dec-05):           pTmp->pNextAll = pPg->pNextAll;
1.225        (danielk1 18-Dec-05):         }
1.225        (danielk1 18-Dec-05):         nReleased += sqliteAllocSize(pPg);
1.327        (drh      13-Apr-07):         IOTRACE(("PGFREE %p %d\n", pPager, pPg->pgno));
1.327        (drh      13-Apr-07):         PAGER_INCR(sqlite3_pager_pgfree_count);
1.225        (danielk1 18-Dec-05):         sqliteFree(pPg);
1.225        (danielk1 18-Dec-05):       }
1.225        (danielk1 18-Dec-05): 
1.225        (danielk1 18-Dec-05):       if( rc!=SQLITE_OK ){
1.229        (danielk1 30-Dec-05):         /* An error occured whilst writing to the database file or 
1.229        (danielk1 30-Dec-05):         ** journal in pager_recycle(). The error is not returned to the 
1.238        (danielk1 16-Jan-06):         ** caller of this function. Instead, set the Pager.errCode variable.
1.229        (danielk1 30-Dec-05):         ** The error will be returned to the user (or users, in the case 
1.229        (danielk1 30-Dec-05):         ** of a shared pager cache) of the pager for which the error occured.
1.225        (danielk1 18-Dec-05):         */
1.272        (drh      15-Sep-06):         assert( (rc&0xff)==SQLITE_IOERR || rc==SQLITE_FULL );
1.322        (danielk1 05-Apr-07):         assert( pPager->state>=PAGER_RESERVED );
1.322        (danielk1 05-Apr-07):         pager_error(pPager, rc);
1.225        (danielk1 18-Dec-05):       }
1.225        (danielk1 18-Dec-05):     }
1.225        (danielk1 18-Dec-05):   }
1.229        (danielk1 30-Dec-05): 
1.225        (danielk1 18-Dec-05):   return nReleased;
1.225        (danielk1 18-Dec-05): }
1.338        (drh      08-May-07): #endif /* SQLITE_ENABLE_MEMORY_MANAGEMENT && !SQLITE_OMIT_DISKIO */
1.225        (danielk1 18-Dec-05): 
1.194        (drh      15-Mar-05): /*
1.323        (danielk1 05-Apr-07): ** Read the content of page pPg out of the database file.
1.323        (danielk1 05-Apr-07): */
1.323        (danielk1 05-Apr-07): static int readDbPage(Pager *pPager, PgHdr *pPg, Pgno pgno){
1.323        (danielk1 05-Apr-07):   int rc;
1.323        (danielk1 05-Apr-07):   assert( MEMDB==0 );
1.323        (danielk1 05-Apr-07):   rc = sqlite3OsSeek(pPager->fd, (pgno-1)*(i64)pPager->pageSize);
1.323        (danielk1 05-Apr-07):   if( rc==SQLITE_OK ){
1.323        (danielk1 05-Apr-07):     rc = sqlite3OsRead(pPager->fd, PGHDR_TO_DATA(pPg),
1.323        (danielk1 05-Apr-07):                           pPager->pageSize);
1.323        (danielk1 05-Apr-07):   }
1.327        (drh      13-Apr-07):   PAGER_INCR(sqlite3_pager_readdb_count);
1.327        (drh      13-Apr-07):   PAGER_INCR(pPager->nRead);
1.327        (drh      13-Apr-07):   IOTRACE(("PGIN %p %d\n", pPager, pgno));
1.329        (drh      16-Apr-07):   if( pgno==1 ){
1.329        (drh      16-Apr-07):     memcpy(&pPager->dbFileVers, &((u8*)PGHDR_TO_DATA(pPg))[24],
1.329        (drh      16-Apr-07):                                               sizeof(pPager->dbFileVers));
1.329        (drh      16-Apr-07):   }
1.323        (danielk1 05-Apr-07):   CODEC1(pPager, PGHDR_TO_DATA(pPg), pPg->pgno, 3);
1.344        (drh      16-Jun-07):   PAGERTRACE4("FETCH %d page %d hash(%08x)\n",
1.344        (drh      16-Jun-07):                PAGERID(pPager), pPg->pgno, pager_pagehash(pPg));
1.323        (danielk1 05-Apr-07):   return rc;
1.323        (danielk1 05-Apr-07): }
1.323        (danielk1 05-Apr-07): 
1.323        (danielk1 05-Apr-07): 
1.323        (danielk1 05-Apr-07): /*
1.293        (danielk1 23-Mar-07): ** This function is called to obtain the shared lock required before
1.293        (danielk1 23-Mar-07): ** data may be read from the pager cache. If the shared lock has already
1.293        (danielk1 23-Mar-07): ** been obtained, this function is a no-op.
1.312        (danielk1 31-Mar-07): **
1.312        (danielk1 31-Mar-07): ** Immediately after obtaining the shared lock (if required), this function
1.312        (danielk1 31-Mar-07): ** checks for a hot-journal file. If one is found, an emergency rollback
1.312        (danielk1 31-Mar-07): ** is performed immediately.
1.293        (danielk1 23-Mar-07): */
1.293        (danielk1 23-Mar-07): static int pagerSharedLock(Pager *pPager){
1.293        (danielk1 23-Mar-07):   int rc = SQLITE_OK;
1.293        (danielk1 23-Mar-07): 
1.293        (danielk1 23-Mar-07):   if( pPager->state==PAGER_UNLOCK ){
1.293        (danielk1 23-Mar-07):     if( !MEMDB ){
1.293        (danielk1 23-Mar-07):       assert( pPager->nRef==0 );
1.293        (danielk1 23-Mar-07):       if( !pPager->noReadlock ){
1.293        (danielk1 23-Mar-07):         rc = pager_wait_on_lock(pPager, SHARED_LOCK);
1.293        (danielk1 23-Mar-07):         if( rc!=SQLITE_OK ){
1.293        (danielk1 23-Mar-07):           return pager_error(pPager, rc);
1.293        (danielk1 23-Mar-07):         }
1.293        (danielk1 23-Mar-07):         assert( pPager->state>=SHARED_LOCK );
1.293        (danielk1 23-Mar-07):       }
1.293        (danielk1 23-Mar-07):   
1.293        (danielk1 23-Mar-07):       /* If a journal file exists, and there is no RESERVED lock on the
1.293        (danielk1 23-Mar-07):       ** database file, then it either needs to be played back or deleted.
1.293        (danielk1 23-Mar-07):       */
1.293        (danielk1 23-Mar-07):       if( hasHotJournal(pPager) ){
1.293        (danielk1 23-Mar-07):         /* Get an EXCLUSIVE lock on the database file. At this point it is
1.293        (danielk1 23-Mar-07):         ** important that a RESERVED lock is not obtained on the way to the
1.293        (danielk1 23-Mar-07):         ** EXCLUSIVE lock. If it were, another process might open the
1.293        (danielk1 23-Mar-07):         ** database file, detect the RESERVED lock, and conclude that the
1.293        (danielk1 23-Mar-07):         ** database is safe to read while this process is still rolling it 
1.293        (danielk1 23-Mar-07):         ** back.
1.293        (danielk1 23-Mar-07):         ** 
1.293        (danielk1 23-Mar-07):         ** Because the intermediate RESERVED lock is not requested, the
1.293        (danielk1 23-Mar-07):         ** second process will get to this point in the code and fail to
1.293        (danielk1 23-Mar-07):         ** obtain it's own EXCLUSIVE lock on the database file.
1.293        (danielk1 23-Mar-07):         */
1.293        (danielk1 23-Mar-07):         rc = sqlite3OsLock(pPager->fd, EXCLUSIVE_LOCK);
1.293        (danielk1 23-Mar-07):         if( rc!=SQLITE_OK ){
1.293        (danielk1 23-Mar-07):           pager_unlock(pPager);
1.293        (danielk1 23-Mar-07):           return pager_error(pPager, rc);
1.293        (danielk1 23-Mar-07):         }
1.293        (danielk1 23-Mar-07):         pPager->state = PAGER_EXCLUSIVE;
1.293        (danielk1 23-Mar-07):  
1.293        (danielk1 23-Mar-07):         /* Open the journal for reading only.  Return SQLITE_BUSY if
1.293        (danielk1 23-Mar-07):         ** we are unable to open the journal file. 
1.293        (danielk1 23-Mar-07):         **
1.293        (danielk1 23-Mar-07):         ** The journal file does not need to be locked itself.  The
1.293        (danielk1 23-Mar-07):         ** journal file is never open unless the main database file holds
1.293        (danielk1 23-Mar-07):         ** a write lock, so there is never any chance of two or more
1.293        (danielk1 23-Mar-07):         ** processes opening the journal at the same time.
1.302        (danielk1 27-Mar-07):         **
1.352        (drh      07-Aug-07):         ** Open the journal for read/write access. This is because in 
1.352        (drh      07-Aug-07):         ** exclusive-access mode the file descriptor will be kept open and
1.302        (danielk1 27-Mar-07):         ** possibly used for a transaction later on. On some systems, the
1.302        (danielk1 27-Mar-07):         ** OsTruncate() call used in exclusive-access mode also requires
1.302        (danielk1 27-Mar-07):         ** a read/write file handle.
1.293        (danielk1 23-Mar-07):         */
1.302        (danielk1 27-Mar-07):         rc = SQLITE_BUSY;
1.302        (danielk1 27-Mar-07):         if( sqlite3OsFileExists(pPager->zJournal) ){
1.302        (danielk1 27-Mar-07):           int ro;
1.305        (danielk1 29-Mar-07):           assert( !pPager->tempFile );
1.302        (danielk1 27-Mar-07):           rc = sqlite3OsOpenReadWrite(pPager->zJournal, &pPager->jfd, &ro);
1.320        (danielk1 05-Apr-07):           assert( rc!=SQLITE_OK || pPager->jfd );
1.302        (danielk1 27-Mar-07):           if( ro ){
1.302        (danielk1 27-Mar-07):             rc = SQLITE_BUSY;
1.315        (danielk1 02-Apr-07):             sqlite3OsClose(&pPager->jfd);
1.302        (danielk1 27-Mar-07):           }
1.302        (danielk1 27-Mar-07):         }
1.293        (danielk1 23-Mar-07):         if( rc!=SQLITE_OK ){
1.293        (danielk1 23-Mar-07):           pager_unlock(pPager);
1.293        (danielk1 23-Mar-07):           return SQLITE_BUSY;
1.293        (danielk1 23-Mar-07):         }
1.293        (danielk1 23-Mar-07):         pPager->journalOpen = 1;
1.293        (danielk1 23-Mar-07):         pPager->journalStarted = 0;
1.293        (danielk1 23-Mar-07):         pPager->journalOff = 0;
1.293        (danielk1 23-Mar-07):         pPager->setMaster = 0;
1.293        (danielk1 23-Mar-07):         pPager->journalHdr = 0;
1.293        (danielk1 23-Mar-07):  
1.293        (danielk1 23-Mar-07):         /* Playback and delete the journal.  Drop the database write
1.293        (danielk1 23-Mar-07):         ** lock and reacquire the read lock.
1.293        (danielk1 23-Mar-07):         */
1.293        (danielk1 23-Mar-07):         rc = pager_playback(pPager, 1);
1.293        (danielk1 23-Mar-07):         if( rc!=SQLITE_OK ){
1.293        (danielk1 23-Mar-07):           return pager_error(pPager, rc);
1.293        (danielk1 23-Mar-07):         }
1.297        (danielk1 26-Mar-07):         assert(pPager->state==PAGER_SHARED || 
1.297        (danielk1 26-Mar-07):             (pPager->exclusiveMode && pPager->state>PAGER_SHARED)
1.297        (danielk1 26-Mar-07):         );
1.293        (danielk1 23-Mar-07):       }
1.293        (danielk1 23-Mar-07): 
1.293        (danielk1 23-Mar-07):       if( pPager->pAll ){
1.314        (danielk1 02-Apr-07):         /* The shared-lock has just been acquired on the database file
1.314        (danielk1 02-Apr-07):         ** and there are already pages in the cache (from a previous
1.329        (drh      16-Apr-07):         ** read or write transaction).  Check to see if the database
1.329        (drh      16-Apr-07):         ** has been modified.  If the database has changed, flush the
1.329        (drh      16-Apr-07):         ** cache.
1.329        (drh      16-Apr-07):         **
1.329        (drh      16-Apr-07):         ** Database changes is detected by looking at 15 bytes beginning
1.329        (drh      16-Apr-07):         ** at offset 24 into the file.  The first 4 of these 16 bytes are
1.329        (drh      16-Apr-07):         ** a 32-bit counter that is incremented with each change.  The
1.329        (drh      16-Apr-07):         ** other bytes change randomly with each file change when
1.329        (drh      16-Apr-07):         ** a codec is in use.
1.329        (drh      16-Apr-07):         ** 
1.329        (drh      16-Apr-07):         ** There is a vanishingly small chance that a change will not be 
1.340        (drh      09-May-07):         ** detected.  The chance of an undetected change is so small that
1.329        (drh      16-Apr-07):         ** it can be neglected.
1.314        (danielk1 02-Apr-07):         */
1.329        (drh      16-Apr-07):         char dbFileVers[sizeof(pPager->dbFileVers)];
1.323        (danielk1 05-Apr-07):         sqlite3PagerPagecount(pPager);
1.314        (danielk1 02-Apr-07): 
1.323        (danielk1 05-Apr-07):         if( pPager->errCode ){
1.323        (danielk1 05-Apr-07):           return pPager->errCode;
1.323        (danielk1 05-Apr-07):         }
1.323        (danielk1 05-Apr-07): 
1.323        (danielk1 05-Apr-07):         if( pPager->dbSize>0 ){
1.333        (drh      03-May-07):           IOTRACE(("CKVERS %p %d\n", pPager, sizeof(dbFileVers)));
1.323        (danielk1 05-Apr-07):           rc = sqlite3OsSeek(pPager->fd, 24);
1.323        (danielk1 05-Apr-07):           if( rc!=SQLITE_OK ){
1.323        (danielk1 05-Apr-07):             return rc;
1.323        (danielk1 05-Apr-07):           }
1.329        (drh      16-Apr-07):           rc = sqlite3OsRead(pPager->fd, &dbFileVers, sizeof(dbFileVers));
1.323        (danielk1 05-Apr-07):           if( rc!=SQLITE_OK ){
1.323        (danielk1 05-Apr-07):             return rc;
1.314        (danielk1 02-Apr-07):           }
1.329        (drh      16-Apr-07):         }else{
1.329        (drh      16-Apr-07):           memset(dbFileVers, 0, sizeof(dbFileVers));
1.293        (danielk1 23-Mar-07):         }
1.293        (danielk1 23-Mar-07): 
1.329        (drh      16-Apr-07):         if( memcmp(pPager->dbFileVers, dbFileVers, sizeof(dbFileVers))!=0 ){
1.323        (danielk1 05-Apr-07):           pager_reset(pPager);
1.293        (danielk1 23-Mar-07):         }
1.293        (danielk1 23-Mar-07):       }
1.293        (danielk1 23-Mar-07):     }
1.297        (danielk1 26-Mar-07):     assert( pPager->exclusiveMode || pPager->state<=PAGER_SHARED );
1.297        (danielk1 26-Mar-07):     if( pPager->state==PAGER_UNLOCK ){
1.297        (danielk1 26-Mar-07):       pPager->state = PAGER_SHARED;
1.297        (danielk1 26-Mar-07):     }
1.293        (danielk1 23-Mar-07):   }
1.293        (danielk1 23-Mar-07): 
1.293        (danielk1 23-Mar-07):   return rc;
1.293        (danielk1 23-Mar-07): }
1.293        (danielk1 23-Mar-07): 
1.293        (danielk1 23-Mar-07): /*
1.323        (danielk1 05-Apr-07): ** Allocate a PgHdr object.   Either create a new one or reuse
1.323        (danielk1 05-Apr-07): ** an existing one that is not otherwise in use.
1.323        (danielk1 05-Apr-07): **
1.323        (danielk1 05-Apr-07): ** A new PgHdr structure is created if any of the following are
1.323        (danielk1 05-Apr-07): ** true:
1.323        (danielk1 05-Apr-07): **
1.323        (danielk1 05-Apr-07): **     (1)  We have not exceeded our maximum allocated cache size
1.323        (danielk1 05-Apr-07): **          as set by the "PRAGMA cache_size" command.
1.323        (danielk1 05-Apr-07): **
1.323        (danielk1 05-Apr-07): **     (2)  There are no unused PgHdr objects available at this time.
1.323        (danielk1 05-Apr-07): **
1.323        (danielk1 05-Apr-07): **     (3)  This is an in-memory database.
1.323        (danielk1 05-Apr-07): **
1.323        (danielk1 05-Apr-07): **     (4)  There are no PgHdr objects that do not require a journal
1.323        (danielk1 05-Apr-07): **          file sync and a sync of the journal file is currently
1.323        (danielk1 05-Apr-07): **          prohibited.
1.323        (danielk1 05-Apr-07): **
1.323        (danielk1 05-Apr-07): ** Otherwise, reuse an existing PgHdr.  In other words, reuse an
1.323        (danielk1 05-Apr-07): ** existing PgHdr if all of the following are true:
1.323        (danielk1 05-Apr-07): **
1.323        (danielk1 05-Apr-07): **     (1)  We have reached or exceeded the maximum cache size
1.323        (danielk1 05-Apr-07): **          allowed by "PRAGMA cache_size".
1.323        (danielk1 05-Apr-07): **
1.323        (danielk1 05-Apr-07): **     (2)  There is a PgHdr available with PgHdr->nRef==0
1.323        (danielk1 05-Apr-07): **
1.323        (danielk1 05-Apr-07): **     (3)  We are not in an in-memory database
1.323        (danielk1 05-Apr-07): **
1.323        (danielk1 05-Apr-07): **     (4)  Either there is an available PgHdr that does not need
1.323        (danielk1 05-Apr-07): **          to be synced to disk or else disk syncing is currently
1.323        (danielk1 05-Apr-07): **          allowed.
1.314        (danielk1 02-Apr-07): */
1.314        (danielk1 02-Apr-07): static int pagerAllocatePage(Pager *pPager, PgHdr **ppPg){
1.314        (danielk1 02-Apr-07):   int rc = SQLITE_OK;
1.314        (danielk1 02-Apr-07):   PgHdr *pPg;
1.314        (danielk1 02-Apr-07): 
1.323        (danielk1 05-Apr-07):   /* Create a new PgHdr if any of the four conditions defined 
1.323        (danielk1 05-Apr-07):   ** above is met: */
1.323        (danielk1 05-Apr-07):   if( pPager->nPage<pPager->mxPage
1.323        (danielk1 05-Apr-07):    || pPager->pFirst==0 
1.323        (danielk1 05-Apr-07):    || MEMDB
1.323        (danielk1 05-Apr-07):    || (pPager->pFirstSynced==0 && pPager->doNotSync)
1.323        (danielk1 05-Apr-07):   ){
1.314        (danielk1 02-Apr-07):     if( pPager->nPage>=pPager->nHash ){
1.314        (danielk1 02-Apr-07):       pager_resize_hash_table(pPager,
1.314        (danielk1 02-Apr-07):          pPager->nHash<256 ? 256 : pPager->nHash*2);
1.314        (danielk1 02-Apr-07):       if( pPager->nHash==0 ){
1.314        (danielk1 02-Apr-07):         rc = SQLITE_NOMEM;
1.314        (danielk1 02-Apr-07):         goto pager_allocate_out;
1.314        (danielk1 02-Apr-07):       }
1.314        (danielk1 02-Apr-07):     }
1.314        (danielk1 02-Apr-07):     pPg = sqliteMallocRaw( sizeof(*pPg) + pPager->pageSize
1.314        (danielk1 02-Apr-07):                             + sizeof(u32) + pPager->nExtra
1.314        (danielk1 02-Apr-07):                             + MEMDB*sizeof(PgHistory) );
1.314        (danielk1 02-Apr-07):     if( pPg==0 ){
1.314        (danielk1 02-Apr-07):       rc = SQLITE_NOMEM;
1.314        (danielk1 02-Apr-07):       goto pager_allocate_out;
1.314        (danielk1 02-Apr-07):     }
1.314        (danielk1 02-Apr-07):     memset(pPg, 0, sizeof(*pPg));
1.314        (danielk1 02-Apr-07):     if( MEMDB ){
1.314        (danielk1 02-Apr-07):       memset(PGHDR_TO_HIST(pPg, pPager), 0, sizeof(PgHistory));
1.314        (danielk1 02-Apr-07):     }
1.314        (danielk1 02-Apr-07):     pPg->pPager = pPager;
1.314        (danielk1 02-Apr-07):     pPg->pNextAll = pPager->pAll;
1.314        (danielk1 02-Apr-07):     pPager->pAll = pPg;
1.314        (danielk1 02-Apr-07):     pPager->nPage++;
1.314        (danielk1 02-Apr-07):   }else{
1.314        (danielk1 02-Apr-07):     /* Recycle an existing page with a zero ref-count. */
1.314        (danielk1 02-Apr-07):     rc = pager_recycle(pPager, 1, &pPg);
1.343        (danielk1 13-Jun-07):     if( rc==SQLITE_BUSY ){
1.343        (danielk1 13-Jun-07):       rc = SQLITE_IOERR_BLOCKED;
1.343        (danielk1 13-Jun-07):     }
1.314        (danielk1 02-Apr-07):     if( rc!=SQLITE_OK ){
1.314        (danielk1 02-Apr-07):       goto pager_allocate_out;
1.314        (danielk1 02-Apr-07):     }
1.314        (danielk1 02-Apr-07):     assert( pPager->state>=SHARED_LOCK );
1.314        (danielk1 02-Apr-07):     assert(pPg);
1.314        (danielk1 02-Apr-07):   }
1.314        (danielk1 02-Apr-07):   *ppPg = pPg;
1.314        (danielk1 02-Apr-07): 
1.314        (danielk1 02-Apr-07): pager_allocate_out:
1.314        (danielk1 02-Apr-07):   return rc;
1.314        (danielk1 02-Apr-07): }
1.314        (danielk1 02-Apr-07): 
1.314        (danielk1 02-Apr-07): /*
1.330        (drh      26-Apr-07): ** Make sure we have the content for a page.  If the page was
1.330        (drh      26-Apr-07): ** previously acquired with noContent==1, then the content was
1.330        (drh      26-Apr-07): ** just initialized to zeros instead of being read from disk.
1.330        (drh      26-Apr-07): ** But now we need the real data off of disk.  So make sure we
1.330        (drh      26-Apr-07): ** have it.  Read it in if we do not have it already.
1.330        (drh      26-Apr-07): */
1.330        (drh      26-Apr-07): static int pager_get_content(PgHdr *pPg){
1.330        (drh      26-Apr-07):   if( pPg->needRead ){
1.330        (drh      26-Apr-07):     int rc = readDbPage(pPg->pPager, pPg, pPg->pgno);
1.330        (drh      26-Apr-07):     if( rc==SQLITE_OK ){
1.330        (drh      26-Apr-07):       pPg->needRead = 0;
1.330        (drh      26-Apr-07):     }else{
1.330        (drh      26-Apr-07):       return rc;
1.330        (drh      26-Apr-07):     }
1.330        (drh      26-Apr-07):   }
1.330        (drh      26-Apr-07):   return SQLITE_OK;
1.330        (drh      26-Apr-07): }
1.330        (drh      26-Apr-07): 
1.330        (drh      26-Apr-07): /*
1.3          (drh      15-Apr-01): ** Acquire a page.
1.3          (drh      15-Apr-01): **
1.30         (drh      10-Nov-01): ** A read lock on the disk file is obtained when the first page is acquired. 
1.14         (drh      13-Sep-01): ** This read lock is dropped when the last page is released.
1.3          (drh      15-Apr-01): **
1.330        (drh      26-Apr-07): ** This routine works for any page number greater than 0.  If the database
1.6          (drh      21-May-01): ** file is smaller than the requested page, then no actual disk
1.6          (drh      21-May-01): ** read occurs and the memory image of the page is initialized to
1.6          (drh      21-May-01): ** all zeros.  The extra data appended to a page is always initialized
1.6          (drh      21-May-01): ** to zeros the first time a page is loaded into memory.
1.6          (drh      21-May-01): **
1.3          (drh      15-Apr-01): ** The acquisition might fail for several reasons.  In all cases,
1.3          (drh      15-Apr-01): ** an appropriate error code is returned and *ppPage is set to NULL.
1.5          (drh      28-Apr-01): **
1.330        (drh      26-Apr-07): ** See also sqlite3PagerLookup().  Both this routine and Lookup() attempt
1.5          (drh      28-Apr-01): ** to find a page in the in-memory cache first.  If the page is not already
1.330        (drh      26-Apr-07): ** in memory, this routine goes to disk to read it in whereas Lookup()
1.5          (drh      28-Apr-01): ** just returns 0.  This routine acquires a read-lock the first time it
1.5          (drh      28-Apr-01): ** has to go to disk, and could also playback an old journal if necessary.
1.330        (drh      26-Apr-07): ** Since Lookup() never goes to disk, it never has to deal with locks
1.5          (drh      28-Apr-01): ** or journal files.
1.285        (drh      04-Mar-07): **
1.327        (drh      13-Apr-07): ** If noContent is false, the page contents are actually read from disk.
1.327        (drh      13-Apr-07): ** If noContent is true, it means that we do not care about the contents
1.327        (drh      13-Apr-07): ** of the page at this time, so do not do a disk read.  Just fill in the
1.327        (drh      13-Apr-07): ** page content with zeros.  But mark the fact that we have not read the
1.327        (drh      13-Apr-07): ** content by setting the PgHdr.needRead flag.  Later on, if 
1.330        (drh      26-Apr-07): ** sqlite3PagerWrite() is called on this page or if this routine is
1.330        (drh      26-Apr-07): ** called again with noContent==0, that means that the content is needed
1.330        (drh      26-Apr-07): ** and the disk read should occur at that point.
1.327        (drh      13-Apr-07): */
1.327        (drh      13-Apr-07): int sqlite3PagerAcquire(
1.327        (drh      13-Apr-07):   Pager *pPager,      /* The pager open on the database file */
1.327        (drh      13-Apr-07):   Pgno pgno,          /* Page number to fetch */
1.327        (drh      13-Apr-07):   DbPage **ppPage,    /* Write a pointer to the page here */
1.327        (drh      13-Apr-07):   int noContent       /* Do not bother reading content from disk if true */
1.327        (drh      13-Apr-07): ){
1.1          (drh      11-Apr-01):   PgHdr *pPg;
1.194        (drh      15-Mar-05):   int rc;
1.1          (drh      11-Apr-01): 
1.293        (danielk1 23-Mar-07):   assert( pPager->state==PAGER_UNLOCK || pPager->nRef>0 || pgno==1 );
1.293        (danielk1 23-Mar-07): 
1.183        (danielk1 17-Jan-05):   /* The maximum page number is 2^31. Return SQLITE_CORRUPT if a page
1.183        (danielk1 17-Jan-05):   ** number greater than this, or zero, is requested.
1.183        (danielk1 17-Jan-05):   */
1.214        (drh      16-Sep-05):   if( pgno>PAGER_MAX_PGNO || pgno==0 || pgno==PAGER_MJ_PGNO(pPager) ){
1.215        (drh      17-Sep-05):     return SQLITE_CORRUPT_BKPT;
1.183        (danielk1 17-Jan-05):   }
1.183        (danielk1 17-Jan-05): 
1.3          (drh      15-Apr-01):   /* Make sure we have not hit any critical errors.
1.3          (drh      15-Apr-01):   */ 
1.66         (drh      11-Jan-03):   assert( pPager!=0 );
1.83         (drh      25-Apr-03):   *ppPage = 0;
1.238        (danielk1 16-Jan-06):   if( pPager->errCode && pPager->errCode!=SQLITE_FULL ){
1.238        (danielk1 16-Jan-06):     return pPager->errCode;
1.3          (drh      15-Apr-01):   }
1.3          (drh      15-Apr-01): 
1.110        (danielk1 03-Jun-04):   /* If this is the first page accessed, then get a SHARED lock
1.295        (danielk1 26-Mar-07):   ** on the database file. pagerSharedLock() is a no-op if 
1.295        (danielk1 26-Mar-07):   ** a database lock is already held.
1.1          (drh      11-Apr-01):   */
1.293        (danielk1 23-Mar-07):   rc = pagerSharedLock(pPager);
1.293        (danielk1 23-Mar-07):   if( rc!=SQLITE_OK ){
1.293        (danielk1 23-Mar-07):     return rc;
1.293        (danielk1 23-Mar-07):   }
1.293        (danielk1 23-Mar-07):   assert( pPager->state!=PAGER_UNLOCK );
1.1          (drh      11-Apr-01): 
1.293        (danielk1 23-Mar-07):   pPg = pager_lookup(pPager, pgno);
1.1          (drh      11-Apr-01):   if( pPg==0 ){
1.3          (drh      15-Apr-01):     /* The requested page is not in the page cache. */
1.302        (danielk1 27-Mar-07):     int nMax;
1.1          (drh      11-Apr-01):     int h;
1.327        (drh      13-Apr-07):     PAGER_INCR(pPager->nMiss);
1.314        (danielk1 02-Apr-07):     rc = pagerAllocatePage(pPager, &pPg);
1.314        (danielk1 02-Apr-07):     if( rc!=SQLITE_OK ){
1.314        (danielk1 02-Apr-07):       return rc;
1.1          (drh      11-Apr-01):     }
1.314        (danielk1 02-Apr-07): 
1.1          (drh      11-Apr-01):     pPg->pgno = pgno;
1.325        (danielk1 07-Apr-07):     assert( !MEMDB || pgno>pPager->stmtSize );
1.36         (drh      14-Jan-02):     if( pPager->aInJournal && (int)pgno<=pPager->origDbSize ){
1.104        (danielk1 08-May-04):       sqlite3CheckMemory(pPager->aInJournal, pgno/8);
1.68         (drh      16-Jan-03):       assert( pPager->journalOpen );
1.13         (drh      02-Jul-01):       pPg->inJournal = (pPager->aInJournal[pgno/8] & (1<<(pgno&7)))!=0;
1.68         (drh      16-Jan-03):       pPg->needSync = 0;
1.13         (drh      02-Jul-01):     }else{
1.13         (drh      02-Jul-01):       pPg->inJournal = 0;
1.68         (drh      16-Jan-03):       pPg->needSync = 0;
1.13         (drh      02-Jul-01):     }
1.325        (danielk1 07-Apr-07): 
1.267        (drh      03-May-06):     makeClean(pPg);
1.1          (drh      11-Apr-01):     pPg->nRef = 1;
1.12         (drh      28-Jun-01):     REFINFO(pPg);
1.250        (danielk1 23-Jan-06): 
1.3          (drh      15-Apr-01):     pPager->nRef++;
1.83         (drh      25-Apr-03):     if( pPager->nExtra>0 ){
1.152        (drh      22-Jul-04):       memset(PGHDR_TO_EXTRA(pPg, pPager), 0, pPager->nExtra);
1.83         (drh      25-Apr-03):     }
1.302        (danielk1 27-Mar-07):     nMax = sqlite3PagerPagecount(pPager);
1.238        (danielk1 16-Jan-06):     if( pPager->errCode ){
1.292        (danielk1 19-Mar-07):       sqlite3PagerUnref(pPg);
1.238        (danielk1 16-Jan-06):       rc = pPager->errCode;
1.83         (drh      25-Apr-03):       return rc;
1.83         (drh      25-Apr-03):     }
1.250        (danielk1 23-Jan-06): 
1.250        (danielk1 23-Jan-06):     /* Populate the page with data, either by reading from the database
1.250        (danielk1 23-Jan-06):     ** file, or by setting the entire page to zero.
1.250        (danielk1 23-Jan-06):     */
1.328        (drh      13-Apr-07):     if( nMax<(int)pgno || MEMDB || (noContent && !pPager->alwaysRollback) ){
1.337        (drh      08-May-07):       if( pgno>pPager->mxPgno ){
1.339        (danielk1 09-May-07):         sqlite3PagerUnref(pPg);
1.337        (drh      08-May-07):         return SQLITE_FULL;
1.337        (drh      08-May-07):       }
1.152        (drh      22-Jul-04):       memset(PGHDR_TO_DATA(pPg), 0, pPager->pageSize);
1.328        (drh      13-Apr-07):       pPg->needRead = noContent && !pPager->alwaysRollback;
1.327        (drh      13-Apr-07):       IOTRACE(("ZERO %p %d\n", pPager, pgno));
1.6          (drh      21-May-01):     }else{
1.323        (danielk1 05-Apr-07):       rc = readDbPage(pPager, pPg, pgno);
1.275        (drh      06-Nov-06):       if( rc!=SQLITE_OK && rc!=SQLITE_IOERR_SHORT_READ ){
1.275        (drh      06-Nov-06):         pPg->pgno = 0;
1.292        (danielk1 19-Mar-07):         sqlite3PagerUnref(pPg);
1.275        (drh      06-Nov-06):         return rc;
1.27         (drh      12-Oct-01):       }
1.331        (danielk1 28-Apr-07):       pPg->needRead = 0;
1.6          (drh      21-May-01):     }
1.250        (danielk1 23-Jan-06): 
1.250        (danielk1 23-Jan-06):     /* Link the page into the page hash table */
1.268        (drh      07-May-06):     h = pgno & (pPager->nHash-1);
1.270        (drh      28-Jun-06):     assert( pgno!=0 );
1.250        (danielk1 23-Jan-06):     pPg->pNextHash = pPager->aHash[h];
1.250        (danielk1 23-Jan-06):     pPager->aHash[h] = pPg;
1.250        (danielk1 23-Jan-06):     if( pPg->pNextHash ){
1.250        (danielk1 23-Jan-06):       assert( pPg->pNextHash->pPrevHash==0 );
1.250        (danielk1 23-Jan-06):       pPg->pNextHash->pPrevHash = pPg;
1.250        (danielk1 23-Jan-06):     }
1.250        (danielk1 23-Jan-06): 
1.189        (danielk1 15-Feb-05): #ifdef SQLITE_CHECK_PAGES
1.189        (danielk1 15-Feb-05):     pPg->pageHash = pager_pagehash(pPg);
1.189        (danielk1 15-Feb-05): #endif
1.1          (drh      11-Apr-01):   }else{
1.3          (drh      15-Apr-01):     /* The requested page is in the page cache. */
1.293        (danielk1 23-Mar-07):     assert(pPager->nRef>0 || pgno==1);
1.327        (drh      13-Apr-07):     PAGER_INCR(pPager->nHit);
1.330        (drh      26-Apr-07):     if( !noContent ){
1.330        (drh      26-Apr-07):       rc = pager_get_content(pPg);
1.330        (drh      26-Apr-07):       if( rc ){
1.330        (drh      26-Apr-07):         return rc;
1.330        (drh      26-Apr-07):       }
1.330        (drh      26-Apr-07):     }
1.10         (drh      23-Jun-01):     page_ref(pPg);
1.1          (drh      11-Apr-01):   }
1.292        (danielk1 19-Mar-07):   *ppPage = pPg;
1.1          (drh      11-Apr-01):   return SQLITE_OK;
1.5          (drh      28-Apr-01): }
1.5          (drh      28-Apr-01): 
1.5          (drh      28-Apr-01): /*
1.5          (drh      28-Apr-01): ** Acquire a page if it is already in the in-memory cache.  Do
1.5          (drh      28-Apr-01): ** not read the page from disk.  Return a pointer to the page,
1.5          (drh      28-Apr-01): ** or 0 if the page is not in cache.
1.5          (drh      28-Apr-01): **
1.292        (danielk1 19-Mar-07): ** See also sqlite3PagerGet().  The difference between this routine
1.292        (danielk1 19-Mar-07): ** and sqlite3PagerGet() is that _get() will go to the disk and read
1.5          (drh      28-Apr-01): ** in the page if the page is not already in cache.  This routine
1.14         (drh      13-Sep-01): ** returns NULL if the page is not in cache or if a disk I/O error 
1.14         (drh      13-Sep-01): ** has ever happened.
1.5          (drh      28-Apr-01): */
1.292        (danielk1 19-Mar-07): DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno){
1.5          (drh      28-Apr-01):   PgHdr *pPg;
1.5          (drh      28-Apr-01): 
1.66         (drh      11-Jan-03):   assert( pPager!=0 );
1.66         (drh      11-Jan-03):   assert( pgno!=0 );
1.293        (danielk1 23-Mar-07): 
1.293        (danielk1 23-Mar-07):   if( pPager->state==PAGER_UNLOCK ){
1.295        (danielk1 26-Mar-07):     assert( !pPager->pAll || pPager->exclusiveMode );
1.293        (danielk1 23-Mar-07):     return 0;
1.293        (danielk1 23-Mar-07):   }
1.295        (danielk1 26-Mar-07):   if( pPager->errCode && pPager->errCode!=SQLITE_FULL ){
1.5          (drh      28-Apr-01):     return 0;
1.5          (drh      28-Apr-01):   }
1.5          (drh      28-Apr-01):   pPg = pager_lookup(pPager, pgno);
1.5          (drh      28-Apr-01):   if( pPg==0 ) return 0;
1.10         (drh      23-Jun-01):   page_ref(pPg);
1.292        (danielk1 19-Mar-07):   return pPg;
1.1          (drh      11-Apr-01): }
1.1          (drh      11-Apr-01): 
1.1          (drh      11-Apr-01): /*
1.1          (drh      11-Apr-01): ** Release a page.
1.1          (drh      11-Apr-01): **
1.1          (drh      11-Apr-01): ** If the number of references to the page drop to zero, then the
1.1          (drh      11-Apr-01): ** page is added to the LRU list.  When all references to all pages
1.3          (drh      15-Apr-01): ** are released, a rollback occurs and the lock on the database is
1.1          (drh      11-Apr-01): ** removed.
1.1          (drh      11-Apr-01): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerUnref(DbPage *pPg){
1.3          (drh      15-Apr-01): 
1.3          (drh      15-Apr-01):   /* Decrement the reference count for this page
1.3          (drh      15-Apr-01):   */
1.1          (drh      11-Apr-01):   assert( pPg->nRef>0 );
1.1          (drh      11-Apr-01):   pPg->nRef--;
1.12         (drh      28-Jun-01):   REFINFO(pPg);
1.3          (drh      15-Apr-01): 
1.189        (danielk1 15-Feb-05):   CHECK_PAGE(pPg);
1.189        (danielk1 15-Feb-05): 
1.7          (drh      24-May-01):   /* When the number of references to a page reach 0, call the
1.7          (drh      24-May-01):   ** destructor and add the page to the freelist.
1.3          (drh      15-Apr-01):   */
1.1          (drh      11-Apr-01):   if( pPg->nRef==0 ){
1.21         (drh      18-Sep-01):     Pager *pPager;
1.21         (drh      18-Sep-01):     pPager = pPg->pPager;
1.3          (drh      15-Apr-01):     pPg->pNextFree = 0;
1.3          (drh      15-Apr-01):     pPg->pPrevFree = pPager->pLast;
1.1          (drh      11-Apr-01):     pPager->pLast = pPg;
1.3          (drh      15-Apr-01):     if( pPg->pPrevFree ){
1.3          (drh      15-Apr-01):       pPg->pPrevFree->pNextFree = pPg;
1.1          (drh      11-Apr-01):     }else{
1.1          (drh      11-Apr-01):       pPager->pFirst = pPg;
1.7          (drh      24-May-01):     }
1.69         (drh      21-Jan-03):     if( pPg->needSync==0 && pPager->pFirstSynced==0 ){
1.69         (drh      21-Jan-03):       pPager->pFirstSynced = pPg;
1.69         (drh      21-Jan-03):     }
1.7          (drh      24-May-01):     if( pPager->xDestructor ){
1.292        (danielk1 19-Mar-07):       pPager->xDestructor(pPg, pPager->pageSize);
1.1          (drh      11-Apr-01):     }
1.3          (drh      15-Apr-01):   
1.3          (drh      15-Apr-01):     /* When all pages reach the freelist, drop the read lock from
1.3          (drh      15-Apr-01):     ** the database file.
1.3          (drh      15-Apr-01):     */
1.3          (drh      15-Apr-01):     pPager->nRef--;
1.3          (drh      15-Apr-01):     assert( pPager->nRef>=0 );
1.303        (danielk1 27-Mar-07):     if( pPager->nRef==0 && (!pPager->exclusiveMode || pPager->journalOff>0) ){
1.293        (danielk1 23-Mar-07):       pagerUnlockAndRollback(pPager);
1.3          (drh      15-Apr-01):     }
1.1          (drh      11-Apr-01):   }
1.3          (drh      15-Apr-01):   return SQLITE_OK;
1.1          (drh      11-Apr-01): }
1.1          (drh      11-Apr-01): 
1.1          (drh      11-Apr-01): /*
1.115        (drh      09-Jun-04): ** Create a journal file for pPager.  There should already be a RESERVED
1.115        (drh      09-Jun-04): ** or EXCLUSIVE lock on the database file when this routine is called.
1.60         (drh      02-Dec-02): **
1.60         (drh      02-Dec-02): ** Return SQLITE_OK if everything.  Return an error code and release the
1.60         (drh      02-Dec-02): ** write lock if anything goes wrong.
1.60         (drh      02-Dec-02): */
1.60         (drh      02-Dec-02): static int pager_open_journal(Pager *pPager){
1.60         (drh      02-Dec-02):   int rc;
1.169        (drh      31-Oct-04):   assert( !MEMDB );
1.115        (drh      09-Jun-04):   assert( pPager->state>=PAGER_RESERVED );
1.60         (drh      02-Dec-02):   assert( pPager->journalOpen==0 );
1.60         (drh      02-Dec-02):   assert( pPager->useJournal );
1.201        (drh      28-Mar-05):   assert( pPager->aInJournal==0 );
1.292        (danielk1 19-Mar-07):   sqlite3PagerPagecount(pPager);
1.60         (drh      02-Dec-02):   pPager->aInJournal = sqliteMalloc( pPager->dbSize/8 + 1 );
1.60         (drh      02-Dec-02):   if( pPager->aInJournal==0 ){
1.166        (drh      02-Oct-04):     rc = SQLITE_NOMEM;
1.166        (drh      02-Oct-04):     goto failed_to_open_journal;
1.60         (drh      02-Dec-02):   }
1.231        (drh      06-Jan-06):   rc = sqlite3OsOpenExclusive(pPager->zJournal, &pPager->jfd,
1.218        (drh      26-Nov-05):                                  pPager->tempFile);
1.320        (danielk1 05-Apr-07):   assert( rc!=SQLITE_OK || pPager->jfd );
1.138        (danielk1 25-Jun-04):   pPager->journalOff = 0;
1.138        (danielk1 25-Jun-04):   pPager->setMaster = 0;
1.138        (danielk1 25-Jun-04):   pPager->journalHdr = 0;
1.60         (drh      02-Dec-02):   if( rc!=SQLITE_OK ){
1.304        (drh      28-Mar-07):     if( rc==SQLITE_NOMEM ){
1.304        (drh      28-Mar-07):       sqlite3OsDelete(pPager->zJournal);
1.304        (drh      28-Mar-07):     }
1.166        (drh      02-Oct-04):     goto failed_to_open_journal;
1.60         (drh      02-Dec-02):   }
1.258        (drh      11-Feb-06):   sqlite3OsSetFullSync(pPager->jfd, pPager->full_fsync);
1.258        (drh      11-Feb-06):   sqlite3OsSetFullSync(pPager->fd, pPager->full_fsync);
1.222        (drh      30-Nov-05):   sqlite3OsOpenDirectory(pPager->jfd, pPager->zDirectory);
1.60         (drh      02-Dec-02):   pPager->journalOpen = 1;
1.68         (drh      16-Jan-03):   pPager->journalStarted = 0;
1.60         (drh      02-Dec-02):   pPager->needSync = 0;
1.60         (drh      02-Dec-02):   pPager->alwaysRollback = 0;
1.73         (drh      11-Feb-03):   pPager->nRec = 0;
1.238        (danielk1 16-Jan-06):   if( pPager->errCode ){
1.238        (danielk1 16-Jan-06):     rc = pPager->errCode;
1.199        (drh      28-Mar-05):     goto failed_to_open_journal;
1.83         (drh      25-Apr-03):   }
1.60         (drh      02-Dec-02):   pPager->origDbSize = pPager->dbSize;
1.116        (drh      09-Jun-04): 
1.138        (danielk1 25-Jun-04):   rc = writeJournalHdr(pPager);
1.138        (danielk1 25-Jun-04): 
1.107        (drh      12-May-04):   if( pPager->stmtAutoopen && rc==SQLITE_OK ){
1.292        (danielk1 19-Mar-07):     rc = sqlite3PagerStmtBegin(pPager);
1.60         (drh      02-Dec-02):   }
1.223        (danielk1 06-Dec-05):   if( rc!=SQLITE_OK && rc!=SQLITE_NOMEM ){
1.307        (drh      30-Mar-07):     rc = pager_end_transaction(pPager);
1.60         (drh      02-Dec-02):     if( rc==SQLITE_OK ){
1.60         (drh      02-Dec-02):       rc = SQLITE_FULL;
1.60         (drh      02-Dec-02):     }
1.60         (drh      02-Dec-02):   }
1.166        (drh      02-Oct-04):   return rc;
1.166        (drh      02-Oct-04): 
1.166        (drh      02-Oct-04): failed_to_open_journal:
1.166        (drh      02-Oct-04):   sqliteFree(pPager->aInJournal);
1.166        (drh      02-Oct-04):   pPager->aInJournal = 0;
1.166        (drh      02-Oct-04):   return rc;
1.60         (drh      02-Dec-02): }
1.60         (drh      02-Dec-02): 
1.60         (drh      02-Dec-02): /*
1.43         (drh      05-Mar-02): ** Acquire a write-lock on the database.  The lock is removed when
1.43         (drh      05-Mar-02): ** the any of the following happen:
1.43         (drh      05-Mar-02): **
1.307        (drh      30-Mar-07): **   *  sqlite3PagerCommitPhaseTwo() is called.
1.292        (danielk1 19-Mar-07): **   *  sqlite3PagerRollback() is called.
1.292        (danielk1 19-Mar-07): **   *  sqlite3PagerClose() is called.
1.292        (danielk1 19-Mar-07): **   *  sqlite3PagerUnref() is called to on every outstanding page.
1.43         (drh      05-Mar-02): **
1.110        (danielk1 03-Jun-04): ** The first parameter to this routine is a pointer to any open page of the
1.110        (danielk1 03-Jun-04): ** database file.  Nothing changes about the page - it is used merely to
1.110        (danielk1 03-Jun-04): ** acquire a pointer to the Pager structure and as proof that there is
1.110        (danielk1 03-Jun-04): ** already a read-lock on the database.
1.110        (danielk1 03-Jun-04): **
1.110        (danielk1 03-Jun-04): ** The second parameter indicates how much space in bytes to reserve for a
1.110        (danielk1 03-Jun-04): ** master journal file-name at the start of the journal when it is created.
1.110        (danielk1 03-Jun-04): **
1.110        (danielk1 03-Jun-04): ** A journal file is opened if this is not a temporary file.  For temporary
1.110        (danielk1 03-Jun-04): ** files, the opening of the journal file is deferred until there is an
1.110        (danielk1 03-Jun-04): ** actual need to write to the journal.
1.60         (drh      02-Dec-02): **
1.115        (drh      09-Jun-04): ** If the database is already reserved for writing, this routine is a no-op.
1.167        (drh      05-Oct-04): **
1.167        (drh      05-Oct-04): ** If exFlag is true, go ahead and get an EXCLUSIVE lock on the file
1.167        (drh      05-Oct-04): ** immediately instead of waiting until we try to flush the cache.  The
1.167        (drh      05-Oct-04): ** exFlag is ignored if a transaction is already active.
1.43         (drh      05-Mar-02): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerBegin(DbPage *pPg, int exFlag){
1.43         (drh      05-Mar-02):   Pager *pPager = pPg->pPager;
1.43         (drh      05-Mar-02):   int rc = SQLITE_OK;
1.43         (drh      05-Mar-02):   assert( pPg->nRef>0 );
1.115        (drh      09-Jun-04):   assert( pPager->state!=PAGER_UNLOCK );
1.115        (drh      09-Jun-04):   if( pPager->state==PAGER_SHARED ){
1.43         (drh      05-Mar-02):     assert( pPager->aInJournal==0 );
1.169        (drh      31-Oct-04):     if( MEMDB ){
1.115        (drh      09-Jun-04):       pPager->state = PAGER_EXCLUSIVE;
1.107        (drh      12-May-04):       pPager->origDbSize = pPager->dbSize;
1.107        (drh      12-May-04):     }else{
1.222        (drh      30-Nov-05):       rc = sqlite3OsLock(pPager->fd, RESERVED_LOCK);
1.167        (drh      05-Oct-04):       if( rc==SQLITE_OK ){
1.167        (drh      05-Oct-04):         pPager->state = PAGER_RESERVED;
1.167        (drh      05-Oct-04):         if( exFlag ){
1.167        (drh      05-Oct-04):           rc = pager_wait_on_lock(pPager, EXCLUSIVE_LOCK);
1.167        (drh      05-Oct-04):         }
1.167        (drh      05-Oct-04):       }
1.112        (danielk1 04-Jun-04):       if( rc!=SQLITE_OK ){
1.112        (danielk1 04-Jun-04):         return rc;
1.107        (drh      12-May-04):       }
1.115        (drh      09-Jun-04):       pPager->dirtyCache = 0;
1.300        (drh      26-Mar-07):       PAGERTRACE2("TRANSACTION %d\n", PAGERID(pPager));
1.107        (drh      12-May-04):       if( pPager->useJournal && !pPager->tempFile ){
1.107        (drh      12-May-04):         rc = pager_open_journal(pPager);
1.107        (drh      12-May-04):       }
1.43         (drh      05-Mar-02):     }
1.295        (danielk1 26-Mar-07):   }else if( pPager->journalOpen && pPager->journalOff==0 ){
1.295        (danielk1 26-Mar-07):     /* This happens when the pager was in exclusive-access mode last
1.295        (danielk1 26-Mar-07):     ** time a (read or write) transaction was successfully concluded
1.295        (danielk1 26-Mar-07):     ** by this connection. Instead of deleting the journal file it was 
1.295        (danielk1 26-Mar-07):     ** kept open and truncated to 0 bytes.
1.295        (danielk1 26-Mar-07):     */
1.295        (danielk1 26-Mar-07):     assert( pPager->nRec==0 );
1.295        (danielk1 26-Mar-07):     assert( pPager->origDbSize==0 );
1.309        (drh      30-Mar-07):     assert( pPager->aInJournal==0 );
1.295        (danielk1 26-Mar-07):     sqlite3PagerPagecount(pPager);
1.295        (danielk1 26-Mar-07):     pPager->aInJournal = sqliteMalloc( pPager->dbSize/8 + 1 );
1.295        (danielk1 26-Mar-07):     if( !pPager->aInJournal ){
1.295        (danielk1 26-Mar-07):       rc = SQLITE_NOMEM;
1.295        (danielk1 26-Mar-07):     }else{
1.309        (drh      30-Mar-07):       pPager->origDbSize = pPager->dbSize;
1.295        (danielk1 26-Mar-07):       rc = writeJournalHdr(pPager);
1.295        (danielk1 26-Mar-07):     }
1.43         (drh      05-Mar-02):   }
1.295        (danielk1 26-Mar-07):   assert( !pPager->journalOpen || pPager->journalOff>0 || rc!=SQLITE_OK );
1.43         (drh      05-Mar-02):   return rc;
1.43         (drh      05-Mar-02): }
1.43         (drh      05-Mar-02): 
1.43         (drh      05-Mar-02): /*
1.267        (drh      03-May-06): ** Make a page dirty.  Set its dirty flag and add it to the dirty
1.267        (drh      03-May-06): ** page list.
1.267        (drh      03-May-06): */
1.267        (drh      03-May-06): static void makeDirty(PgHdr *pPg){
1.267        (drh      03-May-06):   if( pPg->dirty==0 ){
1.267        (drh      03-May-06):     Pager *pPager = pPg->pPager;
1.267        (drh      03-May-06):     pPg->dirty = 1;
1.267        (drh      03-May-06):     pPg->pDirty = pPager->pDirty;
1.267        (drh      03-May-06):     if( pPager->pDirty ){
1.267        (drh      03-May-06):       pPager->pDirty->pPrevDirty = pPg;
1.267        (drh      03-May-06):     }
1.267        (drh      03-May-06):     pPg->pPrevDirty = 0;
1.267        (drh      03-May-06):     pPager->pDirty = pPg;
1.267        (drh      03-May-06):   }
1.267        (drh      03-May-06): }
1.267        (drh      03-May-06): 
1.267        (drh      03-May-06): /*
1.267        (drh      03-May-06): ** Make a page clean.  Clear its dirty bit and remove it from the
1.267        (drh      03-May-06): ** dirty page list.
1.267        (drh      03-May-06): */
1.267        (drh      03-May-06): static void makeClean(PgHdr *pPg){
1.267        (drh      03-May-06):   if( pPg->dirty ){
1.267        (drh      03-May-06):     pPg->dirty = 0;
1.267        (drh      03-May-06):     if( pPg->pDirty ){
1.267        (drh      03-May-06):       pPg->pDirty->pPrevDirty = pPg->pPrevDirty;
1.267        (drh      03-May-06):     }
1.267        (drh      03-May-06):     if( pPg->pPrevDirty ){
1.267        (drh      03-May-06):       pPg->pPrevDirty->pDirty = pPg->pDirty;
1.267        (drh      03-May-06):     }else{
1.267        (drh      03-May-06):       pPg->pPager->pDirty = pPg->pDirty;
1.267        (drh      03-May-06):     }
1.267        (drh      03-May-06):   }
1.267        (drh      03-May-06): }
1.267        (drh      03-May-06): 
1.267        (drh      03-May-06): 
1.267        (drh      03-May-06): /*
1.1          (drh      11-Apr-01): ** Mark a data page as writeable.  The page is written into the journal 
1.1          (drh      11-Apr-01): ** if it is not there already.  This routine must be called before making
1.1          (drh      11-Apr-01): ** changes to a page.
1.1          (drh      11-Apr-01): **
1.1          (drh      11-Apr-01): ** The first time this routine is called, the pager creates a new
1.115        (drh      09-Jun-04): ** journal and acquires a RESERVED lock on the database.  If the RESERVED
1.1          (drh      11-Apr-01): ** lock could not be acquired, this routine returns SQLITE_BUSY.  The
1.6          (drh      21-May-01): ** calling routine must check for that return value and be careful not to
1.1          (drh      11-Apr-01): ** change any page data until this routine returns SQLITE_OK.
1.3          (drh      15-Apr-01): **
1.3          (drh      15-Apr-01): ** If the journal file could not be written because the disk is full,
1.3          (drh      15-Apr-01): ** then this routine returns SQLITE_FULL and does an immediate rollback.
1.3          (drh      15-Apr-01): ** All subsequent write attempts also return SQLITE_FULL until there
1.292        (danielk1 19-Mar-07): ** is a call to sqlite3PagerCommit() or sqlite3PagerRollback() to
1.3          (drh      15-Apr-01): ** reset.
1.1          (drh      11-Apr-01): */
1.292        (danielk1 19-Mar-07): static int pager_write(PgHdr *pPg){
1.292        (danielk1 19-Mar-07):   void *pData = PGHDR_TO_DATA(pPg);
1.2          (drh      14-Apr-01):   Pager *pPager = pPg->pPager;
1.4          (drh      15-Apr-01):   int rc = SQLITE_OK;
1.2          (drh      14-Apr-01): 
1.34         (drh      15-Dec-01):   /* Check for errors
1.34         (drh      15-Dec-01):   */
1.238        (danielk1 16-Jan-06):   if( pPager->errCode ){ 
1.238        (danielk1 16-Jan-06):     return pPager->errCode;
1.3          (drh      15-Apr-01):   }
1.14         (drh      13-Sep-01):   if( pPager->readOnly ){
1.14         (drh      13-Sep-01):     return SQLITE_PERM;
1.14         (drh      13-Sep-01):   }
1.34         (drh      15-Dec-01): 
1.138        (danielk1 25-Jun-04):   assert( !pPager->setMaster );
1.138        (danielk1 25-Jun-04): 
1.189        (danielk1 15-Feb-05):   CHECK_PAGE(pPg);
1.189        (danielk1 15-Feb-05): 
1.327        (drh      13-Apr-07):   /* If this page was previously acquired with noContent==1, that means
1.327        (drh      13-Apr-07):   ** we didn't really read in the content of the page.  This can happen
1.327        (drh      13-Apr-07):   ** (for example) when the page is being moved to the freelist.  But
1.327        (drh      13-Apr-07):   ** now we are (perhaps) moving the page off of the freelist for
1.327        (drh      13-Apr-07):   ** reuse and we need to know its original content so that content
1.327        (drh      13-Apr-07):   ** can be stored in the rollback journal.  So do the read at this
1.327        (drh      13-Apr-07):   ** time.
1.327        (drh      13-Apr-07):   */
1.330        (drh      26-Apr-07):   rc = pager_get_content(pPg);
1.330        (drh      26-Apr-07):   if( rc ){
1.330        (drh      26-Apr-07):     return rc;
1.327        (drh      13-Apr-07):   }
1.327        (drh      13-Apr-07): 
1.34         (drh      15-Dec-01):   /* Mark the page as dirty.  If the page has already been written
1.34         (drh      15-Dec-01):   ** to the journal then we can return right away.
1.34         (drh      15-Dec-01):   */
1.267        (drh      03-May-06):   makeDirty(pPg);
1.325        (danielk1 07-Apr-07):   if( pPg->inJournal && (pageInStatement(pPg) || pPager->stmtInUse==0) ){
1.115        (drh      09-Jun-04):     pPager->dirtyCache = 1;
1.172        (danielk1 04-Nov-04):   }else{
1.34         (drh      15-Dec-01): 
1.172        (danielk1 04-Nov-04):     /* If we get this far, it means that the page needs to be
1.172        (danielk1 04-Nov-04):     ** written to the transaction journal or the ckeckpoint journal
1.172        (danielk1 04-Nov-04):     ** or both.
1.172        (danielk1 04-Nov-04):     **
1.172        (danielk1 04-Nov-04):     ** First check to see that the transaction journal exists and
1.172        (danielk1 04-Nov-04):     ** create it if it does not.
1.172        (danielk1 04-Nov-04):     */
1.172        (danielk1 04-Nov-04):     assert( pPager->state!=PAGER_UNLOCK );
1.292        (danielk1 19-Mar-07):     rc = sqlite3PagerBegin(pPg, 0);
1.172        (danielk1 04-Nov-04):     if( rc!=SQLITE_OK ){
1.172        (danielk1 04-Nov-04):       return rc;
1.172        (danielk1 04-Nov-04):     }
1.172        (danielk1 04-Nov-04):     assert( pPager->state>=PAGER_RESERVED );
1.172        (danielk1 04-Nov-04):     if( !pPager->journalOpen && pPager->useJournal ){
1.172        (danielk1 04-Nov-04):       rc = pager_open_journal(pPager);
1.172        (danielk1 04-Nov-04):       if( rc!=SQLITE_OK ) return rc;
1.172        (danielk1 04-Nov-04):     }
1.172        (danielk1 04-Nov-04):     assert( pPager->journalOpen || !pPager->useJournal );
1.172        (danielk1 04-Nov-04):     pPager->dirtyCache = 1;
1.172        (danielk1 04-Nov-04):   
1.172        (danielk1 04-Nov-04):     /* The transaction journal now exists and we have a RESERVED or an
1.172        (danielk1 04-Nov-04):     ** EXCLUSIVE lock on the main database file.  Write the current page to
1.172        (danielk1 04-Nov-04):     ** the transaction journal if it is not there already.
1.172        (danielk1 04-Nov-04):     */
1.172        (danielk1 04-Nov-04):     if( !pPg->inJournal && (pPager->useJournal || MEMDB) ){
1.172        (danielk1 04-Nov-04):       if( (int)pPg->pgno <= pPager->origDbSize ){
1.172        (danielk1 04-Nov-04):         int szPg;
1.172        (danielk1 04-Nov-04):         if( MEMDB ){
1.172        (danielk1 04-Nov-04):           PgHistory *pHist = PGHDR_TO_HIST(pPg, pPager);
1.300        (drh      26-Mar-07):           PAGERTRACE3("JOURNAL %d page %d\n", PAGERID(pPager), pPg->pgno);
1.172        (danielk1 04-Nov-04):           assert( pHist->pOrig==0 );
1.172        (danielk1 04-Nov-04):           pHist->pOrig = sqliteMallocRaw( pPager->pageSize );
1.172        (danielk1 04-Nov-04):           if( pHist->pOrig ){
1.172        (danielk1 04-Nov-04):             memcpy(pHist->pOrig, PGHDR_TO_DATA(pPg), pPager->pageSize);
1.172        (danielk1 04-Nov-04):           }
1.172        (danielk1 04-Nov-04):         }else{
1.261        (drh      06-Mar-06):           u32 cksum, saved;
1.261        (drh      06-Mar-06):           char *pData2, *pEnd;
1.214        (drh      16-Sep-05):           /* We should never write to the journal file the page that
1.214        (drh      16-Sep-05):           ** contains the database locks.  The following assert verifies
1.214        (drh      16-Sep-05):           ** that we do not. */
1.214        (drh      16-Sep-05):           assert( pPg->pgno!=PAGER_MJ_PGNO(pPager) );
1.261        (drh      06-Mar-06):           pData2 = CODEC2(pPager, pData, pPg->pgno, 7);
1.263        (drh      16-Mar-06):           cksum = pager_cksum(pPager, (u8*)pData2);
1.261        (drh      06-Mar-06):           pEnd = pData2 + pPager->pageSize;
1.261        (drh      06-Mar-06):           pData2 -= 4;
1.261        (drh      06-Mar-06):           saved = *(u32*)pEnd;
1.261        (drh      06-Mar-06):           put32bits(pEnd, cksum);
1.172        (danielk1 04-Nov-04):           szPg = pPager->pageSize+8;
1.261        (drh      06-Mar-06):           put32bits(pData2, pPg->pgno);
1.261        (drh      06-Mar-06):           rc = sqlite3OsWrite(pPager->jfd, pData2, szPg);
1.283        (drh      28-Feb-07):           IOTRACE(("JOUT %p %d %lld %d\n", pPager, pPg->pgno,
1.327        (drh      13-Apr-07):                    pPager->journalOff, szPg));
1.327        (drh      13-Apr-07):           PAGER_INCR(sqlite3_pager_writej_count);
1.172        (danielk1 04-Nov-04):           pPager->journalOff += szPg;
1.344        (drh      16-Jun-07):           PAGERTRACE5("JOURNAL %d page %d needSync=%d hash(%08x)\n",
1.344        (drh      16-Jun-07):                PAGERID(pPager), pPg->pgno, pPg->needSync, pager_pagehash(pPg));
1.261        (drh      06-Mar-06):           *(u32*)pEnd = saved;
1.246        (danielk1 20-Jan-06): 
1.352        (drh      07-Aug-07):           /* An error has occured writing to the journal file. The 
1.246        (danielk1 20-Jan-06):           ** transaction will be rolled back by the layer above.
1.246        (danielk1 20-Jan-06):           */
1.172        (danielk1 04-Nov-04):           if( rc!=SQLITE_OK ){
1.172        (danielk1 04-Nov-04):             return rc;
1.172        (danielk1 04-Nov-04):           }
1.246        (danielk1 20-Jan-06): 
1.172        (danielk1 04-Nov-04):           pPager->nRec++;
1.172        (danielk1 04-Nov-04):           assert( pPager->aInJournal!=0 );
1.172        (danielk1 04-Nov-04):           pPager->aInJournal[pPg->pgno/8] |= 1<<(pPg->pgno&7);
1.172        (danielk1 04-Nov-04):           pPg->needSync = !pPager->noSync;
1.172        (danielk1 04-Nov-04):           if( pPager->stmtInUse ){
1.172        (danielk1 04-Nov-04):             pPager->aInStmt[pPg->pgno/8] |= 1<<(pPg->pgno&7);
1.172        (danielk1 04-Nov-04):           }
1.172        (danielk1 04-Nov-04):         }
1.172        (danielk1 04-Nov-04):       }else{
1.172        (danielk1 04-Nov-04):         pPg->needSync = !pPager->journalStarted && !pPager->noSync;
1.300        (drh      26-Mar-07):         PAGERTRACE4("APPEND %d page %d needSync=%d\n",
1.174        (danielk1 06-Nov-04):                 PAGERID(pPager), pPg->pgno, pPg->needSync);
1.172        (danielk1 04-Nov-04):       }
1.172        (danielk1 04-Nov-04):       if( pPg->needSync ){
1.172        (danielk1 04-Nov-04):         pPager->needSync = 1;
1.172        (danielk1 04-Nov-04):       }
1.172        (danielk1 04-Nov-04):       pPg->inJournal = 1;
1.172        (danielk1 04-Nov-04):     }
1.172        (danielk1 04-Nov-04):   
1.172        (danielk1 04-Nov-04):     /* If the statement journal is open and the page is not in it,
1.172        (danielk1 04-Nov-04):     ** then write the current page to the statement journal.  Note that
1.172        (danielk1 04-Nov-04):     ** the statement journal format differs from the standard journal format
1.172        (danielk1 04-Nov-04):     ** in that it omits the checksums and the header.
1.172        (danielk1 04-Nov-04):     */
1.325        (danielk1 07-Apr-07):     if( pPager->stmtInUse 
1.325        (danielk1 07-Apr-07):      && !pageInStatement(pPg) 
1.325        (danielk1 07-Apr-07):      && (int)pPg->pgno<=pPager->stmtSize 
1.325        (danielk1 07-Apr-07):     ){
1.172        (danielk1 04-Nov-04):       assert( pPg->inJournal || (int)pPg->pgno>pPager->origDbSize );
1.169        (drh      31-Oct-04):       if( MEMDB ){
1.107        (drh      12-May-04):         PgHistory *pHist = PGHDR_TO_HIST(pPg, pPager);
1.172        (danielk1 04-Nov-04):         assert( pHist->pStmt==0 );
1.172        (danielk1 04-Nov-04):         pHist->pStmt = sqliteMallocRaw( pPager->pageSize );
1.172        (danielk1 04-Nov-04):         if( pHist->pStmt ){
1.172        (danielk1 04-Nov-04):           memcpy(pHist->pStmt, PGHDR_TO_DATA(pPg), pPager->pageSize);
1.107        (drh      12-May-04):         }
1.300        (drh      26-Mar-07):         PAGERTRACE3("STMT-JOURNAL %d page %d\n", PAGERID(pPager), pPg->pgno);
1.325        (danielk1 07-Apr-07):         page_add_to_stmt_list(pPg);
1.110        (danielk1 03-Jun-04):       }else{
1.261        (drh      06-Mar-06):         char *pData2 = CODEC2(pPager, pData, pPg->pgno, 7)-4;
1.261        (drh      06-Mar-06):         put32bits(pData2, pPg->pgno);
1.261        (drh      06-Mar-06):         rc = sqlite3OsWrite(pPager->stfd, pData2, pPager->pageSize+4);
1.300        (drh      26-Mar-07):         PAGERTRACE3("STMT-JOURNAL %d page %d\n", PAGERID(pPager), pPg->pgno);
1.107        (drh      12-May-04):         if( rc!=SQLITE_OK ){
1.107        (drh      12-May-04):           return rc;
1.107        (drh      12-May-04):         }
1.172        (danielk1 04-Nov-04):         pPager->stmtNRec++;
1.172        (danielk1 04-Nov-04):         assert( pPager->aInStmt!=0 );
1.172        (danielk1 04-Nov-04):         pPager->aInStmt[pPg->pgno/8] |= 1<<(pPg->pgno&7);
1.68         (drh      16-Jan-03):       }
1.37         (drh      02-Feb-02):     }
1.37         (drh      02-Feb-02):   }
1.37         (drh      02-Feb-02): 
1.37         (drh      02-Feb-02):   /* Update the database size and return.
1.34         (drh      15-Dec-01):   */
1.279        (drh      03-Jan-07):   assert( pPager->state>=PAGER_SHARED );
1.36         (drh      14-Jan-02):   if( pPager->dbSize<(int)pPg->pgno ){
1.6          (drh      21-May-01):     pPager->dbSize = pPg->pgno;
1.169        (drh      31-Oct-04):     if( !MEMDB && pPager->dbSize==PENDING_BYTE/pPager->pageSize ){
1.127        (drh      15-Jun-04):       pPager->dbSize++;
1.127        (drh      15-Jun-04):     }
1.6          (drh      21-May-01):   }
1.2          (drh      14-Apr-01):   return rc;
1.13         (drh      02-Jul-01): }
1.13         (drh      02-Jul-01): 
1.13         (drh      02-Jul-01): /*
1.290        (danielk1 19-Mar-07): ** This function is used to mark a data-page as writable. It uses 
1.290        (danielk1 19-Mar-07): ** pager_write() to open a journal file (if it is not already open)
1.290        (danielk1 19-Mar-07): ** and write the page *pData to the journal.
1.290        (danielk1 19-Mar-07): **
1.290        (danielk1 19-Mar-07): ** The difference between this function and pager_write() is that this
1.290        (danielk1 19-Mar-07): ** function also deals with the special case where 2 or more pages
1.290        (danielk1 19-Mar-07): ** fit on a single disk sector. In this case all co-resident pages
1.290        (danielk1 19-Mar-07): ** must have been written to the journal file before returning.
1.290        (danielk1 19-Mar-07): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerWrite(DbPage *pDbPage){
1.290        (danielk1 19-Mar-07):   int rc = SQLITE_OK;
1.290        (danielk1 19-Mar-07): 
1.292        (danielk1 19-Mar-07):   PgHdr *pPg = pDbPage;
1.290        (danielk1 19-Mar-07):   Pager *pPager = pPg->pPager;
1.290        (danielk1 19-Mar-07):   Pgno nPagePerSector = (pPager->sectorSize/pPager->pageSize);
1.290        (danielk1 19-Mar-07): 
1.290        (danielk1 19-Mar-07):   if( !MEMDB && nPagePerSector>1 ){
1.290        (danielk1 19-Mar-07):     Pgno nPageCount;          /* Total number of pages in database file */
1.290        (danielk1 19-Mar-07):     Pgno pg1;                 /* First page of the sector pPg is located on. */
1.290        (danielk1 19-Mar-07):     int nPage;                /* Number of pages starting at pg1 to journal */
1.290        (danielk1 19-Mar-07):     int ii;
1.290        (danielk1 19-Mar-07): 
1.290        (danielk1 19-Mar-07):     /* Set the doNotSync flag to 1. This is because we cannot allow a journal
1.290        (danielk1 19-Mar-07):     ** header to be written between the pages journaled by this function.
1.290        (danielk1 19-Mar-07):     */
1.290        (danielk1 19-Mar-07):     assert( pPager->doNotSync==0 );
1.290        (danielk1 19-Mar-07):     pPager->doNotSync = 1;
1.290        (danielk1 19-Mar-07): 
1.290        (danielk1 19-Mar-07):     /* This trick assumes that both the page-size and sector-size are
1.290        (danielk1 19-Mar-07):     ** an integer power of 2. It sets variable pg1 to the identifier
1.290        (danielk1 19-Mar-07):     ** of the first page of the sector pPg is located on.
1.290        (danielk1 19-Mar-07):     */
1.290        (danielk1 19-Mar-07):     pg1 = ((pPg->pgno-1) & ~(nPagePerSector-1)) + 1;
1.290        (danielk1 19-Mar-07): 
1.292        (danielk1 19-Mar-07):     nPageCount = sqlite3PagerPagecount(pPager);
1.290        (danielk1 19-Mar-07):     if( pPg->pgno>nPageCount ){
1.290        (danielk1 19-Mar-07):       nPage = (pPg->pgno - pg1)+1;
1.290        (danielk1 19-Mar-07):     }else if( (pg1+nPagePerSector-1)>nPageCount ){
1.290        (danielk1 19-Mar-07):       nPage = nPageCount+1-pg1;
1.290        (danielk1 19-Mar-07):     }else{
1.290        (danielk1 19-Mar-07):       nPage = nPagePerSector;
1.290        (danielk1 19-Mar-07):     }
1.290        (danielk1 19-Mar-07):     assert(nPage>0);
1.290        (danielk1 19-Mar-07):     assert(pg1<=pPg->pgno);
1.290        (danielk1 19-Mar-07):     assert((pg1+nPage)>pPg->pgno);
1.290        (danielk1 19-Mar-07): 
1.290        (danielk1 19-Mar-07):     for(ii=0; ii<nPage && rc==SQLITE_OK; ii++){
1.290        (danielk1 19-Mar-07):       Pgno pg = pg1+ii;
1.290        (danielk1 19-Mar-07):       if( !pPager->aInJournal || pg==pPg->pgno || 
1.290        (danielk1 19-Mar-07):           pg>pPager->origDbSize || !(pPager->aInJournal[pg/8]&(1<<(pg&7)))
1.290        (danielk1 19-Mar-07):       ) {
1.290        (danielk1 19-Mar-07):         if( pg!=PAGER_MJ_PGNO(pPager) ){
1.292        (danielk1 19-Mar-07):           PgHdr *pPage;
1.292        (danielk1 19-Mar-07):           rc = sqlite3PagerGet(pPager, pg, &pPage);
1.290        (danielk1 19-Mar-07):           if( rc==SQLITE_OK ){
1.290        (danielk1 19-Mar-07):             rc = pager_write(pPage);
1.292        (danielk1 19-Mar-07):             sqlite3PagerUnref(pPage);
1.290        (danielk1 19-Mar-07):           }
1.290        (danielk1 19-Mar-07):         }
1.290        (danielk1 19-Mar-07):       }
1.290        (danielk1 19-Mar-07):     }
1.290        (danielk1 19-Mar-07): 
1.290        (danielk1 19-Mar-07):     assert( pPager->doNotSync==1 );
1.290        (danielk1 19-Mar-07):     pPager->doNotSync = 0;
1.290        (danielk1 19-Mar-07):   }else{
1.292        (danielk1 19-Mar-07):     rc = pager_write(pDbPage);
1.290        (danielk1 19-Mar-07):   }
1.290        (danielk1 19-Mar-07):   return rc;
1.290        (danielk1 19-Mar-07): }
1.290        (danielk1 19-Mar-07): 
1.290        (danielk1 19-Mar-07): /*
1.35         (drh      06-Jan-02): ** Return TRUE if the page given in the argument was previously passed
1.292        (danielk1 19-Mar-07): ** to sqlite3PagerWrite().  In other words, return TRUE if it is ok
1.13         (drh      02-Jul-01): ** to change the content of the page.
1.13         (drh      02-Jul-01): */
1.254        (danielk1 23-Jan-06): #ifndef NDEBUG
1.292        (danielk1 19-Mar-07): int sqlite3PagerIswriteable(DbPage *pPg){
1.13         (drh      02-Jul-01):   return pPg->dirty;
1.79         (drh      19-Mar-03): }
1.254        (danielk1 23-Jan-06): #endif
1.79         (drh      19-Mar-03): 
1.184        (danielk1 20-Jan-05): #ifndef SQLITE_OMIT_VACUUM
1.79         (drh      19-Mar-03): /*
1.79         (drh      19-Mar-03): ** Replace the content of a single page with the information in the third
1.79         (drh      19-Mar-03): ** argument.
1.79         (drh      19-Mar-03): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerOverwrite(Pager *pPager, Pgno pgno, void *pData){
1.292        (danielk1 19-Mar-07):   PgHdr *pPg;
1.79         (drh      19-Mar-03):   int rc;
1.79         (drh      19-Mar-03): 
1.292        (danielk1 19-Mar-07):   rc = sqlite3PagerGet(pPager, pgno, &pPg);
1.79         (drh      19-Mar-03):   if( rc==SQLITE_OK ){
1.292        (danielk1 19-Mar-07):     rc = sqlite3PagerWrite(pPg);
1.79         (drh      19-Mar-03):     if( rc==SQLITE_OK ){
1.292        (danielk1 19-Mar-07):       memcpy(sqlite3PagerGetData(pPg), pData, pPager->pageSize);
1.79         (drh      19-Mar-03):     }
1.292        (danielk1 19-Mar-07):     sqlite3PagerUnref(pPg);
1.79         (drh      19-Mar-03):   }
1.79         (drh      19-Mar-03):   return rc;
1.41         (drh      02-Mar-02): }
1.184        (danielk1 20-Jan-05): #endif
1.41         (drh      02-Mar-02): 
1.41         (drh      02-Mar-02): /*
1.41         (drh      02-Mar-02): ** A call to this routine tells the pager that it is not necessary to
1.327        (drh      13-Apr-07): ** write the information on page pPg back to the disk, even though
1.41         (drh      02-Mar-02): ** that page might be marked as dirty.
1.41         (drh      02-Mar-02): **
1.41         (drh      02-Mar-02): ** The overlying software layer calls this routine when all of the data
1.41         (drh      02-Mar-02): ** on the given page is unused.  The pager marks the page as clean so
1.41         (drh      02-Mar-02): ** that it does not get written to disk.
1.41         (drh      02-Mar-02): **
1.41         (drh      02-Mar-02): ** Tests show that this optimization, together with the
1.292        (danielk1 19-Mar-07): ** sqlite3PagerDontRollback() below, more than double the speed
1.41         (drh      02-Mar-02): ** of large INSERT operations and quadruple the speed of large DELETEs.
1.48         (drh      06-Jul-02): **
1.48         (drh      06-Jul-02): ** When this routine is called, set the alwaysRollback flag to true.
1.292        (danielk1 19-Mar-07): ** Subsequent calls to sqlite3PagerDontRollback() for the same page
1.48         (drh      06-Jul-02): ** will thereafter be ignored.  This is necessary to avoid a problem
1.48         (drh      06-Jul-02): ** where a page with data is added to the freelist during one part of
1.48         (drh      06-Jul-02): ** a transaction then removed from the freelist during a later part
1.48         (drh      06-Jul-02): ** of the same transaction and reused for some other purpose.  When it
1.48         (drh      06-Jul-02): ** is first added to the freelist, this routine is called.  When reused,
1.307        (drh      30-Mar-07): ** the sqlite3PagerDontRollback() routine is called.  But because the
1.307        (drh      30-Mar-07): ** page contains critical data, we still need to be sure it gets
1.307        (drh      30-Mar-07): ** rolled back in spite of the sqlite3PagerDontRollback() call.
1.41         (drh      02-Mar-02): */
1.327        (drh      13-Apr-07): void sqlite3PagerDontWrite(DbPage *pDbPage){
1.327        (drh      13-Apr-07):   PgHdr *pPg = pDbPage;
1.327        (drh      13-Apr-07):   Pager *pPager = pPg->pPager;
1.48         (drh      06-Jul-02): 
1.169        (drh      31-Oct-04):   if( MEMDB ) return;
1.48         (drh      06-Jul-02):   pPg->alwaysRollback = 1;
1.262        (drh      06-Mar-06):   if( pPg->dirty && !pPager->stmtInUse ){
1.279        (drh      03-Jan-07):     assert( pPager->state>=PAGER_SHARED );
1.47         (drh      25-Jun-02):     if( pPager->dbSize==(int)pPg->pgno && pPager->origDbSize<pPager->dbSize ){
1.47         (drh      25-Jun-02):       /* If this pages is the last page in the file and the file has grown
1.47         (drh      25-Jun-02):       ** during the current transaction, then do NOT mark the page as clean.
1.47         (drh      25-Jun-02):       ** When the database file grows, we must make sure that the last page
1.47         (drh      25-Jun-02):       ** gets written at least once so that the disk file will be the correct
1.47         (drh      25-Jun-02):       ** size. If you do not write this page and the size of the file
1.47         (drh      25-Jun-02):       ** on the disk ends up being too small, that can lead to database
1.47         (drh      25-Jun-02):       ** corruption during the next transaction.
1.47         (drh      25-Jun-02):       */
1.47         (drh      25-Jun-02):     }else{
1.327        (drh      13-Apr-07):       PAGERTRACE3("DONT_WRITE page %d of %d\n", pPg->pgno, PAGERID(pPager));
1.327        (drh      13-Apr-07):       IOTRACE(("CLEAN %p %d\n", pPager, pPg->pgno))
1.267        (drh      03-May-06):       makeClean(pPg);
1.189        (danielk1 15-Feb-05): #ifdef SQLITE_CHECK_PAGES
1.189        (danielk1 15-Feb-05):       pPg->pageHash = pager_pagehash(pPg);
1.189        (danielk1 15-Feb-05): #endif
1.47         (drh      25-Jun-02):     }
1.41         (drh      02-Mar-02):   }
1.41         (drh      02-Mar-02): }
1.41         (drh      02-Mar-02): 
1.41         (drh      02-Mar-02): /*
1.41         (drh      02-Mar-02): ** A call to this routine tells the pager that if a rollback occurs,
1.41         (drh      02-Mar-02): ** it is not necessary to restore the data on the given page.  This
1.41         (drh      02-Mar-02): ** means that the pager does not have to record the given page in the
1.41         (drh      02-Mar-02): ** rollback journal.
1.327        (drh      13-Apr-07): **
1.327        (drh      13-Apr-07): ** If we have not yet actually read the content of this page (if
1.327        (drh      13-Apr-07): ** the PgHdr.needRead flag is set) then this routine acts as a promise
1.327        (drh      13-Apr-07): ** that we will never need to read the page content in the future.
1.327        (drh      13-Apr-07): ** so the needRead flag can be cleared at this point.
1.41         (drh      02-Mar-02): */
1.292        (danielk1 19-Mar-07): void sqlite3PagerDontRollback(DbPage *pPg){
1.41         (drh      02-Mar-02):   Pager *pPager = pPg->pPager;
1.41         (drh      02-Mar-02): 
1.277        (drh      18-Dec-06):   assert( pPager->state>=PAGER_RESERVED );
1.277        (drh      18-Dec-06):   if( pPager->journalOpen==0 ) return;
1.169        (drh      31-Oct-04):   if( pPg->alwaysRollback || pPager->alwaysRollback || MEMDB ) return;
1.41         (drh      02-Mar-02):   if( !pPg->inJournal && (int)pPg->pgno <= pPager->origDbSize ){
1.41         (drh      02-Mar-02):     assert( pPager->aInJournal!=0 );
1.41         (drh      02-Mar-02):     pPager->aInJournal[pPg->pgno/8] |= 1<<(pPg->pgno&7);
1.41         (drh      02-Mar-02):     pPg->inJournal = 1;
1.327        (drh      13-Apr-07):     pPg->needRead = 0;
1.107        (drh      12-May-04):     if( pPager->stmtInUse ){
1.107        (drh      12-May-04):       pPager->aInStmt[pPg->pgno/8] |= 1<<(pPg->pgno&7);
1.41         (drh      02-Mar-02):     }
1.300        (drh      26-Mar-07):     PAGERTRACE3("DONT_ROLLBACK page %d of %d\n", pPg->pgno, PAGERID(pPager));
1.283        (drh      28-Feb-07):     IOTRACE(("GARBAGE %p %d\n", pPager, pPg->pgno))
1.41         (drh      02-Mar-02):   }
1.325        (danielk1 07-Apr-07):   if( pPager->stmtInUse 
1.325        (danielk1 07-Apr-07):    && !pageInStatement(pPg) 
1.325        (danielk1 07-Apr-07):    && (int)pPg->pgno<=pPager->stmtSize 
1.325        (danielk1 07-Apr-07):   ){
1.41         (drh      02-Mar-02):     assert( pPg->inJournal || (int)pPg->pgno>pPager->origDbSize );
1.107        (drh      12-May-04):     assert( pPager->aInStmt!=0 );
1.107        (drh      12-May-04):     pPager->aInStmt[pPg->pgno/8] |= 1<<(pPg->pgno&7);
1.41         (drh      02-Mar-02):   }
1.1          (drh      11-Apr-01): }
1.1          (drh      11-Apr-01): 
1.107        (drh      12-May-04): 
1.1          (drh      11-Apr-01): /*
1.307        (drh      30-Mar-07): ** This routine is called to increment the database file change-counter,
1.307        (drh      30-Mar-07): ** stored at byte 24 of the pager file.
1.307        (drh      30-Mar-07): */
1.307        (drh      30-Mar-07): static int pager_incr_changecounter(Pager *pPager){
1.307        (drh      30-Mar-07):   PgHdr *pPgHdr;
1.307        (drh      30-Mar-07):   u32 change_counter;
1.307        (drh      30-Mar-07):   int rc;
1.307        (drh      30-Mar-07): 
1.307        (drh      30-Mar-07):   if( !pPager->changeCountDone ){
1.307        (drh      30-Mar-07):     /* Open page 1 of the file for writing. */
1.307        (drh      30-Mar-07):     rc = sqlite3PagerGet(pPager, 1, &pPgHdr);
1.307        (drh      30-Mar-07):     if( rc!=SQLITE_OK ) return rc;
1.307        (drh      30-Mar-07):     rc = sqlite3PagerWrite(pPgHdr);
1.307        (drh      30-Mar-07):     if( rc!=SQLITE_OK ) return rc;
1.307        (drh      30-Mar-07):   
1.307        (drh      30-Mar-07):     /* Increment the value just read and write it back to byte 24. */
1.351        (drh      20-Jul-07):     change_counter = sqlite3Get4byte((u8*)pPager->dbFileVers);
1.307        (drh      30-Mar-07):     change_counter++;
1.307        (drh      30-Mar-07):     put32bits(((char*)PGHDR_TO_DATA(pPgHdr))+24, change_counter);
1.307        (drh      30-Mar-07):     /* Release the page reference. */
1.307        (drh      30-Mar-07):     sqlite3PagerUnref(pPgHdr);
1.307        (drh      30-Mar-07):     pPager->changeCountDone = 1;
1.307        (drh      30-Mar-07):   }
1.307        (drh      30-Mar-07):   return SQLITE_OK;
1.307        (drh      30-Mar-07): }
1.307        (drh      30-Mar-07): 
1.307        (drh      30-Mar-07): /*
1.307        (drh      30-Mar-07): ** Sync the database file for the pager pPager. zMaster points to the name
1.307        (drh      30-Mar-07): ** of a master journal file that should be written into the individual
1.307        (drh      30-Mar-07): ** journal file. zMaster may be NULL, which is interpreted as no master
1.307        (drh      30-Mar-07): ** journal (a single database transaction).
1.307        (drh      30-Mar-07): **
1.307        (drh      30-Mar-07): ** This routine ensures that the journal is synced, all dirty pages written
1.307        (drh      30-Mar-07): ** to the database file and the database file synced. The only thing that
1.307        (drh      30-Mar-07): ** remains to commit the transaction is to delete the journal file (or
1.307        (drh      30-Mar-07): ** master journal file if specified).
1.307        (drh      30-Mar-07): **
1.307        (drh      30-Mar-07): ** Note that if zMaster==NULL, this does not overwrite a previous value
1.307        (drh      30-Mar-07): ** passed to an sqlite3PagerCommitPhaseOne() call.
1.307        (drh      30-Mar-07): **
1.307        (drh      30-Mar-07): ** If parameter nTrunc is non-zero, then the pager file is truncated to
1.307        (drh      30-Mar-07): ** nTrunc pages (this is used by auto-vacuum databases).
1.307        (drh      30-Mar-07): */
1.307        (drh      30-Mar-07): int sqlite3PagerCommitPhaseOne(Pager *pPager, const char *zMaster, Pgno nTrunc){
1.307        (drh      30-Mar-07):   int rc = SQLITE_OK;
1.307        (drh      30-Mar-07): 
1.307        (drh      30-Mar-07):   PAGERTRACE4("DATABASE SYNC: File=%s zMaster=%s nTrunc=%d\n", 
1.307        (drh      30-Mar-07):       pPager->zFilename, zMaster, nTrunc);
1.307        (drh      30-Mar-07): 
1.307        (drh      30-Mar-07):   /* If this is an in-memory db, or no pages have been written to, or this
1.307        (drh      30-Mar-07):   ** function has already been called, it is a no-op.
1.307        (drh      30-Mar-07):   */
1.307        (drh      30-Mar-07):   if( pPager->state!=PAGER_SYNCED && !MEMDB && pPager->dirtyCache ){
1.307        (drh      30-Mar-07):     PgHdr *pPg;
1.307        (drh      30-Mar-07):     assert( pPager->journalOpen );
1.307        (drh      30-Mar-07): 
1.307        (drh      30-Mar-07):     /* If a master journal file name has already been written to the
1.307        (drh      30-Mar-07):     ** journal file, then no sync is required. This happens when it is
1.307        (drh      30-Mar-07):     ** written, then the process fails to upgrade from a RESERVED to an
1.307        (drh      30-Mar-07):     ** EXCLUSIVE lock. The next time the process tries to commit the
1.307        (drh      30-Mar-07):     ** transaction the m-j name will have already been written.
1.307        (drh      30-Mar-07):     */
1.307        (drh      30-Mar-07):     if( !pPager->setMaster ){
1.307        (drh      30-Mar-07):       rc = pager_incr_changecounter(pPager);
1.307        (drh      30-Mar-07):       if( rc!=SQLITE_OK ) goto sync_exit;
1.307        (drh      30-Mar-07): #ifndef SQLITE_OMIT_AUTOVACUUM
1.307        (drh      30-Mar-07):       if( nTrunc!=0 ){
1.307        (drh      30-Mar-07):         /* If this transaction has made the database smaller, then all pages
1.307        (drh      30-Mar-07):         ** being discarded by the truncation must be written to the journal
1.307        (drh      30-Mar-07):         ** file.
1.307        (drh      30-Mar-07):         */
1.307        (drh      30-Mar-07):         Pgno i;
1.307        (drh      30-Mar-07):         int iSkip = PAGER_MJ_PGNO(pPager);
1.307        (drh      30-Mar-07):         for( i=nTrunc+1; i<=pPager->origDbSize; i++ ){
1.307        (drh      30-Mar-07):           if( !(pPager->aInJournal[i/8] & (1<<(i&7))) && i!=iSkip ){
1.307        (drh      30-Mar-07):             rc = sqlite3PagerGet(pPager, i, &pPg);
1.307        (drh      30-Mar-07):             if( rc!=SQLITE_OK ) goto sync_exit;
1.307        (drh      30-Mar-07):             rc = sqlite3PagerWrite(pPg);
1.307        (drh      30-Mar-07):             sqlite3PagerUnref(pPg);
1.307        (drh      30-Mar-07):             if( rc!=SQLITE_OK ) goto sync_exit;
1.307        (drh      30-Mar-07):           }
1.307        (drh      30-Mar-07):         } 
1.307        (drh      30-Mar-07):       }
1.307        (drh      30-Mar-07): #endif
1.307        (drh      30-Mar-07):       rc = writeMasterJournal(pPager, zMaster);
1.307        (drh      30-Mar-07):       if( rc!=SQLITE_OK ) goto sync_exit;
1.307        (drh      30-Mar-07):       rc = syncJournal(pPager);
1.307        (drh      30-Mar-07):       if( rc!=SQLITE_OK ) goto sync_exit;
1.307        (drh      30-Mar-07):     }
1.307        (drh      30-Mar-07): 
1.307        (drh      30-Mar-07): #ifndef SQLITE_OMIT_AUTOVACUUM
1.307        (drh      30-Mar-07):     if( nTrunc!=0 ){
1.307        (drh      30-Mar-07):       rc = sqlite3PagerTruncate(pPager, nTrunc);
1.307        (drh      30-Mar-07):       if( rc!=SQLITE_OK ) goto sync_exit;
1.307        (drh      30-Mar-07):     }
1.307        (drh      30-Mar-07): #endif
1.307        (drh      30-Mar-07): 
1.307        (drh      30-Mar-07):     /* Write all dirty pages to the database file */
1.307        (drh      30-Mar-07):     pPg = pager_get_all_dirty_pages(pPager);
1.307        (drh      30-Mar-07):     rc = pager_write_pagelist(pPg);
1.307        (drh      30-Mar-07):     if( rc!=SQLITE_OK ) goto sync_exit;
1.308        (drh      30-Mar-07):     pPager->pDirty = 0;
1.307        (drh      30-Mar-07): 
1.307        (drh      30-Mar-07):     /* Sync the database file. */
1.307        (drh      30-Mar-07):     if( !pPager->noSync ){
1.307        (drh      30-Mar-07):       rc = sqlite3OsSync(pPager->fd, 0);
1.307        (drh      30-Mar-07):     }
1.307        (drh      30-Mar-07):     IOTRACE(("DBSYNC %p\n", pPager))
1.307        (drh      30-Mar-07): 
1.307        (drh      30-Mar-07):     pPager->state = PAGER_SYNCED;
1.307        (drh      30-Mar-07):   }else if( MEMDB && nTrunc!=0 ){
1.307        (drh      30-Mar-07):     rc = sqlite3PagerTruncate(pPager, nTrunc);
1.307        (drh      30-Mar-07):   }
1.307        (drh      30-Mar-07): 
1.307        (drh      30-Mar-07): sync_exit:
1.343        (danielk1 13-Jun-07):   if( rc==SQLITE_IOERR_BLOCKED ){
1.343        (danielk1 13-Jun-07):     /* pager_incr_changecounter() may attempt to obtain an exclusive
1.343        (danielk1 13-Jun-07):      * lock to spill the cache and return IOERR_BLOCKED. But since 
1.343        (danielk1 13-Jun-07):      * there is no chance the cache is inconsistent, it's
1.343        (danielk1 13-Jun-07):      * better to return SQLITE_BUSY.
1.343        (danielk1 13-Jun-07):      */
1.343        (danielk1 13-Jun-07):     rc = SQLITE_BUSY;
1.343        (danielk1 13-Jun-07):   }
1.307        (drh      30-Mar-07):   return rc;
1.307        (drh      30-Mar-07): }
1.307        (drh      30-Mar-07): 
1.307        (drh      30-Mar-07): 
1.307        (drh      30-Mar-07): /*
1.1          (drh      11-Apr-01): ** Commit all changes to the database and release the write lock.
1.3          (drh      15-Apr-01): **
1.3          (drh      15-Apr-01): ** If the commit fails for any reason, a rollback attempt is made
1.3          (drh      15-Apr-01): ** and an error code is returned.  If the commit worked, SQLITE_OK
1.3          (drh      15-Apr-01): ** is returned.
1.1          (drh      11-Apr-01): */
1.307        (drh      30-Mar-07): int sqlite3PagerCommitPhaseTwo(Pager *pPager){
1.17         (drh      14-Sep-01):   int rc;
1.1          (drh      11-Apr-01):   PgHdr *pPg;
1.3          (drh      15-Apr-01): 
1.238        (danielk1 16-Jan-06):   if( pPager->errCode ){
1.251        (danielk1 23-Jan-06):     return pPager->errCode;
1.3          (drh      15-Apr-01):   }
1.115        (drh      09-Jun-04):   if( pPager->state<PAGER_RESERVED ){
1.3          (drh      15-Apr-01):     return SQLITE_ERROR;
1.3          (drh      15-Apr-01):   }
1.300        (drh      26-Mar-07):   PAGERTRACE2("COMMIT %d\n", PAGERID(pPager));
1.169        (drh      31-Oct-04):   if( MEMDB ){
1.107        (drh      12-May-04):     pPg = pager_get_all_dirty_pages(pPager);
1.107        (drh      12-May-04):     while( pPg ){
1.325        (danielk1 07-Apr-07):       PgHistory *pHist = PGHDR_TO_HIST(pPg, pPager);
1.325        (danielk1 07-Apr-07):       clearHistory(pHist);
1.107        (drh      12-May-04):       pPg->dirty = 0;
1.107        (drh      12-May-04):       pPg->inJournal = 0;
1.325        (danielk1 07-Apr-07):       pHist->inStmt = 0;
1.264        (drh      23-Mar-06):       pPg->needSync = 0;
1.325        (danielk1 07-Apr-07):       pHist->pPrevStmt = pHist->pNextStmt = 0;
1.107        (drh      12-May-04):       pPg = pPg->pDirty;
1.107        (drh      12-May-04):     }
1.267        (drh      03-May-06):     pPager->pDirty = 0;
1.129        (danielk1 16-Jun-04): #ifndef NDEBUG
1.129        (danielk1 16-Jun-04):     for(pPg=pPager->pAll; pPg; pPg=pPg->pNextAll){
1.129        (danielk1 16-Jun-04):       PgHistory *pHist = PGHDR_TO_HIST(pPg, pPager);
1.129        (danielk1 16-Jun-04):       assert( !pPg->alwaysRollback );
1.129        (danielk1 16-Jun-04):       assert( !pHist->pOrig );
1.129        (danielk1 16-Jun-04):       assert( !pHist->pStmt );
1.129        (danielk1 16-Jun-04):     }
1.129        (danielk1 16-Jun-04): #endif
1.107        (drh      12-May-04):     pPager->pStmt = 0;
1.115        (drh      09-Jun-04):     pPager->state = PAGER_SHARED;
1.107        (drh      12-May-04):     return SQLITE_OK;
1.107        (drh      12-May-04):   }
1.308        (drh      30-Mar-07):   assert( pPager->journalOpen || !pPager->dirtyCache );
1.308        (drh      30-Mar-07):   assert( pPager->state==PAGER_SYNCED || !pPager->dirtyCache );
1.308        (drh      30-Mar-07):   rc = pager_end_transaction(pPager);
1.302        (danielk1 27-Mar-07):   return pager_error(pPager, rc);
1.1          (drh      11-Apr-01): }
1.1          (drh      11-Apr-01): 
1.1          (drh      11-Apr-01): /*
1.115        (drh      09-Jun-04): ** Rollback all changes.  The database falls back to PAGER_SHARED mode.
1.1          (drh      11-Apr-01): ** All in-memory cache pages revert to their original data contents.
1.1          (drh      11-Apr-01): ** The journal is deleted.
1.3          (drh      15-Apr-01): **
1.3          (drh      15-Apr-01): ** This routine cannot fail unless some other process is not following
1.311        (drh      30-Mar-07): ** the correct locking protocol or unless some other
1.3          (drh      15-Apr-01): ** process is writing trash into the journal file (SQLITE_CORRUPT) or
1.3          (drh      15-Apr-01): ** unless a prior malloc() failed (SQLITE_NOMEM).  Appropriate error
1.3          (drh      15-Apr-01): ** codes are returned for all these occasions.  Otherwise,
1.3          (drh      15-Apr-01): ** SQLITE_OK is returned.
1.1          (drh      11-Apr-01): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerRollback(Pager *pPager){
1.1          (drh      11-Apr-01):   int rc;
1.300        (drh      26-Mar-07):   PAGERTRACE2("ROLLBACK %d\n", PAGERID(pPager));
1.169        (drh      31-Oct-04):   if( MEMDB ){
1.107        (drh      12-May-04):     PgHdr *p;
1.107        (drh      12-May-04):     for(p=pPager->pAll; p; p=p->pNextAll){
1.107        (drh      12-May-04):       PgHistory *pHist;
1.129        (danielk1 16-Jun-04):       assert( !p->alwaysRollback );
1.129        (danielk1 16-Jun-04):       if( !p->dirty ){
1.129        (danielk1 16-Jun-04):         assert( !((PgHistory *)PGHDR_TO_HIST(p, pPager))->pOrig );
1.129        (danielk1 16-Jun-04):         assert( !((PgHistory *)PGHDR_TO_HIST(p, pPager))->pStmt );
1.129        (danielk1 16-Jun-04):         continue;
1.129        (danielk1 16-Jun-04):       }
1.129        (danielk1 16-Jun-04): 
1.107        (drh      12-May-04):       pHist = PGHDR_TO_HIST(p, pPager);
1.107        (drh      12-May-04):       if( pHist->pOrig ){
1.107        (drh      12-May-04):         memcpy(PGHDR_TO_DATA(p), pHist->pOrig, pPager->pageSize);
1.300        (drh      26-Mar-07):         PAGERTRACE3("ROLLBACK-PAGE %d of %d\n", p->pgno, PAGERID(pPager));
1.107        (drh      12-May-04):       }else{
1.300        (drh      26-Mar-07):         PAGERTRACE3("PAGE %d is clean on %d\n", p->pgno, PAGERID(pPager));
1.107        (drh      12-May-04):       }
1.107        (drh      12-May-04):       clearHistory(pHist);
1.107        (drh      12-May-04):       p->dirty = 0;
1.107        (drh      12-May-04):       p->inJournal = 0;
1.325        (danielk1 07-Apr-07):       pHist->inStmt = 0;
1.325        (danielk1 07-Apr-07):       pHist->pPrevStmt = pHist->pNextStmt = 0;
1.128        (danielk1 15-Jun-04):       if( pPager->xReiniter ){
1.292        (danielk1 19-Mar-07):         pPager->xReiniter(p, pPager->pageSize);
1.128        (danielk1 15-Jun-04):       }
1.107        (drh      12-May-04):     }
1.267        (drh      03-May-06):     pPager->pDirty = 0;
1.107        (drh      12-May-04):     pPager->pStmt = 0;
1.107        (drh      12-May-04):     pPager->dbSize = pPager->origDbSize;
1.323        (danielk1 05-Apr-07):     pager_truncate_cache(pPager);
1.107        (drh      12-May-04):     pPager->stmtInUse = 0;
1.115        (drh      09-Jun-04):     pPager->state = PAGER_SHARED;
1.107        (drh      12-May-04):     return SQLITE_OK;
1.107        (drh      12-May-04):   }
1.107        (drh      12-May-04): 
1.115        (drh      09-Jun-04):   if( !pPager->dirtyCache || !pPager->journalOpen ){
1.307        (drh      30-Mar-07):     rc = pager_end_transaction(pPager);
1.60         (drh      02-Dec-02):     return rc;
1.60         (drh      02-Dec-02):   }
1.68         (drh      16-Jan-03): 
1.238        (danielk1 16-Jan-06):   if( pPager->errCode && pPager->errCode!=SQLITE_FULL ){
1.115        (drh      09-Jun-04):     if( pPager->state>=PAGER_EXCLUSIVE ){
1.293        (danielk1 23-Mar-07):       pager_playback(pPager, 0);
1.43         (drh      05-Mar-02):     }
1.238        (danielk1 16-Jan-06):     return pPager->errCode;
1.3          (drh      15-Apr-01):   }
1.115        (drh      09-Jun-04):   if( pPager->state==PAGER_RESERVED ){
1.190        (danielk1 15-Feb-05):     int rc2;
1.293        (danielk1 23-Mar-07):     rc = pager_playback(pPager, 0);
1.307        (drh      30-Mar-07):     rc2 = pager_end_transaction(pPager);
1.115        (drh      09-Jun-04):     if( rc==SQLITE_OK ){
1.115        (drh      09-Jun-04):       rc = rc2;
1.115        (drh      09-Jun-04):     }
1.115        (drh      09-Jun-04):   }else{
1.293        (danielk1 23-Mar-07):     rc = pager_playback(pPager, 0);
1.3          (drh      15-Apr-01):   }
1.323        (danielk1 05-Apr-07):   /* pager_reset(pPager); */
1.3          (drh      15-Apr-01):   pPager->dbSize = -1;
1.246        (danielk1 20-Jan-06): 
1.246        (danielk1 20-Jan-06):   /* If an error occurs during a ROLLBACK, we can no longer trust the pager
1.246        (danielk1 20-Jan-06):   ** cache. So call pager_error() on the way out to make any error 
1.246        (danielk1 20-Jan-06):   ** persistent.
1.246        (danielk1 20-Jan-06):   */
1.246        (danielk1 20-Jan-06):   return pager_error(pPager, rc);
1.28         (drh      18-Oct-01): }
1.14         (drh      13-Sep-01): 
1.14         (drh      13-Sep-01): /*
1.14         (drh      13-Sep-01): ** Return TRUE if the database file is opened read-only.  Return FALSE
1.14         (drh      13-Sep-01): ** if the database is (in theory) writable.
1.14         (drh      13-Sep-01): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerIsreadonly(Pager *pPager){
1.15         (drh      13-Sep-01):   return pPager->readOnly;
1.14         (drh      13-Sep-01): }
1.3          (drh      15-Apr-01): 
1.3          (drh      15-Apr-01): /*
1.271        (drh      08-Aug-06): ** Return the number of references to the pager.
1.271        (drh      08-Aug-06): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerRefcount(Pager *pPager){
1.271        (drh      08-Aug-06):   return pPager->nRef;
1.271        (drh      08-Aug-06): }
1.271        (drh      08-Aug-06): 
1.271        (drh      08-Aug-06): #ifdef SQLITE_TEST
1.271        (drh      08-Aug-06): /*
1.3          (drh      15-Apr-01): ** This routine is used for testing and analysis only.
1.3          (drh      15-Apr-01): */
1.292        (danielk1 19-Mar-07): int *sqlite3PagerStats(Pager *pPager){
1.180        (danielk1 08-Jan-05):   static int a[11];
1.3          (drh      15-Apr-01):   a[0] = pPager->nRef;
1.3          (drh      15-Apr-01):   a[1] = pPager->nPage;
1.3          (drh      15-Apr-01):   a[2] = pPager->mxPage;
1.3          (drh      15-Apr-01):   a[3] = pPager->dbSize;
1.3          (drh      15-Apr-01):   a[4] = pPager->state;
1.238        (danielk1 16-Jan-06):   a[5] = pPager->errCode;
1.3          (drh      15-Apr-01):   a[6] = pPager->nHit;
1.3          (drh      15-Apr-01):   a[7] = pPager->nMiss;
1.319        (drh      05-Apr-07):   a[8] = 0;  /* Used to be pPager->nOvfl */
1.180        (danielk1 08-Jan-05):   a[9] = pPager->nRead;
1.180        (danielk1 08-Jan-05):   a[10] = pPager->nWrite;
1.3          (drh      15-Apr-01):   return a;
1.37         (drh      02-Feb-02): }
1.271        (drh      08-Aug-06): #endif
1.37         (drh      02-Feb-02): 
1.37         (drh      02-Feb-02): /*
1.107        (drh      12-May-04): ** Set the statement rollback point.
1.37         (drh      02-Feb-02): **
1.37         (drh      02-Feb-02): ** This routine should be called with the transaction journal already
1.107        (drh      12-May-04): ** open.  A new statement journal is created that can be used to rollback
1.40         (drh      19-Feb-02): ** changes of a single SQL command within a larger transaction.
1.37         (drh      02-Feb-02): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerStmtBegin(Pager *pPager){
1.37         (drh      02-Feb-02):   int rc;
1.107        (drh      12-May-04):   assert( !pPager->stmtInUse );
1.279        (drh      03-Jan-07):   assert( pPager->state>=PAGER_SHARED );
1.155        (drh      18-Aug-04):   assert( pPager->dbSize>=0 );
1.300        (drh      26-Mar-07):   PAGERTRACE2("STMT-BEGIN %d\n", PAGERID(pPager));
1.169        (drh      31-Oct-04):   if( MEMDB ){
1.107        (drh      12-May-04):     pPager->stmtInUse = 1;
1.107        (drh      12-May-04):     pPager->stmtSize = pPager->dbSize;
1.107        (drh      12-May-04):     return SQLITE_OK;
1.107        (drh      12-May-04):   }
1.60         (drh      02-Dec-02):   if( !pPager->journalOpen ){
1.107        (drh      12-May-04):     pPager->stmtAutoopen = 1;
1.60         (drh      02-Dec-02):     return SQLITE_OK;
1.60         (drh      02-Dec-02):   }
1.37         (drh      02-Feb-02):   assert( pPager->journalOpen );
1.107        (drh      12-May-04):   pPager->aInStmt = sqliteMalloc( pPager->dbSize/8 + 1 );
1.107        (drh      12-May-04):   if( pPager->aInStmt==0 ){
1.223        (danielk1 06-Dec-05):     /* sqlite3OsLock(pPager->fd, SHARED_LOCK); */
1.37         (drh      02-Feb-02):     return SQLITE_NOMEM;
1.37         (drh      02-Feb-02):   }
1.73         (drh      11-Feb-03): #ifndef NDEBUG
1.222        (drh      30-Nov-05):   rc = sqlite3OsFileSize(pPager->jfd, &pPager->stmtJSize);
1.107        (drh      12-May-04):   if( rc ) goto stmt_begin_failed;
1.138        (danielk1 25-Jun-04):   assert( pPager->stmtJSize == pPager->journalOff );
1.73         (drh      11-Feb-03): #endif
1.138        (danielk1 25-Jun-04):   pPager->stmtJSize = pPager->journalOff;
1.107        (drh      12-May-04):   pPager->stmtSize = pPager->dbSize;
1.138        (danielk1 25-Jun-04):   pPager->stmtHdrOff = 0;
1.143        (danielk1 26-Jun-04):   pPager->stmtCksum = pPager->cksumInit;
1.107        (drh      12-May-04):   if( !pPager->stmtOpen ){
1.292        (danielk1 19-Mar-07):     rc = sqlite3PagerOpentemp(&pPager->stfd);
1.107        (drh      12-May-04):     if( rc ) goto stmt_begin_failed;
1.107        (drh      12-May-04):     pPager->stmtOpen = 1;
1.107        (drh      12-May-04):     pPager->stmtNRec = 0;
1.46         (drh      30-May-02):   }
1.107        (drh      12-May-04):   pPager->stmtInUse = 1;
1.37         (drh      02-Feb-02):   return SQLITE_OK;
1.37         (drh      02-Feb-02):  
1.107        (drh      12-May-04): stmt_begin_failed:
1.107        (drh      12-May-04):   if( pPager->aInStmt ){
1.107        (drh      12-May-04):     sqliteFree(pPager->aInStmt);
1.107        (drh      12-May-04):     pPager->aInStmt = 0;
1.37         (drh      02-Feb-02):   }
1.37         (drh      02-Feb-02):   return rc;
1.37         (drh      02-Feb-02): }
1.37         (drh      02-Feb-02): 
1.37         (drh      02-Feb-02): /*
1.107        (drh      12-May-04): ** Commit a statement.
1.37         (drh      02-Feb-02): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerStmtCommit(Pager *pPager){
1.107        (drh      12-May-04):   if( pPager->stmtInUse ){
1.57         (drh      10-Nov-02):     PgHdr *pPg, *pNext;
1.300        (drh      26-Mar-07):     PAGERTRACE2("STMT-COMMIT %d\n", PAGERID(pPager));
1.169        (drh      31-Oct-04):     if( !MEMDB ){
1.222        (drh      30-Nov-05):       sqlite3OsSeek(pPager->stfd, 0);
1.222        (drh      30-Nov-05):       /* sqlite3OsTruncate(pPager->stfd, 0); */
1.107        (drh      12-May-04):       sqliteFree( pPager->aInStmt );
1.107        (drh      12-May-04):       pPager->aInStmt = 0;
1.325        (danielk1 07-Apr-07):     }else{
1.325        (danielk1 07-Apr-07):       for(pPg=pPager->pStmt; pPg; pPg=pNext){
1.107        (drh      12-May-04):         PgHistory *pHist = PGHDR_TO_HIST(pPg, pPager);
1.325        (danielk1 07-Apr-07):         pNext = pHist->pNextStmt;
1.325        (danielk1 07-Apr-07):         assert( pHist->inStmt );
1.325        (danielk1 07-Apr-07):         pHist->inStmt = 0;
1.325        (danielk1 07-Apr-07):         pHist->pPrevStmt = pHist->pNextStmt = 0;
1.107        (drh      12-May-04):         sqliteFree(pHist->pStmt);
1.107        (drh      12-May-04):         pHist->pStmt = 0;
1.107        (drh      12-May-04):       }
1.38         (drh      02-Feb-02):     }
1.107        (drh      12-May-04):     pPager->stmtNRec = 0;
1.107        (drh      12-May-04):     pPager->stmtInUse = 0;
1.107        (drh      12-May-04):     pPager->pStmt = 0;
1.38         (drh      02-Feb-02):   }
1.107        (drh      12-May-04):   pPager->stmtAutoopen = 0;
1.37         (drh      02-Feb-02):   return SQLITE_OK;
1.37         (drh      02-Feb-02): }
1.37         (drh      02-Feb-02): 
1.37         (drh      02-Feb-02): /*
1.107        (drh      12-May-04): ** Rollback a statement.
1.37         (drh      02-Feb-02): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerStmtRollback(Pager *pPager){
1.37         (drh      02-Feb-02):   int rc;
1.107        (drh      12-May-04):   if( pPager->stmtInUse ){
1.300        (drh      26-Mar-07):     PAGERTRACE2("STMT-ROLLBACK %d\n", PAGERID(pPager));
1.169        (drh      31-Oct-04):     if( MEMDB ){
1.107        (drh      12-May-04):       PgHdr *pPg;
1.325        (danielk1 07-Apr-07):       PgHistory *pHist;
1.325        (danielk1 07-Apr-07):       for(pPg=pPager->pStmt; pPg; pPg=pHist->pNextStmt){
1.325        (danielk1 07-Apr-07):         pHist = PGHDR_TO_HIST(pPg, pPager);
1.107        (drh      12-May-04):         if( pHist->pStmt ){
1.107        (drh      12-May-04):           memcpy(PGHDR_TO_DATA(pPg), pHist->pStmt, pPager->pageSize);
1.107        (drh      12-May-04):           sqliteFree(pHist->pStmt);
1.107        (drh      12-May-04):           pHist->pStmt = 0;
1.107        (drh      12-May-04):         }
1.107        (drh      12-May-04):       }
1.107        (drh      12-May-04):       pPager->dbSize = pPager->stmtSize;
1.323        (danielk1 05-Apr-07):       pager_truncate_cache(pPager);
1.107        (drh      12-May-04):       rc = SQLITE_OK;
1.107        (drh      12-May-04):     }else{
1.107        (drh      12-May-04):       rc = pager_stmt_playback(pPager);
1.107        (drh      12-May-04):     }
1.292        (danielk1 19-Mar-07):     sqlite3PagerStmtCommit(pPager);
1.38         (drh      02-Feb-02):   }else{
1.38         (drh      02-Feb-02):     rc = SQLITE_OK;
1.38         (drh      02-Feb-02):   }
1.107        (drh      12-May-04):   pPager->stmtAutoopen = 0;
1.37         (drh      02-Feb-02):   return rc;
1.80         (drh      06-Apr-03): }
1.80         (drh      06-Apr-03): 
1.80         (drh      06-Apr-03): /*
1.80         (drh      06-Apr-03): ** Return the full pathname of the database file.
1.80         (drh      06-Apr-03): */
1.292        (danielk1 19-Mar-07): const char *sqlite3PagerFilename(Pager *pPager){
1.80         (drh      06-Apr-03):   return pPager->zFilename;
1.126        (danielk1 14-Jun-04): }
1.126        (danielk1 14-Jun-04): 
1.126        (danielk1 14-Jun-04): /*
1.126        (danielk1 14-Jun-04): ** Return the directory of the database file.
1.126        (danielk1 14-Jun-04): */
1.292        (danielk1 19-Mar-07): const char *sqlite3PagerDirname(Pager *pPager){
1.126        (danielk1 14-Jun-04):   return pPager->zDirectory;
1.126        (danielk1 14-Jun-04): }
1.126        (danielk1 14-Jun-04): 
1.126        (danielk1 14-Jun-04): /*
1.126        (danielk1 14-Jun-04): ** Return the full pathname of the journal file.
1.126        (danielk1 14-Jun-04): */
1.292        (danielk1 19-Mar-07): const char *sqlite3PagerJournalname(Pager *pPager){
1.126        (danielk1 14-Jun-04):   return pPager->zJournal;
1.96         (drh      09-Feb-04): }
1.96         (drh      09-Feb-04): 
1.96         (drh      09-Feb-04): /*
1.210        (drh      27-Aug-05): ** Return true if fsync() calls are disabled for this pager.  Return FALSE
1.210        (drh      27-Aug-05): ** if fsync()s are executed normally.
1.210        (drh      27-Aug-05): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerNosync(Pager *pPager){
1.210        (drh      27-Aug-05):   return pPager->noSync;
1.210        (drh      27-Aug-05): }
1.210        (drh      27-Aug-05): 
1.319        (drh      05-Apr-07): #ifdef SQLITE_HAS_CODEC
1.210        (drh      27-Aug-05): /*
1.96         (drh      09-Feb-04): ** Set the codec for this pager
1.96         (drh      09-Feb-04): */
1.292        (danielk1 19-Mar-07): void sqlite3PagerSetCodec(
1.96         (drh      09-Feb-04):   Pager *pPager,
1.261        (drh      06-Mar-06):   void *(*xCodec)(void*,void*,Pgno,int),
1.96         (drh      09-Feb-04):   void *pCodecArg
1.96         (drh      09-Feb-04): ){
1.96         (drh      09-Feb-04):   pPager->xCodec = xCodec;
1.96         (drh      09-Feb-04):   pPager->pCodecArg = pCodecArg;
1.110        (danielk1 03-Jun-04): }
1.319        (drh      05-Apr-07): #endif
1.110        (danielk1 03-Jun-04): 
1.170        (danielk1 02-Nov-04): #ifndef SQLITE_OMIT_AUTOVACUUM
1.170        (danielk1 02-Nov-04): /*
1.345        (drh      16-Jun-07): ** Move the page pPg to location pgno in the file. 
1.170        (danielk1 02-Nov-04): **
1.345        (drh      16-Jun-07): ** There must be no references to the page previously located at
1.345        (drh      16-Jun-07): ** pgno (which we call pPgOld) though that page is allowed to be
1.345        (drh      16-Jun-07): ** in cache.  If the page previous located at pgno is not already
1.345        (drh      16-Jun-07): ** in the rollback journal, it is not put there by by this routine.
1.170        (danielk1 02-Nov-04): **
1.345        (drh      16-Jun-07): ** References to the page pPg remain valid. Updating any
1.345        (drh      16-Jun-07): ** meta-data associated with pPg (i.e. data stored in the nExtra bytes
1.170        (danielk1 02-Nov-04): ** allocated along with the page) is the responsibility of the caller.
1.170        (danielk1 02-Nov-04): **
1.191        (danielk1 09-Mar-05): ** A transaction must be active when this routine is called. It used to be
1.191        (danielk1 09-Mar-05): ** required that a statement transaction was not active, but this restriction
1.191        (danielk1 09-Mar-05): ** has been removed (CREATE INDEX needs to move a page when a statement
1.191        (danielk1 09-Mar-05): ** transaction is active).
1.170        (danielk1 02-Nov-04): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerMovepage(Pager *pPager, DbPage *pPg, Pgno pgno){
1.345        (drh      16-Jun-07):   PgHdr *pPgOld;  /* The page being overwritten. */
1.171        (danielk1 03-Nov-04):   int h;
1.176        (danielk1 08-Nov-04):   Pgno needSyncPgno = 0;
1.170        (danielk1 02-Nov-04): 
1.170        (danielk1 02-Nov-04):   assert( pPg->nRef>0 );
1.170        (danielk1 02-Nov-04): 
1.300        (drh      26-Mar-07):   PAGERTRACE5("MOVE %d page %d (needSync=%d) moves to %d\n", 
1.175        (danielk1 08-Nov-04):       PAGERID(pPager), pPg->pgno, pPg->needSync, pgno);
1.283        (drh      28-Feb-07):   IOTRACE(("MOVE %p %d %d\n", pPager, pPg->pgno, pgno))
1.174        (danielk1 06-Nov-04): 
1.331        (danielk1 28-Apr-07):   pager_get_content(pPg);
1.176        (danielk1 08-Nov-04):   if( pPg->needSync ){
1.176        (danielk1 08-Nov-04):     needSyncPgno = pPg->pgno;
1.347        (drh      16-Jun-07):     assert( pPg->inJournal || (int)pgno>pPager->origDbSize );
1.176        (danielk1 08-Nov-04):     assert( pPg->dirty );
1.178        (danielk1 23-Nov-04):     assert( pPager->needSync );
1.176        (danielk1 08-Nov-04):   }
1.176        (danielk1 08-Nov-04): 
1.170        (danielk1 02-Nov-04):   /* Unlink pPg from it's hash-chain */
1.171        (danielk1 03-Nov-04):   unlinkHashChain(pPager, pPg);
1.170        (danielk1 02-Nov-04): 
1.174        (danielk1 06-Nov-04):   /* If the cache contains a page with page-number pgno, remove it
1.175        (danielk1 08-Nov-04):   ** from it's hash chain. Also, if the PgHdr.needSync was set for 
1.175        (danielk1 08-Nov-04):   ** page pgno before the 'move' operation, it needs to be retained 
1.175        (danielk1 08-Nov-04):   ** for the page moved there.
1.171        (danielk1 03-Nov-04):   */
1.345        (drh      16-Jun-07):   pPg->needSync = 0;
1.170        (danielk1 02-Nov-04):   pPgOld = pager_lookup(pPager, pgno);
1.170        (danielk1 02-Nov-04):   if( pPgOld ){
1.171        (danielk1 03-Nov-04):     assert( pPgOld->nRef==0 );
1.171        (danielk1 03-Nov-04):     unlinkHashChain(pPager, pPgOld);
1.267        (drh      03-May-06):     makeClean(pPgOld);
1.345        (drh      16-Jun-07):     pPg->needSync = pPgOld->needSync;
1.345        (drh      16-Jun-07):   }else{
1.345        (drh      16-Jun-07):     pPg->needSync = 0;
1.345        (drh      16-Jun-07):   }
1.345        (drh      16-Jun-07):   if( pPager->aInJournal && (int)pgno<=pPager->origDbSize ){
1.345        (drh      16-Jun-07):     pPg->inJournal =  (pPager->aInJournal[pgno/8] & (1<<(pgno&7)))!=0;
1.345        (drh      16-Jun-07):   }else{
1.345        (drh      16-Jun-07):     pPg->inJournal = 0;
1.346        (drh      16-Jun-07):     assert( pPg->needSync==0 || (int)pgno>pPager->origDbSize );
1.170        (danielk1 02-Nov-04):   }
1.170        (danielk1 02-Nov-04): 
1.171        (danielk1 03-Nov-04):   /* Change the page number for pPg and insert it into the new hash-chain. */
1.270        (drh      28-Jun-06):   assert( pgno!=0 );
1.171        (danielk1 03-Nov-04):   pPg->pgno = pgno;
1.268        (drh      07-May-06):   h = pgno & (pPager->nHash-1);
1.171        (danielk1 03-Nov-04):   if( pPager->aHash[h] ){
1.171        (danielk1 03-Nov-04):     assert( pPager->aHash[h]->pPrevHash==0 );
1.171        (danielk1 03-Nov-04):     pPager->aHash[h]->pPrevHash = pPg;
1.171        (danielk1 03-Nov-04):   }
1.171        (danielk1 03-Nov-04):   pPg->pNextHash = pPager->aHash[h];
1.171        (danielk1 03-Nov-04):   pPager->aHash[h] = pPg;
1.171        (danielk1 03-Nov-04):   pPg->pPrevHash = 0;
1.171        (danielk1 03-Nov-04): 
1.267        (drh      03-May-06):   makeDirty(pPg);
1.170        (danielk1 02-Nov-04):   pPager->dirtyCache = 1;
1.170        (danielk1 02-Nov-04): 
1.176        (danielk1 08-Nov-04):   if( needSyncPgno ){
1.176        (danielk1 08-Nov-04):     /* If needSyncPgno is non-zero, then the journal file needs to be 
1.176        (danielk1 08-Nov-04):     ** sync()ed before any data is written to database file page needSyncPgno.
1.176        (danielk1 08-Nov-04):     ** Currently, no such page exists in the page-cache and the 
1.176        (danielk1 08-Nov-04):     ** Pager.aInJournal bit has been set. This needs to be remedied by loading
1.176        (danielk1 08-Nov-04):     ** the page into the pager-cache and setting the PgHdr.needSync flag.
1.178        (danielk1 23-Nov-04):     **
1.292        (danielk1 19-Mar-07):     ** The sqlite3PagerGet() call may cause the journal to sync. So make
1.178        (danielk1 23-Nov-04):     ** sure the Pager.needSync flag is set too.
1.176        (danielk1 08-Nov-04):     */
1.176        (danielk1 08-Nov-04):     int rc;
1.292        (danielk1 19-Mar-07):     PgHdr *pPgHdr;
1.178        (danielk1 23-Nov-04):     assert( pPager->needSync );
1.292        (danielk1 19-Mar-07):     rc = sqlite3PagerGet(pPager, needSyncPgno, &pPgHdr);
1.176        (danielk1 08-Nov-04):     if( rc!=SQLITE_OK ) return rc;
1.178        (danielk1 23-Nov-04):     pPager->needSync = 1;
1.292        (danielk1 19-Mar-07):     pPgHdr->needSync = 1;
1.292        (danielk1 19-Mar-07):     pPgHdr->inJournal = 1;
1.292        (danielk1 19-Mar-07):     makeDirty(pPgHdr);
1.292        (danielk1 19-Mar-07):     sqlite3PagerUnref(pPgHdr);
1.176        (danielk1 08-Nov-04):   }
1.176        (danielk1 08-Nov-04): 
1.170        (danielk1 02-Nov-04):   return SQLITE_OK;
1.170        (danielk1 02-Nov-04): }
1.170        (danielk1 02-Nov-04): #endif
1.170        (danielk1 02-Nov-04): 
1.292        (danielk1 19-Mar-07): /*
1.292        (danielk1 19-Mar-07): ** Return a pointer to the data for the specified page.
1.292        (danielk1 19-Mar-07): */
1.292        (danielk1 19-Mar-07): void *sqlite3PagerGetData(DbPage *pPg){
1.292        (danielk1 19-Mar-07):   return PGHDR_TO_DATA(pPg);
1.292        (danielk1 19-Mar-07): }
1.292        (danielk1 19-Mar-07): 
1.292        (danielk1 19-Mar-07): /*
1.292        (danielk1 19-Mar-07): ** Return a pointer to the Pager.nExtra bytes of "extra" space 
1.292        (danielk1 19-Mar-07): ** allocated along with the specified page.
1.292        (danielk1 19-Mar-07): */
1.292        (danielk1 19-Mar-07): void *sqlite3PagerGetExtra(DbPage *pPg){
1.292        (danielk1 19-Mar-07):   Pager *pPager = pPg->pPager;
1.292        (danielk1 19-Mar-07):   return (pPager?PGHDR_TO_EXTRA(pPg, pPager):0);
1.292        (danielk1 19-Mar-07): }
1.292        (danielk1 19-Mar-07): 
1.294        (danielk1 24-Mar-07): /*
1.294        (danielk1 24-Mar-07): ** Get/set the locking-mode for this pager. Parameter eMode must be one
1.294        (danielk1 24-Mar-07): ** of PAGER_LOCKINGMODE_QUERY, PAGER_LOCKINGMODE_NORMAL or 
1.294        (danielk1 24-Mar-07): ** PAGER_LOCKINGMODE_EXCLUSIVE. If the parameter is not _QUERY, then
1.294        (danielk1 24-Mar-07): ** the locking-mode is set to the value specified.
1.294        (danielk1 24-Mar-07): **
1.294        (danielk1 24-Mar-07): ** The returned value is either PAGER_LOCKINGMODE_NORMAL or
1.294        (danielk1 24-Mar-07): ** PAGER_LOCKINGMODE_EXCLUSIVE, indicating the current (possibly updated)
1.294        (danielk1 24-Mar-07): ** locking-mode.
1.294        (danielk1 24-Mar-07): */
1.294        (danielk1 24-Mar-07): int sqlite3PagerLockingMode(Pager *pPager, int eMode){
1.309        (drh      30-Mar-07):   assert( eMode==PAGER_LOCKINGMODE_QUERY
1.309        (drh      30-Mar-07):             || eMode==PAGER_LOCKINGMODE_NORMAL
1.309        (drh      30-Mar-07):             || eMode==PAGER_LOCKINGMODE_EXCLUSIVE );
1.309        (drh      30-Mar-07):   assert( PAGER_LOCKINGMODE_QUERY<0 );
1.309        (drh      30-Mar-07):   assert( PAGER_LOCKINGMODE_NORMAL>=0 && PAGER_LOCKINGMODE_EXCLUSIVE>=0 );
1.309        (drh      30-Mar-07):   if( eMode>=0 && !pPager->tempFile ){
1.294        (danielk1 24-Mar-07):     pPager->exclusiveMode = eMode;
1.294        (danielk1 24-Mar-07):   }
1.294        (danielk1 24-Mar-07):   return (int)pPager->exclusiveMode;
1.294        (danielk1 24-Mar-07): }
1.294        (danielk1 24-Mar-07): 
1.132        (dougcurr 18-Jun-04): #if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
1.114        (drh      09-Jun-04): /*
1.114        (drh      09-Jun-04): ** Return the current state of the file lock for the given pager.
1.114        (drh      09-Jun-04): ** The return value is one of NO_LOCK, SHARED_LOCK, RESERVED_LOCK,
1.114        (drh      09-Jun-04): ** PENDING_LOCK, or EXCLUSIVE_LOCK.
1.114        (drh      09-Jun-04): */
1.292        (danielk1 19-Mar-07): int sqlite3PagerLockstate(Pager *pPager){
1.222        (drh      30-Nov-05):   return sqlite3OsLockState(pPager->fd);
1.114        (drh      09-Jun-04): }
1.114        (drh      09-Jun-04): #endif
1.12         (drh      28-Jun-01): 
1.185        (danielk1 21-Jan-05): #ifdef SQLITE_DEBUG
1.12         (drh      28-Jun-01): /*
1.12         (drh      28-Jun-01): ** Print a listing of all referenced pages and their ref count.
1.12         (drh      28-Jun-01): */
1.292        (danielk1 19-Mar-07): void sqlite3PagerRefdump(Pager *pPager){
1.12         (drh      28-Jun-01):   PgHdr *pPg;
1.12         (drh      28-Jun-01):   for(pPg=pPager->pAll; pPg; pPg=pPg->pNextAll){
1.12         (drh      28-Jun-01):     if( pPg->nRef<=0 ) continue;
1.163        (drh      08-Sep-04):     sqlite3DebugPrintf("PAGE %3d addr=%p nRef=%d\n", 
1.163        (drh      08-Sep-04):        pPg->pgno, PGHDR_TO_DATA(pPg), pPg->nRef);
1.12         (drh      28-Jun-01):   }
1.12         (drh      28-Jun-01): }
1.12         (drh      28-Jun-01): #endif
1.202        (drh      28-Apr-05): 
1.202        (drh      28-Apr-05): #endif /* SQLITE_OMIT_DISKIO */
